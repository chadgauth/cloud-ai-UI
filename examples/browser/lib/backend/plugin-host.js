/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../packages/core/lib/browser/endpoint.js":
/*!***************************************************!*\
  !*** ../../packages/core/lib/browser/endpoint.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2017 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Endpoint = void 0;
const uri_1 = __webpack_require__(/*! ../common/uri */ "../../packages/core/lib/common/uri.js");
/**
 * An endpoint provides URLs for http and ws, based on configuration and defaults.
 */
class Endpoint {
    constructor(options = {}, location = self.location) {
        this.options = options;
        this.location = location;
    }
    getWebSocketUrl() {
        return new uri_1.default(`${this.wsScheme}//${this.host}${this.pathname}${this.path}`);
    }
    getRestUrl() {
        return new uri_1.default(`${this.httpScheme}//${this.host}${this.pathname}${this.path}`);
    }
    get pathname() {
        if (this.location.protocol === Endpoint.PROTO_FILE) {
            return '';
        }
        if (this.location.pathname === '/') {
            return '';
        }
        if (this.location.pathname.endsWith('/')) {
            return this.location.pathname.substring(0, this.location.pathname.length - 1);
        }
        return this.location.pathname;
    }
    get host() {
        if (this.options.host) {
            return this.options.host;
        }
        if (this.location.host) {
            return this.location.host;
        }
        return 'localhost:' + this.port;
    }
    get origin() {
        return `${this.httpScheme}//${this.host}`;
    }
    get port() {
        return this.getSearchParam('port', '3000');
    }
    getSearchParam(name, defaultValue) {
        const search = this.location.search;
        if (!search) {
            return defaultValue;
        }
        return search.substring(1).split('&')
            .filter(value => value.startsWith(name + '='))
            .map(value => {
            const encoded = value.substring(name.length + 1);
            return decodeURIComponent(encoded);
        })[0] || defaultValue;
    }
    get wsScheme() {
        if (this.options.wsScheme) {
            return this.options.wsScheme;
        }
        return this.httpScheme === Endpoint.PROTO_HTTPS ? Endpoint.PROTO_WSS : Endpoint.PROTO_WS;
    }
    /**
     * The HTTP/HTTPS scheme of the endpoint, or the user defined one.
     * See: `Endpoint.Options.httpScheme`.
     */
    get httpScheme() {
        if (this.options.httpScheme) {
            return this.options.httpScheme;
        }
        if (this.location.protocol === Endpoint.PROTO_HTTP ||
            this.location.protocol === Endpoint.PROTO_HTTPS) {
            return this.location.protocol;
        }
        return Endpoint.PROTO_HTTP;
    }
    get path() {
        if (this.options.path) {
            if (this.options.path.startsWith('/')) {
                return this.options.path;
            }
            else {
                return '/' + this.options.path;
            }
        }
        return '';
    }
}
exports.Endpoint = Endpoint;
Endpoint.PROTO_HTTPS = 'https:';
Endpoint.PROTO_HTTP = 'http:';
Endpoint.PROTO_WS = 'ws:';
Endpoint.PROTO_WSS = 'wss:';
Endpoint.PROTO_FILE = 'file:';
(function (Endpoint) {
    class Options {
    }
    Endpoint.Options = Options;
    // Necessary for running tests with dependency on TS lib on node
    // FIXME figure out how to mock with ts-node
    class Location {
    }
    Endpoint.Location = Location;
})(Endpoint = exports.Endpoint || (exports.Endpoint = {}));


/***/ }),

/***/ "../../packages/core/lib/common/glob.js":
/*!**********************************************!*\
  !*** ../../packages/core/lib/common/glob.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
// copied from https://github.com/Microsoft/vscode/blob/bf7ac9201e7a7d01741d4e6e64b5dc9f3197d97b/src/vs/base/common/glob.ts
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPathTerms = exports.getBasenameTerms = exports.parseToAsync = exports.isRelativePattern = exports.hasSiblingFn = exports.hasSiblingPromiseFn = exports.parse = exports.match = exports.splitGlobAware = exports.getEmptyExpression = void 0;
const strings = __webpack_require__(/*! ./strings */ "../../packages/core/lib/common/strings.js");
const paths = __webpack_require__(/*! ./paths */ "../../packages/core/lib/common/paths.js");
function getEmptyExpression() {
    return Object.create(null);
}
exports.getEmptyExpression = getEmptyExpression;
const GLOBSTAR = '**';
const GLOB_SPLIT = '/';
const PATH_REGEX = '[/\\\\]'; // any slash or backslash
const NO_PATH_REGEX = '[^/\\\\]'; // any non-slash and non-backslash
const ALL_FORWARD_SLASHES = /\//g;
function starsToRegExp(starCount) {
    switch (starCount) {
        case 0:
            return '';
        case 1:
            return `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \) - non greedy (?)
        default:
            // Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times
            // Group is non capturing because we don't need to capture at all (?:...)
            // Overall we use non-greedy matching because it could be that we match too much
            return `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}|${PATH_REGEX}${NO_PATH_REGEX}+)*?`;
    }
}
function splitGlobAware(pattern, splitChar) {
    if (!pattern) {
        return [];
    }
    const segments = [];
    let inBraces = false;
    let inBrackets = false;
    let char;
    let curVal = '';
    for (let i = 0; i < pattern.length; i++) {
        char = pattern[i];
        switch (char) {
            case splitChar:
                if (!inBraces && !inBrackets) {
                    segments.push(curVal);
                    curVal = '';
                    continue;
                }
                break;
            case '{':
                inBraces = true;
                break;
            case '}':
                inBraces = false;
                break;
            case '[':
                inBrackets = true;
                break;
            case ']':
                inBrackets = false;
                break;
        }
        curVal += char;
    }
    // Tail
    if (curVal) {
        segments.push(curVal);
    }
    return segments;
}
exports.splitGlobAware = splitGlobAware;
function parseRegExp(pattern) {
    if (!pattern) {
        return '';
    }
    let regEx = '';
    // Split up into segments for each slash found
    // eslint-disable-next-line prefer-const
    let segments = splitGlobAware(pattern, GLOB_SPLIT);
    // Special case where we only have globstars
    if (segments.every(s => s === GLOBSTAR)) {
        regEx = '.*';
    }
    // Build regex over segments
    // tslint:disable-next-line:one-line
    else {
        let previousSegmentWasGlobStar = false;
        segments.forEach((segment, index) => {
            // Globstar is special
            if (segment === GLOBSTAR) {
                // if we have more than one globstar after another, just ignore it
                if (!previousSegmentWasGlobStar) {
                    regEx += starsToRegExp(2);
                    previousSegmentWasGlobStar = true;
                }
                return;
            }
            // States
            let inBraces = false;
            let braceVal = '';
            let inBrackets = false;
            let bracketVal = '';
            let char;
            for (let i = 0; i < segment.length; i++) {
                char = segment[i];
                // Support brace expansion
                if (char !== '}' && inBraces) {
                    braceVal += char;
                    continue;
                }
                // Support brackets
                if (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {
                    let res;
                    // range operator
                    if (char === '-') {
                        res = char;
                    }
                    // negation operator (only valid on first index in bracket)
                    // tslint:disable-next-line:one-line
                    else if ((char === '^' || char === '!') && !bracketVal) {
                        res = '^';
                    }
                    // glob split matching is not allowed within character ranges
                    // see http://man7.org/linux/man-pages/man7/glob.7.html
                    // tslint:disable-next-line:one-line
                    else if (char === GLOB_SPLIT) {
                        res = '';
                    }
                    // anything else gets escaped
                    // tslint:disable-next-line:one-line
                    else {
                        res = strings.escapeRegExpCharacters(char);
                    }
                    bracketVal += res;
                    continue;
                }
                switch (char) {
                    case '{':
                        inBraces = true;
                        continue;
                    case '[':
                        inBrackets = true;
                        continue;
                    case '}':
                        // eslint-disable-next-line prefer-const
                        let choices = splitGlobAware(braceVal, ',');
                        // Converts {foo,bar} => [foo|bar]
                        // eslint-disable-next-line prefer-const
                        let braceRegExp = `(?:${choices.map(c => parseRegExp(c)).join('|')})`;
                        regEx += braceRegExp;
                        inBraces = false;
                        braceVal = '';
                        break;
                    case ']':
                        regEx += ('[' + bracketVal + ']');
                        inBrackets = false;
                        bracketVal = '';
                        break;
                    case '?':
                        regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \)
                        continue;
                    case '*':
                        regEx += starsToRegExp(1);
                        continue;
                    default:
                        regEx += strings.escapeRegExpCharacters(char);
                }
            }
            // Tail: Add the slash we had split on if there is more to come and the remaining pattern is not a globstar
            // For example if pattern: some/**/*.js we want the "/" after some to be included in the RegEx to prevent
            // a folder called "something" to match as well.
            // However, if pattern: some/**, we tolerate that we also match on "something" because our globstar behavior
            // is to match 0-N segments.
            if (index < segments.length - 1 && (segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)) {
                regEx += PATH_REGEX;
            }
            // reset state
            previousSegmentWasGlobStar = false;
        });
    }
    return regEx;
}
// regexes to check for trivial glob patterns that just check for String#endsWith
const T1 = /^\*\*\/\*\.[\w\.-]+$/; // **/*.something
const T2 = /^\*\*\/([\w\.-]+)\/?$/; // **/something
const T3 = /^{\*\*\/[\*\.]?[\w\.-]+\/?(,\*\*\/[\*\.]?[\w\.-]+\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}
const T3_2 = /^{\*\*\/[\*\.]?[\w\.-]+(\/(\*\*)?)?(,\*\*\/[\*\.]?[\w\.-]+(\/(\*\*)?)?)*}$/; // Like T3, with optional trailing /**
const T4 = /^\*\*((\/[\w\.-]+)+)\/?$/; // **/something/else
const T5 = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/; // something/else
const CACHE = new Map(); // new LRUCache<string, ParsedStringPattern>(10000); // bounded to 10000 elements
const FALSE = function () {
    return false;
};
const NULL = function () {
    return null;
};
function parsePattern(arg1, options) {
    if (!arg1) {
        return NULL;
    }
    // Handle IRelativePattern
    let pattern;
    if (typeof arg1 !== 'string') {
        pattern = arg1.pattern;
    }
    else {
        pattern = arg1;
    }
    // Whitespace trimming
    pattern = pattern.trim();
    // Check cache
    const patternKey = `${pattern}_${!!options.trimForExclusions}`;
    let parsedPattern = CACHE.get(patternKey);
    if (parsedPattern) {
        return wrapRelativePattern(parsedPattern, arg1);
    }
    // Check for Trivias
    let match;
    if (T1.test(pattern)) { // common pattern: **/*.txt just need endsWith check
        const base = pattern.substring(4); // '**/*'.length === 4
        parsedPattern = function (path, basename) {
            return path && strings.endsWith(path, base) ? pattern : null;
        };
    }
    else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check
        parsedPattern = trivia2(match[1], pattern);
    }
    else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}
        parsedPattern = trivia3(pattern, options);
    }
    else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check
        parsedPattern = trivia4and5(match[1].substring(1), pattern, true);
    }
    else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check
        parsedPattern = trivia4and5(match[1], pattern, false);
    }
    // Otherwise convert to pattern
    // tslint:disable-next-line:one-line
    else {
        parsedPattern = toRegExp(pattern);
    }
    // Cache
    CACHE.set(patternKey, parsedPattern);
    return wrapRelativePattern(parsedPattern, arg1);
}
function wrapRelativePattern(parsedPattern, arg2) {
    if (typeof arg2 === 'string') {
        return parsedPattern;
    }
    return function (path, basename) {
        if (!paths.isEqualOrParent(path, arg2.base)) {
            return null;
        }
        return parsedPattern(paths.normalize(arg2.pathToRelative(arg2.base, path)), basename);
    };
}
function trimForExclusions(pattern, options) {
    return options.trimForExclusions && strings.endsWith(pattern, '/**') ? pattern.substring(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later
}
// common pattern: **/some.txt just need basename check
function trivia2(base, originalPattern) {
    const slashBase = `/${base}`;
    const backslashBase = `\\${base}`;
    const parsedPattern = function (path, basename) {
        if (!path) {
            return null;
        }
        if (basename) {
            return basename === base ? originalPattern : null;
        }
        return path === base || strings.endsWith(path, slashBase) || strings.endsWith(path, backslashBase) ? originalPattern : null;
    };
    const basenames = [base];
    parsedPattern.basenames = basenames;
    parsedPattern.patterns = [originalPattern];
    parsedPattern.allBasenames = basenames;
    return parsedPattern;
}
// repetition of common patterns (see above) {**/*.txt,**/*.png}
function trivia3(pattern, options) {
    const parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',')
        .map(pattern => parsePattern(pattern, options))
        .filter(pattern => pattern !== NULL), pattern);
    const n = parsedPatterns.length;
    if (!n) {
        return NULL;
    }
    if (n === 1) {
        return parsedPatterns[0];
    }
    const parsedPattern = function (path, basename) {
        for (let i = 0, n = parsedPatterns.length; i < n; i++) {
            if (parsedPatterns[i](path, basename)) {
                return pattern;
            }
        }
        return null;
    };
    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);
    // const withBasenames = arrays.first(parsedPatterns, pattern => !!(<ParsedStringPattern>pattern).allBasenames);
    if (withBasenames) {
        parsedPattern.allBasenames = withBasenames.allBasenames;
    }
    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);
    if (allPaths.length) {
        parsedPattern.allPaths = allPaths;
    }
    return parsedPattern;
}
// common patterns: **/something/else just need endsWith check, something/else just needs and equals check
function trivia4and5(path, pattern, matchPathEnds) {
    const nativePath = paths.nativeSep !== paths.sep ? path.replace(ALL_FORWARD_SLASHES, paths.nativeSep) : path;
    const nativePathEnd = paths.nativeSep + nativePath;
    // eslint-disable-next-line @typescript-eslint/no-shadow
    const parsedPattern = matchPathEnds ? function (path, basename) {
        return path && (path === nativePath || strings.endsWith(path, nativePathEnd)) ? pattern : null;
        // eslint-disable-next-line @typescript-eslint/no-shadow
    } : function (path, basename) {
        return path && path === nativePath ? pattern : null;
    };
    parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + path];
    return parsedPattern;
}
function toRegExp(pattern) {
    try {
        const regExp = new RegExp(`^${parseRegExp(pattern)}$`);
        return function (path, basename) {
            regExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!
            return path && regExp.test(path) ? pattern : null;
        };
    }
    catch (error) {
        return NULL;
    }
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function match(arg1, path, hasSibling) {
    if (!arg1 || !path) {
        return false;
    }
    return parse(arg1)(path, undefined, hasSibling);
}
exports.match = match;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function parse(arg1, options = {}) {
    if (!arg1) {
        return FALSE;
    }
    // Glob with String
    if (typeof arg1 === 'string' || isRelativePattern(arg1)) {
        const parsedPattern = parsePattern(arg1, options);
        if (parsedPattern === NULL) {
            return FALSE;
        }
        const resultPattern = function (path, basename) {
            return !!parsedPattern(path, basename);
        };
        if (parsedPattern.allBasenames) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            resultPattern.allBasenames = parsedPattern.allBasenames;
        }
        if (parsedPattern.allPaths) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            resultPattern.allPaths = parsedPattern.allPaths;
        }
        return resultPattern;
    }
    // Glob with Expression
    return parsedExpression(arg1, options);
}
exports.parse = parse;
function hasSiblingPromiseFn(siblingsFn) {
    if (!siblingsFn) {
        return undefined;
    }
    let siblings;
    return (name) => {
        if (!siblings) {
            siblings = (siblingsFn() || Promise.resolve([]))
                .then(list => list ? listToMap(list) : {});
        }
        return siblings.then(map => !!map[name]);
    };
}
exports.hasSiblingPromiseFn = hasSiblingPromiseFn;
function hasSiblingFn(siblingsFn) {
    if (!siblingsFn) {
        return undefined;
    }
    let siblings;
    return (name) => {
        if (!siblings) {
            const list = siblingsFn();
            siblings = list ? listToMap(list) : {};
        }
        return !!siblings[name];
    };
}
exports.hasSiblingFn = hasSiblingFn;
function listToMap(list) {
    const map = {};
    for (const key of list) {
        map[key] = true;
    }
    return map;
}
function isRelativePattern(obj) {
    const rp = obj;
    return !!rp && typeof rp === 'object' && typeof rp.base === 'string' && typeof rp.pattern === 'string' && typeof rp.pathToRelative === 'function';
}
exports.isRelativePattern = isRelativePattern;
/**
 * Same as `parse`, but the ParsedExpression is guaranteed to return a Promise
 */
function parseToAsync(expression, options) {
    // eslint-disable-next-line @typescript-eslint/no-shadow
    const parsedExpression = parse(expression, options);
    return (path, basename, hasSibling) => {
        const result = parsedExpression(path, basename, hasSibling);
        return result instanceof Promise ? result : Promise.resolve(result);
    };
}
exports.parseToAsync = parseToAsync;
function getBasenameTerms(patternOrExpression) {
    return patternOrExpression.allBasenames || [];
}
exports.getBasenameTerms = getBasenameTerms;
function getPathTerms(patternOrExpression) {
    return patternOrExpression.allPaths || [];
}
exports.getPathTerms = getPathTerms;
function parsedExpression(expression, options) {
    const parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)
        .map(pattern => parseExpressionPattern(pattern, expression[pattern], options))
        .filter(pattern => pattern !== NULL));
    const n = parsedPatterns.length;
    if (!n) {
        return NULL;
    }
    if (!parsedPatterns.some(parsedPattern => parsedPattern.requiresSiblings)) {
        if (n === 1) {
            return parsedPatterns[0];
        }
        // eslint-disable-next-line @typescript-eslint/no-shadow
        const resultExpression = function (path, basename) {
            // eslint-disable-next-line @typescript-eslint/no-shadow
            // tslint:disable-next-line:one-variable-per-declaration
            for (let i = 0, n = parsedPatterns.length; i < n; i++) {
                // Pattern matches path
                const result = parsedPatterns[i](path, basename);
                if (result) {
                    return result;
                }
            }
            return null;
        };
        // eslint-disable-next-line @typescript-eslint/no-shadow
        const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);
        if (withBasenames) {
            resultExpression.allBasenames = withBasenames.allBasenames;
        }
        // eslint-disable-next-line @typescript-eslint/no-shadow
        const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);
        if (allPaths.length) {
            resultExpression.allPaths = allPaths;
        }
        return resultExpression;
    }
    const resultExpression = function (path, basename, hasSibling) {
        let name = null;
        // eslint-disable-next-line @typescript-eslint/no-shadow
        for (let i = 0, n = parsedPatterns.length; i < n; i++) {
            // Pattern matches path
            const parsedPattern = parsedPatterns[i];
            if (parsedPattern.requiresSiblings && hasSibling) {
                if (!basename) {
                    basename = paths.basename(path);
                }
                if (!name) {
                    name = basename.substring(0, basename.length - paths.extname(path).length);
                }
            }
            const result = parsedPattern(path, basename, name, hasSibling);
            if (result) {
                return result;
            }
        }
        return null;
    };
    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);
    if (withBasenames) {
        resultExpression.allBasenames = withBasenames.allBasenames;
    }
    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);
    if (allPaths.length) {
        resultExpression.allPaths = allPaths;
    }
    return resultExpression;
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function parseExpressionPattern(pattern, value, options) {
    if (value === false) {
        return NULL; // pattern is disabled
    }
    const parsedPattern = parsePattern(pattern, options);
    if (parsedPattern === NULL) {
        return NULL;
    }
    // Expression Pattern is <boolean>
    if (typeof value === 'boolean') {
        return parsedPattern;
    }
    // Expression Pattern is <SiblingClause>
    if (value) {
        const when = value.when;
        if (typeof when === 'string') {
            const result = (path, basename, name, hasSibling) => {
                if (!hasSibling || !parsedPattern(path, basename)) {
                    return null;
                }
                const clausePattern = when.replace('$(basename)', name);
                const matched = hasSibling(clausePattern);
                return matched instanceof Promise ?
                    matched.then(m => m ? pattern : null) :
                    matched ? pattern : null;
            };
            result.requiresSiblings = true;
            return result;
        }
    }
    // Expression is Anything
    return parsedPattern;
}
function aggregateBasenameMatches(parsedPatterns, result) {
    const basenamePatterns = parsedPatterns.filter(parsedPattern => !!parsedPattern.basenames);
    if (basenamePatterns.length < 2) {
        return parsedPatterns;
    }
    const basenames = basenamePatterns.reduce((all, current) => all.concat(current.basenames), []);
    let patterns;
    if (result) {
        patterns = [];
        // tslint:disable-next-line:one-variable-per-declaration
        for (let i = 0, n = basenames.length; i < n; i++) {
            patterns.push(result);
        }
    }
    else {
        patterns = basenamePatterns.reduce((all, current) => all.concat(current.patterns), []);
    }
    const aggregate = function (path, basename) {
        if (!path) {
            return null;
        }
        if (!basename) {
            let i;
            for (i = path.length; i > 0; i--) {
                const ch = path.charCodeAt(i - 1);
                if (ch === 47 /* Slash */ || ch === 92 /* Backslash */) {
                    break;
                }
            }
            basename = path.substring(i);
        }
        const index = basenames.indexOf(basename);
        return index !== -1 ? patterns[index] : null;
    };
    aggregate.basenames = basenames;
    aggregate.patterns = patterns;
    aggregate.allBasenames = basenames;
    const aggregatedPatterns = parsedPatterns.filter(parsedPattern => !parsedPattern.basenames);
    aggregatedPatterns.push(aggregate);
    return aggregatedPatterns;
}


/***/ }),

/***/ "../../packages/core/lib/node/dynamic-require.js":
/*!*******************************************************!*\
  !*** ../../packages/core/lib/node/dynamic-require.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.removeFromCache = exports.dynamicRequire = void 0;
const nodeRequire = typeof require !== 'undefined' ? require : __webpack_require__("../../packages/core/lib/node sync recursive");
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function dynamicRequire(id) {
    if (typeof id !== 'string') {
        throw new TypeError('module id must be a string');
    }
    if (id.startsWith('.')) {
        throw new Error(`module id cannot be a relative path, id: "${id}"`);
    }
    return nodeRequire(id);
}
exports.dynamicRequire = dynamicRequire;
/**
 * Remove all references to a module from Node's module cache.
 * @param filter callback to filter modules from the cache: return `true` to remove the module from the cache.
 */
function removeFromCache(filter) {
    Object.entries(nodeRequire.cache).forEach(([key, mod]) => {
        if (!mod || mod.id.endsWith('.node')) {
            return;
        }
        if (filter(mod)) {
            delete nodeRequire.cache[key];
            delete mod.exports;
            mod.children.length = 0;
            return;
        }
        mod.children.splice(0, mod.children.length, ...mod.children.filter(child => {
            if (filter(child)) {
                delete child.exports;
                child.children.length = 0;
                return false;
            }
            return true;
        }));
    });
}
exports.removeFromCache = removeFromCache;


/***/ }),

/***/ "../../packages/core/shared/reflect-metadata/index.js":
/*!************************************************************!*\
  !*** ../../packages/core/shared/reflect-metadata/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! reflect-metadata */ "../../node_modules/reflect-metadata/Reflect.js");


/***/ }),

/***/ "../../packages/debug/lib/common/debug-uri-utils.js":
/*!**********************************************************!*\
  !*** ../../packages/debug/lib/common/debug-uri-utils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/********************************************************************************
 * Copyright (C) 2022 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SCHEME_PATTERN = exports.DEBUG_SCHEME = void 0;
/**
 * The URI scheme for debug URIs.
 */
exports.DEBUG_SCHEME = 'debug';
/**
 * The pattern for URI schemes.
 */
exports.SCHEME_PATTERN = /^[a-zA-Z][a-zA-Z0-9\+\-\.]+:/;


/***/ }),

/***/ "../../packages/debug/lib/common/inline-debug-adapter.js":
/*!***************************************************************!*\
  !*** ../../packages/debug/lib/common/inline-debug-adapter.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlineDebugAdapter = void 0;
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../packages/core/lib/common/event.js");
/**
 * A debug adapter for using the inline implementation from a plugin.
 */
class InlineDebugAdapter {
    constructor(debugAdapter) {
        this.debugAdapter = debugAdapter;
        this.messageReceivedEmitter = new event_1.Emitter();
        this.onMessageReceived = this.messageReceivedEmitter.event;
        this.onError = event_1.Event.None;
        this.closeEmitter = new event_1.Emitter();
        this.onClose = this.closeEmitter.event;
        this.debugAdapter.onDidSendMessage(msg => {
            this.messageReceivedEmitter.fire(JSON.stringify(msg));
        });
    }
    async start() {
    }
    send(message) {
        this.debugAdapter.handleMessage(JSON.parse(message));
    }
    async stop() {
        this.debugAdapter.dispose();
    }
}
exports.InlineDebugAdapter = InlineDebugAdapter;


/***/ }),

/***/ "../../packages/editor/lib/common/language-selector.js":
/*!*************************************************************!*\
  !*** ../../packages/editor/lib/common/language-selector.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.score = void 0;
const glob_1 = __webpack_require__(/*! @theia/core/lib/common/glob */ "../../packages/core/lib/common/glob.js");
function score(selector, uriScheme, path, candidateLanguage, candidateIsSynchronized) {
    if (Array.isArray(selector)) {
        let ret = 0;
        for (const filter of selector) {
            const value = score(filter, uriScheme, path, candidateLanguage, candidateIsSynchronized);
            if (value === 10) {
                return value;
            }
            if (value > ret) {
                ret = value;
            }
        }
        return ret;
    }
    else if (typeof selector === 'string') {
        if (!candidateIsSynchronized) {
            return 0;
        }
        if (selector === '*') {
            return 5;
        }
        else if (selector === candidateLanguage) {
            return 10;
        }
        else {
            return 0;
        }
    }
    else if (selector) {
        const { language, pattern, scheme, hasAccessToAllModels } = selector;
        if (!candidateIsSynchronized && !hasAccessToAllModels) {
            return 0;
        }
        let result = 0;
        if (scheme) {
            if (scheme === uriScheme) {
                result = 10;
            }
            else if (scheme === '*') {
                result = 5;
            }
            else {
                return 0;
            }
        }
        if (language) {
            if (language === candidateLanguage) {
                result = 10;
            }
            else if (language === '*') {
                result = Math.max(result, 5);
            }
            else {
                return 0;
            }
        }
        if (pattern) {
            if (pattern === path || (0, glob_1.match)(pattern, path)) {
                result = 10;
            }
            else {
                return 0;
            }
        }
        return result;
    }
    else {
        return 0;
    }
}
exports.score = score;


/***/ }),

/***/ "../../packages/notebook/lib/common/index.js":
/*!***************************************************!*\
  !*** ../../packages/notebook/lib/common/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./notebook-common */ "../../packages/notebook/lib/common/notebook-common.js"), exports);
__exportStar(__webpack_require__(/*! ./notebook-range */ "../../packages/notebook/lib/common/notebook-range.js"), exports);


/***/ }),

/***/ "../../packages/notebook/lib/common/notebook-common.js":
/*!*************************************************************!*\
  !*** ../../packages/notebook/lib/common/notebook-common.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CellUri = exports.isTextStreamMime = exports.CellExecutionUpdateType = exports.NotebookCellExecutionState = exports.SelectionStateType = exports.NotebookCellsChangeType = exports.CellKind = void 0;
const buffer_1 = __webpack_require__(/*! @theia/core/lib/common/buffer */ "../../packages/core/lib/common/buffer.js");
var CellKind;
(function (CellKind) {
    CellKind[CellKind["Markup"] = 1] = "Markup";
    CellKind[CellKind["Code"] = 2] = "Code";
})(CellKind = exports.CellKind || (exports.CellKind = {}));
;
var NotebookCellsChangeType;
(function (NotebookCellsChangeType) {
    NotebookCellsChangeType[NotebookCellsChangeType["ModelChange"] = 1] = "ModelChange";
    NotebookCellsChangeType[NotebookCellsChangeType["Move"] = 2] = "Move";
    NotebookCellsChangeType[NotebookCellsChangeType["ChangeCellLanguage"] = 5] = "ChangeCellLanguage";
    NotebookCellsChangeType[NotebookCellsChangeType["Initialize"] = 6] = "Initialize";
    NotebookCellsChangeType[NotebookCellsChangeType["ChangeCellMetadata"] = 7] = "ChangeCellMetadata";
    NotebookCellsChangeType[NotebookCellsChangeType["Output"] = 8] = "Output";
    NotebookCellsChangeType[NotebookCellsChangeType["OutputItem"] = 9] = "OutputItem";
    NotebookCellsChangeType[NotebookCellsChangeType["ChangeCellContent"] = 10] = "ChangeCellContent";
    NotebookCellsChangeType[NotebookCellsChangeType["ChangeDocumentMetadata"] = 11] = "ChangeDocumentMetadata";
    NotebookCellsChangeType[NotebookCellsChangeType["ChangeCellInternalMetadata"] = 12] = "ChangeCellInternalMetadata";
    // ChangeCellMime = 13,
    NotebookCellsChangeType[NotebookCellsChangeType["Unknown"] = 100] = "Unknown";
})(NotebookCellsChangeType = exports.NotebookCellsChangeType || (exports.NotebookCellsChangeType = {}));
var SelectionStateType;
(function (SelectionStateType) {
    SelectionStateType[SelectionStateType["Handle"] = 0] = "Handle";
    SelectionStateType[SelectionStateType["Index"] = 1] = "Index";
})(SelectionStateType = exports.SelectionStateType || (exports.SelectionStateType = {}));
;
;
;
var NotebookCellExecutionState;
(function (NotebookCellExecutionState) {
    NotebookCellExecutionState[NotebookCellExecutionState["Unconfirmed"] = 1] = "Unconfirmed";
    NotebookCellExecutionState[NotebookCellExecutionState["Pending"] = 2] = "Pending";
    NotebookCellExecutionState[NotebookCellExecutionState["Executing"] = 3] = "Executing";
})(NotebookCellExecutionState = exports.NotebookCellExecutionState || (exports.NotebookCellExecutionState = {}));
var CellExecutionUpdateType;
(function (CellExecutionUpdateType) {
    CellExecutionUpdateType[CellExecutionUpdateType["Output"] = 1] = "Output";
    CellExecutionUpdateType[CellExecutionUpdateType["OutputItems"] = 2] = "OutputItems";
    CellExecutionUpdateType[CellExecutionUpdateType["ExecutionState"] = 3] = "ExecutionState";
})(CellExecutionUpdateType = exports.CellExecutionUpdateType || (exports.CellExecutionUpdateType = {}));
/**
 * Whether the provided mime type is a text stream like `stdout`, `stderr`.
 */
function isTextStreamMime(mimeType) {
    return ['application/vnd.code.notebook.stdout', 'application/vnd.code.notebook.stderr'].includes(mimeType);
}
exports.isTextStreamMime = isTextStreamMime;
var CellUri;
(function (CellUri) {
    CellUri.scheme = 'vscode-notebook-cell';
    const _lengths = ['W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f'];
    const _padRegexp = new RegExp(`^[${_lengths.join('')}]+`);
    const _radix = 7;
    function generate(notebook, handle) {
        const s = handle.toString(_radix);
        const p = s.length < _lengths.length ? _lengths[s.length - 1] : 'z';
        const fragment = `${p}${s}s${Buffer.from(buffer_1.BinaryBuffer.fromString(notebook.scheme).buffer).toString('base64')} `;
        return notebook.withScheme(CellUri.scheme).withFragment(fragment);
    }
    CellUri.generate = generate;
    function parse(cell) {
        if (cell.scheme !== CellUri.scheme) {
            return undefined;
        }
        const idx = cell.fragment.indexOf('s');
        if (idx < 0) {
            return undefined;
        }
        const handle = parseInt(cell.fragment.substring(0, idx).replace(_padRegexp, ''), _radix);
        const parsedScheme = Buffer.from(cell.fragment.substring(idx + 1), 'base64').toString();
        if (isNaN(handle)) {
            return undefined;
        }
        return {
            handle,
            notebook: cell.withScheme(parsedScheme).withoutFragment()
        };
    }
    CellUri.parse = parse;
    function generateCellPropertyUri(notebook, handle, cellScheme) {
        return CellUri.generate(notebook, handle).withScheme(cellScheme);
    }
    CellUri.generateCellPropertyUri = generateCellPropertyUri;
    function parseCellPropertyUri(uri, propertyScheme) {
        if (uri.scheme !== propertyScheme) {
            return undefined;
        }
        return CellUri.parse(uri.withScheme(CellUri.scheme));
    }
    CellUri.parseCellPropertyUri = parseCellPropertyUri;
})(CellUri = exports.CellUri || (exports.CellUri = {}));


/***/ }),

/***/ "../../packages/notebook/lib/common/notebook-range.js":
/*!************************************************************!*\
  !*** ../../packages/notebook/lib/common/notebook-range.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 Typefox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../../packages/plugin-ext/lib/common/assert.js":
/*!******************************************************!*\
  !*** ../../packages/plugin-ext/lib/common/assert.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ok = void 0;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function ok(val, message) {
    if (!val || val === null) {
        throw new Error(message ? `Assertion failed (${message})` : 'Assertion failed');
    }
}
exports.ok = ok;


/***/ }),

/***/ "../../packages/plugin-ext/lib/common/cache.js":
/*!*****************************************************!*\
  !*** ../../packages/plugin-ext/lib/common/cache.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Cache = void 0;
// copied from https://github.com/microsoft/vscode/blob/53eac52308c4611000a171cc7bf1214293473c78/src/vs/workbench/api/common/cache.ts
class Cache {
    constructor(id) {
        this.id = id;
        this._data = new Map();
        this._idPool = 1;
    }
    add(item) {
        const id = this._idPool++;
        this._data.set(id, item);
        this.logDebugInfo();
        return id;
    }
    get(pid, id) {
        return this._data.has(pid) ? this._data.get(pid)[id] : undefined;
    }
    delete(id) {
        this._data.delete(id);
        this.logDebugInfo();
    }
    logDebugInfo() {
        if (!Cache.enableDebugLogging) {
            return;
        }
        console.log(`${this.id} cache size  ${this._data.size}`);
    }
}
exports.Cache = Cache;
Cache.enableDebugLogging = false;


/***/ }),

/***/ "../../packages/plugin-ext/lib/common/character-classifier.js":
/*!********************************************************************!*\
  !*** ../../packages/plugin-ext/lib/common/character-classifier.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// based on https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/editor/common/core/characterClassifier.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CharacterClassifier = void 0;
const uint_1 = __webpack_require__(/*! ./uint */ "../../packages/plugin-ext/lib/common/uint.js");
/**
 * A fast character classifier that uses a compact array for ASCII values.
 */
class CharacterClassifier {
    constructor(_defaultValue) {
        const defaultValue = (0, uint_1.toUint8)(_defaultValue);
        this._defaultValue = defaultValue;
        this._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);
        this._map = new Map();
    }
    static _createAsciiMap(defaultValue) {
        const asciiMap = new Uint8Array(256);
        for (let i = 0; i < 256; i++) {
            asciiMap[i] = defaultValue;
        }
        return asciiMap;
    }
    set(charCode, _value) {
        const value = (0, uint_1.toUint8)(_value);
        if (charCode >= 0 && charCode < 256) {
            this._asciiMap[charCode] = value;
        }
        else {
            this._map.set(charCode, value);
        }
    }
    get(charCode) {
        if (charCode >= 0 && charCode < 256) {
            return this._asciiMap[charCode];
        }
        else {
            return (this._map.get(charCode) || this._defaultValue);
        }
    }
}
exports.CharacterClassifier = CharacterClassifier;


/***/ }),

/***/ "../../packages/plugin-ext/lib/common/collections.js":
/*!***********************************************************!*\
  !*** ../../packages/plugin-ext/lib/common/collections.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.diffMaps = exports.diffSets = void 0;
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// some code copied and modified from https://github.com/microsoft/vscode/blob/1.71.2/src/vs/base/common/collections.ts
function diffSets(before, after) {
    const removed = [];
    const added = [];
    for (const element of before) {
        if (!after.has(element)) {
            removed.push(element);
        }
    }
    for (const element of after) {
        if (!before.has(element)) {
            added.push(element);
        }
    }
    return { removed, added };
}
exports.diffSets = diffSets;
function diffMaps(before, after) {
    const removed = [];
    const added = [];
    for (const [index, value] of before) {
        if (!after.has(index)) {
            removed.push(value);
        }
    }
    for (const [index, value] of after) {
        if (!before.has(index)) {
            added.push(value);
        }
    }
    return { removed, added };
}
exports.diffMaps = diffMaps;


/***/ }),

/***/ "../../packages/plugin-ext/lib/common/connection.js":
/*!**********************************************************!*\
  !*** ../../packages/plugin-ext/lib/common/connection.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectionImpl = exports.PluginChannel = void 0;
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../packages/core/lib/common/event.js");
/**
 * A channel communicating with a counterpart in a plugin host.
 */
class PluginChannel {
    constructor(id, connection) {
        this.id = id;
        this.connection = connection;
        this.messageEmitter = new event_1.Emitter();
        this.errorEmitter = new event_1.Emitter();
        this.closedEmitter = new event_1.Emitter();
    }
    send(content) {
        this.connection.$sendMessage(this.id, content);
    }
    fireMessageReceived(msg) {
        this.messageEmitter.fire(msg);
    }
    fireError(error) {
        this.errorEmitter.fire(error);
    }
    fireClosed() {
        this.closedEmitter.fire();
    }
    onMessage(cb) {
        this.messageEmitter.event(cb);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    onError(cb) {
        this.errorEmitter.event(cb);
    }
    onClose(cb) {
        this.closedEmitter.event(() => cb(-1, 'closed'));
    }
    close() {
        this.connection.$deleteConnection(this.id);
    }
}
exports.PluginChannel = PluginChannel;
class ConnectionImpl {
    constructor(proxy) {
        this.connections = new Map();
        this.proxy = proxy;
    }
    /**
     * Gets the connection between plugin by id and sends string message to it.
     *
     * @param id connection's id
     * @param message incoming message
     */
    async $sendMessage(id, message) {
        if (this.connections.has(id)) {
            this.connections.get(id).fireMessageReceived(message);
        }
        else {
            console.warn(`Received message for unknown connection: ${id}`);
        }
    }
    /**
     * Instantiates a new connection by the given id.
     * @param id the connection id
     */
    async $createConnection(id) {
        console.debug(`Creating plugin connection: ${id}`);
        await this.doEnsureConnection(id);
    }
    /**
     * Deletes a connection.
     * @param id the connection id
     */
    async $deleteConnection(id) {
        console.debug(`Deleting plugin connection: ${id}`);
        const connection = this.connections.get(id);
        if (connection) {
            this.connections.delete(id);
            connection.fireClosed();
        }
    }
    /**
     * Returns existed connection or creates a new one.
     * @param id the connection id
     */
    async ensureConnection(id) {
        console.debug(`Creating local connection: ${id}`);
        const connection = await this.doEnsureConnection(id);
        await this.proxy.$createConnection(id);
        return connection;
    }
    /**
     * Returns existed connection or creates a new one.
     * @param id the connection id
     */
    async doEnsureConnection(id) {
        const connection = this.connections.get(id) || await this.doCreateConnection(id);
        this.connections.set(id, connection);
        return connection;
    }
    async doCreateConnection(id) {
        const channel = new PluginChannel(id, this.proxy);
        channel.onClose(() => this.connections.delete(id));
        return channel;
    }
}
exports.ConnectionImpl = ConnectionImpl;


/***/ }),

/***/ "../../packages/plugin-ext/lib/common/disposable-util.js":
/*!***************************************************************!*\
  !*** ../../packages/plugin-ext/lib/common/disposable-util.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dispose = void 0;
function dispose(first, ...rest) {
    if (Array.isArray(first)) {
        first.forEach(d => d && d.dispose());
        return [];
    }
    else if (rest.length === 0) {
        if (first) {
            first.dispose();
            return first;
        }
        return undefined;
    }
    else {
        dispose(first);
        dispose(rest);
        return [];
    }
}
exports.dispose = dispose;


/***/ }),

/***/ "../../packages/plugin-ext/lib/common/editor-options.js":
/*!**************************************************************!*\
  !*** ../../packages/plugin-ext/lib/common/editor-options.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cursorStyleToString = exports.TextEditorCursorStyle = void 0;
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// enum copied from monaco.d.ts
/**
 * The style in which the editor's cursor should be rendered.
 */
var TextEditorCursorStyle;
(function (TextEditorCursorStyle) {
    /**
     * As a vertical line
     */
    TextEditorCursorStyle[TextEditorCursorStyle["Line"] = 1] = "Line";
    /**
     * As a block
     */
    TextEditorCursorStyle[TextEditorCursorStyle["Block"] = 2] = "Block";
    /**
     * As a horizontal line, under character
     */
    TextEditorCursorStyle[TextEditorCursorStyle["Underline"] = 3] = "Underline";
    /**
     * As a thin vertical line
     */
    TextEditorCursorStyle[TextEditorCursorStyle["LineThin"] = 4] = "LineThin";
    /**
     * As an outlined block, on top of a character
     */
    TextEditorCursorStyle[TextEditorCursorStyle["BlockOutline"] = 5] = "BlockOutline";
    /**
     * As a thin horizontal line, under a character
     */
    TextEditorCursorStyle[TextEditorCursorStyle["UnderlineThin"] = 6] = "UnderlineThin";
})(TextEditorCursorStyle = exports.TextEditorCursorStyle || (exports.TextEditorCursorStyle = {}));
function cursorStyleToString(cursorStyle) {
    switch (cursorStyle) {
        case TextEditorCursorStyle.Line:
            return 'line';
        case TextEditorCursorStyle.Block:
            return 'block';
        case TextEditorCursorStyle.Underline:
            return 'underline';
        case TextEditorCursorStyle.LineThin:
            return 'line-thin';
        case TextEditorCursorStyle.BlockOutline:
            return 'block-outline';
        case TextEditorCursorStyle.UnderlineThin:
            return 'underline-thin';
        default:
            throw new Error('cursorStyleToString: Unknown cursorStyle');
    }
}
exports.cursorStyleToString = cursorStyleToString;


/***/ }),

/***/ "../../packages/plugin-ext/lib/common/id-generator.js":
/*!************************************************************!*\
  !*** ../../packages/plugin-ext/lib/common/id-generator.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IdGenerator = void 0;
class IdGenerator {
    constructor(prefix) {
        this.prefix = prefix;
        this.lastId = 0;
    }
    nextId() {
        return this.prefix + (++this.lastId);
    }
}
exports.IdGenerator = IdGenerator;


/***/ }),

/***/ "../../packages/plugin-ext/lib/common/link-computer.js":
/*!*************************************************************!*\
  !*** ../../packages/plugin-ext/lib/common/link-computer.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// based on https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/editor/common/modes/linkComputer.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinkComputer = exports.StateMachine = exports.Uint8Matrix = void 0;
/* eslint-disable max-len */
const character_classifier_1 = __webpack_require__(/*! ./character-classifier */ "../../packages/plugin-ext/lib/common/character-classifier.js");
class Uint8Matrix {
    constructor(rows, cols, defaultValue) {
        const data = new Uint8Array(rows * cols);
        for (let i = 0, len = rows * cols; i < len; i++) {
            data[i] = defaultValue;
        }
        this._data = data;
        this.rows = rows;
        this.cols = cols;
    }
    get(row, col) {
        return this._data[row * this.cols + col];
    }
    set(row, col, value) {
        this._data[row * this.cols + col] = value;
    }
}
exports.Uint8Matrix = Uint8Matrix;
class StateMachine {
    constructor(edges) {
        let maxCharCode = 0;
        let maxState = 0 /* Invalid */;
        for (let i = 0, len = edges.length; i < len; i++) {
            const [from, chCode, to] = edges[i];
            if (chCode > maxCharCode) {
                maxCharCode = chCode;
            }
            if (from > maxState) {
                maxState = from;
            }
            if (to > maxState) {
                maxState = to;
            }
        }
        maxCharCode++;
        maxState++;
        const states = new Uint8Matrix(maxState, maxCharCode, 0 /* Invalid */);
        for (let i = 0, len = edges.length; i < len; i++) {
            const [from, chCode, to] = edges[i];
            states.set(from, chCode, to);
        }
        this._states = states;
        this._maxCharCode = maxCharCode;
    }
    nextState(currentState, chCode) {
        if (chCode < 0 || chCode >= this._maxCharCode) {
            return 0 /* Invalid */;
        }
        return this._states.get(currentState, chCode);
    }
}
exports.StateMachine = StateMachine;
// State machine for http:// or https:// or file://
let _stateMachine = null;
function getStateMachine() {
    if (_stateMachine === null) {
        _stateMachine = new StateMachine([
            [1 /* Start */, 104 /* h */, 2 /* H */],
            [1 /* Start */, 72 /* H */, 2 /* H */],
            [1 /* Start */, 102 /* f */, 6 /* F */],
            [1 /* Start */, 70 /* F */, 6 /* F */],
            [2 /* H */, 116 /* t */, 3 /* HT */],
            [2 /* H */, 84 /* T */, 3 /* HT */],
            [3 /* HT */, 116 /* t */, 4 /* HTT */],
            [3 /* HT */, 84 /* T */, 4 /* HTT */],
            [4 /* HTT */, 112 /* p */, 5 /* HTTP */],
            [4 /* HTT */, 80 /* P */, 5 /* HTTP */],
            [5 /* HTTP */, 115 /* s */, 9 /* BeforeColon */],
            [5 /* HTTP */, 83 /* S */, 9 /* BeforeColon */],
            [5 /* HTTP */, 58 /* Colon */, 10 /* AfterColon */],
            [6 /* F */, 105 /* i */, 7 /* FI */],
            [6 /* F */, 73 /* I */, 7 /* FI */],
            [7 /* FI */, 108 /* l */, 8 /* FIL */],
            [7 /* FI */, 76 /* L */, 8 /* FIL */],
            [8 /* FIL */, 101 /* e */, 9 /* BeforeColon */],
            [8 /* FIL */, 69 /* E */, 9 /* BeforeColon */],
            [9 /* BeforeColon */, 58 /* Colon */, 10 /* AfterColon */],
            [10 /* AfterColon */, 47 /* Slash */, 11 /* AlmostThere */],
            [11 /* AlmostThere */, 47 /* Slash */, 12 /* End */],
        ]);
    }
    return _stateMachine;
}
let _classifier = null;
function getClassifier() {
    if (_classifier === null) {
        _classifier = new character_classifier_1.CharacterClassifier(0 /* None */);
        const FORCE_TERMINATION_CHARACTERS = ' \t<>\'\"';
        for (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {
            _classifier.set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), 1 /* ForceTermination */);
        }
        const CANNOT_END_WITH_CHARACTERS = '.,;';
        for (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {
            _classifier.set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), 2 /* CannotEndIn */);
        }
    }
    return _classifier;
}
class LinkComputer {
    static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {
        // Do not allow to end link in certain characters...
        let lastIncludedCharIndex = linkEndIndex - 1;
        do {
            const chCode = line.charCodeAt(lastIncludedCharIndex);
            const chClass = classifier.get(chCode);
            if (chClass !== 2 /* CannotEndIn */) {
                break;
            }
            lastIncludedCharIndex--;
        } while (lastIncludedCharIndex > linkBeginIndex);
        // Handle links enclosed in parens, square and curly brackets.
        if (linkBeginIndex > 0) {
            const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);
            const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);
            if ((charCodeBeforeLink === 40 /* OpenParen */ && lastCharCodeInLink === 41 /* CloseParen */)
                || (charCodeBeforeLink === 91 /* OpenSquareBracket */ && lastCharCodeInLink === 93 /* CloseSquareBracket */)
                || (charCodeBeforeLink === 123 /* OpenCurlyBrace */ && lastCharCodeInLink === 125 /* CloseCurlyBrace */)) {
                // Do not end in ) if ( is before the link start
                // Do not end in ] if [ is before the link start
                // Do not end in } if { is before the link start
                lastIncludedCharIndex--;
            }
        }
        return {
            range: {
                startLineNumber: lineNumber,
                startColumn: linkBeginIndex + 1,
                endLineNumber: lineNumber,
                endColumn: lastIncludedCharIndex + 2
            },
            url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)
        };
    }
    static computeLinks(model, stateMachine = getStateMachine()) {
        const classifier = getClassifier();
        const result = [];
        for (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {
            const line = model.getLineContent(i);
            const len = line.length;
            let j = 0;
            let linkBeginIndex = 0;
            let linkBeginChCode = 0;
            let state = 1 /* Start */;
            let hasOpenParens = false;
            let hasOpenSquareBracket = false;
            let inSquareBrackets = false;
            let hasOpenCurlyBracket = false;
            while (j < len) {
                let resetStateMachine = false;
                const chCode = line.charCodeAt(j);
                if (state === 13 /* Accept */) {
                    let chClass;
                    switch (chCode) {
                        case 40 /* OpenParen */:
                            hasOpenParens = true;
                            chClass = 0 /* None */;
                            break;
                        case 41 /* CloseParen */:
                            chClass = (hasOpenParens ? 0 /* None */ : 1 /* ForceTermination */);
                            break;
                        case 91 /* OpenSquareBracket */:
                            inSquareBrackets = true;
                            hasOpenSquareBracket = true;
                            chClass = 0 /* None */;
                            break;
                        case 93 /* CloseSquareBracket */:
                            inSquareBrackets = false;
                            chClass = (hasOpenSquareBracket ? 0 /* None */ : 1 /* ForceTermination */);
                            break;
                        case 123 /* OpenCurlyBrace */:
                            hasOpenCurlyBracket = true;
                            chClass = 0 /* None */;
                            break;
                        case 125 /* CloseCurlyBrace */:
                            chClass = (hasOpenCurlyBracket ? 0 /* None */ : 1 /* ForceTermination */);
                            break;
                        /* The following three rules make it that ' or " or ` are allowed inside links if the link began with a different one */
                        case 39 /* SingleQuote */:
                            chClass = (linkBeginChCode === 34 /* DoubleQuote */ || linkBeginChCode === 96 /* BackTick */) ? 0 /* None */ : 1 /* ForceTermination */;
                            break;
                        case 34 /* DoubleQuote */:
                            chClass = (linkBeginChCode === 39 /* SingleQuote */ || linkBeginChCode === 96 /* BackTick */) ? 0 /* None */ : 1 /* ForceTermination */;
                            break;
                        case 96 /* BackTick */:
                            chClass = (linkBeginChCode === 39 /* SingleQuote */ || linkBeginChCode === 34 /* DoubleQuote */) ? 0 /* None */ : 1 /* ForceTermination */;
                            break;
                        case 42 /* Asterisk */:
                            // `*` terminates a link if the link began with `*`
                            chClass = (linkBeginChCode === 42 /* Asterisk */) ? 1 /* ForceTermination */ : 0 /* None */;
                            break;
                        case 124 /* Pipe */:
                            // `|` terminates a link if the link began with `|`
                            chClass = (linkBeginChCode === 124 /* Pipe */) ? 1 /* ForceTermination */ : 0 /* None */;
                            break;
                        case 32 /* Space */:
                            // ` ` allow space in between [ and ]
                            chClass = (inSquareBrackets ? 0 /* None */ : 1 /* ForceTermination */);
                            break;
                        default:
                            chClass = classifier.get(chCode);
                    }
                    // Check if character terminates link
                    if (chClass === 1 /* ForceTermination */) {
                        result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));
                        resetStateMachine = true;
                    }
                }
                else if (state === 12 /* End */) {
                    let chClass;
                    if (chCode === 91 /* OpenSquareBracket */) {
                        // Allow for the authority part to contain ipv6 addresses which contain [ and ]
                        hasOpenSquareBracket = true;
                        chClass = 0 /* None */;
                    }
                    else {
                        chClass = classifier.get(chCode);
                    }
                    // Check if character terminates link
                    if (chClass === 1 /* ForceTermination */) {
                        resetStateMachine = true;
                    }
                    else {
                        state = 13 /* Accept */;
                    }
                }
                else {
                    state = stateMachine.nextState(state, chCode);
                    if (state === 0 /* Invalid */) {
                        resetStateMachine = true;
                    }
                }
                if (resetStateMachine) {
                    state = 1 /* Start */;
                    hasOpenParens = false;
                    hasOpenSquareBracket = false;
                    hasOpenCurlyBracket = false;
                    // Record where the link started
                    linkBeginIndex = j + 1;
                    linkBeginChCode = chCode;
                }
                j++;
            }
            if (state === 13 /* Accept */) {
                result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));
            }
        }
        return result;
    }
}
exports.LinkComputer = LinkComputer;


/***/ }),

/***/ "../../packages/plugin-ext/lib/common/object-identifier.js":
/*!*****************************************************************!*\
  !*** ../../packages/plugin-ext/lib/common/object-identifier.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ObjectIdentifier = void 0;
var ObjectIdentifier;
(function (ObjectIdentifier) {
    ObjectIdentifier.name = '$ident';
    function mixin(obj, id) {
        Object.defineProperty(obj, ObjectIdentifier.name, { value: id, enumerable: true });
        return obj;
    }
    ObjectIdentifier.mixin = mixin;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function of(obj) {
        return obj[ObjectIdentifier.name];
    }
    ObjectIdentifier.of = of;
})(ObjectIdentifier = exports.ObjectIdentifier || (exports.ObjectIdentifier = {}));


/***/ }),

/***/ "../../packages/plugin-ext/lib/common/objects.js":
/*!*******************************************************!*\
  !*** ../../packages/plugin-ext/lib/common/objects.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* eslint-disable */
// copied from https://github.com/microsoft/vscode/blob/1.37.0/src/vs/base/common/objects.ts
/*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cloneAndChange = void 0;
const types_1 = __webpack_require__(/*! ./types */ "../../packages/plugin-ext/lib/common/types.js");
const _hasOwnProperty = Object.prototype.hasOwnProperty;
function cloneAndChange(obj, changer) {
    return _cloneAndChange(obj, changer, new Set());
}
exports.cloneAndChange = cloneAndChange;
function _cloneAndChange(obj, changer, seen) {
    if ((0, types_1.isUndefinedOrNull)(obj)) {
        return obj;
    }
    const changed = changer(obj);
    if (typeof changed !== 'undefined') {
        return changed;
    }
    if ((0, types_1.isArray)(obj)) {
        const r1 = [];
        for (const e of obj) {
            r1.push(_cloneAndChange(e, changer, seen));
        }
        return r1;
    }
    if ((0, types_1.isObject)(obj)) {
        if (seen.has(obj)) {
            throw new Error('Cannot clone recursive data-structure');
        }
        seen.add(obj);
        const r2 = {};
        for (let i2 in obj) {
            if (_hasOwnProperty.call(obj, i2)) {
                r2[i2] = _cloneAndChange(obj[i2], changer, seen);
            }
        }
        seen.delete(obj);
        return r2;
    }
    return obj;
}


/***/ }),

/***/ "../../packages/plugin-ext/lib/common/reference-map.js":
/*!*************************************************************!*\
  !*** ../../packages/plugin-ext/lib/common/reference-map.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReferenceMap = void 0;
// copied from hhttps://github.com/microsoft/vscode/blob/6261075646f055b99068d3688932416f2346dd3b/src/vs/workbench/api/common/extHostLanguageFeatures.ts#L1291-L1310.
class ReferenceMap {
    constructor() {
        this._references = new Map();
        this._idPool = 1;
    }
    createReferenceId(value) {
        const id = this._idPool++;
        this._references.set(id, value);
        return id;
    }
    disposeReferenceId(referenceId) {
        const value = this._references.get(referenceId);
        this._references.delete(referenceId);
        return value;
    }
    get(referenceId) {
        return this._references.get(referenceId);
    }
}
exports.ReferenceMap = ReferenceMap;


/***/ }),

/***/ "../../packages/plugin-ext/lib/common/semantic-tokens-dto.js":
/*!*******************************************************************!*\
  !*** ../../packages/plugin-ext/lib/common/semantic-tokens-dto.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeSemanticTokensDto = exports.encodeSemanticTokensDto = void 0;
// copied and modified from https://github.com/microsoft/vscode/blob/0eb3a02ca2bcfab5faa3dc6e52d7c079efafcab0/src/vs/workbench/api/common/shared/semanticTokensDto.ts
const buffer_1 = __webpack_require__(/*! @theia/core/lib/common/buffer */ "../../packages/core/lib/common/buffer.js");
let _isLittleEndian = true;
let _isLittleEndianComputed = false;
function isLittleEndian() {
    if (!_isLittleEndianComputed) {
        _isLittleEndianComputed = true;
        const test = new Uint8Array(2);
        test[0] = 1;
        test[1] = 2;
        const view = new Uint16Array(test.buffer);
        _isLittleEndian = (view[0] === (2 << 8) + 1);
    }
    return _isLittleEndian;
}
function reverseEndianness(arr) {
    for (let i = 0, len = arr.length; i < len; i += 4) {
        // flip bytes 0<->3 and 1<->2
        const b0 = arr[i + 0];
        const b1 = arr[i + 1];
        const b2 = arr[i + 2];
        const b3 = arr[i + 3];
        arr[i + 0] = b3;
        arr[i + 1] = b2;
        arr[i + 2] = b1;
        arr[i + 3] = b0;
    }
}
function toLittleEndianBuffer(arr) {
    const uint8Arr = new Uint8Array(arr.buffer, arr.byteOffset, arr.length * 4);
    if (!isLittleEndian()) {
        // the byte order must be changed
        reverseEndianness(uint8Arr);
    }
    return buffer_1.BinaryBuffer.wrap(uint8Arr);
}
function fromLittleEndianBuffer(buff) {
    const uint8Arr = buff.buffer;
    if (!isLittleEndian()) {
        // the byte order must be changed
        reverseEndianness(uint8Arr);
    }
    if (uint8Arr.byteOffset % 4 === 0) {
        return new Uint32Array(uint8Arr.buffer, uint8Arr.byteOffset, uint8Arr.length / 4);
    }
    else {
        // unaligned memory access doesn't work on all platforms
        const data = new Uint8Array(uint8Arr.byteLength);
        data.set(uint8Arr);
        return new Uint32Array(data.buffer, data.byteOffset, data.length / 4);
    }
}
function encodeSemanticTokensDto(semanticTokens) {
    const dest = new Uint32Array(encodeSemanticTokensDtoSize(semanticTokens));
    let offset = 0;
    dest[offset++] = semanticTokens.id;
    if (semanticTokens.type === 'full') {
        dest[offset++] = 1 /* Full */;
        dest[offset++] = semanticTokens.data.length;
        dest.set(semanticTokens.data, offset);
        offset += semanticTokens.data.length;
    }
    else {
        dest[offset++] = 2 /* Delta */;
        dest[offset++] = semanticTokens.deltas.length;
        for (const delta of semanticTokens.deltas) {
            dest[offset++] = delta.start;
            dest[offset++] = delta.deleteCount;
            if (delta.data) {
                dest[offset++] = delta.data.length;
                dest.set(delta.data, offset);
                offset += delta.data.length;
            }
            else {
                dest[offset++] = 0;
            }
        }
    }
    return toLittleEndianBuffer(dest);
}
exports.encodeSemanticTokensDto = encodeSemanticTokensDto;
function encodeSemanticTokensDtoSize(semanticTokens) {
    let result = 0;
    result += (+1 // id
        + 1 // type
    );
    if (semanticTokens.type === 'full') {
        result += (+1 // data length
            + semanticTokens.data.length);
    }
    else {
        result += (+1 // delta count
        );
        result += (+1 // start
            + 1 // deleteCount
            + 1 // data length
        ) * semanticTokens.deltas.length;
        for (const delta of semanticTokens.deltas) {
            if (delta.data) {
                result += delta.data.length;
            }
        }
    }
    return result;
}
function decodeSemanticTokensDto(_buff) {
    const src = fromLittleEndianBuffer(_buff);
    let offset = 0;
    const id = src[offset++];
    const type = src[offset++];
    if (type === 1 /* Full */) {
        const length = src[offset++];
        const data = src.subarray(offset, offset + length);
        offset += length;
        return {
            id: id,
            type: 'full',
            data: data
        };
    }
    const deltaCount = src[offset++];
    const deltas = [];
    for (let i = 0; i < deltaCount; i++) {
        const start = src[offset++];
        const deleteCount = src[offset++];
        const length = src[offset++];
        let data;
        if (length > 0) {
            data = src.subarray(offset, offset + length);
            offset += length;
        }
        deltas[i] = { start, deleteCount, data };
    }
    return {
        id: id,
        type: 'delta',
        deltas: deltas
    };
}
exports.decodeSemanticTokensDto = decodeSemanticTokensDto;


/***/ }),

/***/ "../../packages/plugin-ext/lib/common/uint.js":
/*!****************************************************!*\
  !*** ../../packages/plugin-ext/lib/common/uint.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// based on https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/base/common/uint.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toUint8 = void 0;
function toUint8(v) {
    if (v < 0) {
        return 0;
    }
    if (v > 255 /* MAX_UINT_8 */) {
        return 255 /* MAX_UINT_8 */;
    }
    return v | 0;
}
exports.toUint8 = toUint8;


/***/ }),

/***/ "../../packages/plugin-ext/lib/common/uri-components.js":
/*!**************************************************************!*\
  !*** ../../packages/plugin-ext/lib/common/uri-components.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.theiaUritoUriComponents = exports.Schemes = void 0;
// some well known URI schemas
// based on https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/base/common/network.ts#L9-L79
// TODO move to network.ts file
var Schemes;
(function (Schemes) {
    /**
     * A schema that is used for models that exist in memory
     * only and that have no correspondence on a server or such.
     */
    Schemes.inMemory = 'inmemory';
    /**
     * A schema that is used for setting files
     */
    Schemes.vscode = 'vscode';
    /**
     * A schema that is used for internal private files
     */
    Schemes.internal = 'private';
    /**
     * A walk-through document.
     */
    Schemes.walkThrough = 'walkThrough';
    /**
     * An embedded code snippet.
     */
    Schemes.walkThroughSnippet = 'walkThroughSnippet';
    Schemes.http = 'http';
    Schemes.https = 'https';
    Schemes.file = 'file';
    Schemes.mailto = 'mailto';
    Schemes.untitled = 'untitled';
    Schemes.data = 'data';
    Schemes.command = 'command';
    Schemes.vscodeRemote = 'vscode-remote';
    Schemes.vscodeRemoteResource = 'vscode-remote-resource';
    Schemes.userData = 'vscode-userdata';
    Schemes.vscodeCustomEditor = 'vscode-custom-editor';
    Schemes.vscodeSettings = 'vscode-settings';
    Schemes.webviewPanel = 'webview-panel';
})(Schemes = exports.Schemes || (exports.Schemes = {}));
function theiaUritoUriComponents(uri) {
    return uri.toComponents();
}
exports.theiaUritoUriComponents = theiaUritoUriComponents;


/***/ }),

/***/ "../../packages/plugin-ext/lib/hosted/node/plugin-host-proxy.js":
/*!**********************************************************************!*\
  !*** ../../packages/plugin-ext/lib/hosted/node/plugin-host-proxy.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (C) 2022 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.connectProxyResolver = void 0;
const http = __webpack_require__(/*! http */ "http");
const https = __webpack_require__(/*! https */ "https");
const tls = __webpack_require__(/*! tls */ "tls");
const proxy_agent_1 = __webpack_require__(/*! @vscode/proxy-agent */ "../../node_modules/@vscode/proxy-agent/out/index.js");
function connectProxyResolver(workspaceExt, configProvider) {
    const resolveProxy = (0, proxy_agent_1.createProxyResolver)({
        resolveProxy: async (url) => workspaceExt.resolveProxy(url),
        getHttpProxySetting: () => configProvider.getConfiguration('http').get('proxy'),
        log: () => { },
        getLogLevel: () => 0,
        proxyResolveTelemetry: () => { },
        useHostProxy: true,
        env: process.env,
    });
    const lookup = createPatchedModules(configProvider, resolveProxy);
    configureModuleLoading(lookup);
}
exports.connectProxyResolver = connectProxyResolver;
function createPatchedModules(configProvider, resolveProxy) {
    const defaultConfig = 'override';
    const proxySetting = {
        config: defaultConfig
    };
    const certSetting = {
        config: false
    };
    configProvider.onDidChangeConfiguration(() => {
        const httpConfig = configProvider.getConfiguration('http');
        proxySetting.config = (httpConfig === null || httpConfig === void 0 ? void 0 : httpConfig.get('proxySupport')) || defaultConfig;
        certSetting.config = !!(httpConfig === null || httpConfig === void 0 ? void 0 : httpConfig.get('systemCertificates'));
    });
    return {
        http: Object.assign(http, (0, proxy_agent_1.createHttpPatch)(http, resolveProxy, proxySetting, certSetting, true)),
        https: Object.assign(https, (0, proxy_agent_1.createHttpPatch)(https, resolveProxy, proxySetting, certSetting, true)),
        tls: Object.assign(tls, (0, proxy_agent_1.createTlsPatch)(tls))
    };
}
function configureModuleLoading(lookup) {
    const node_module = __webpack_require__(/*! module */ "module");
    const original = node_module._load;
    node_module._load = function (request) {
        if (request === 'tls') {
            return lookup.tls;
        }
        if (request !== 'http' && request !== 'https') {
            return original.apply(this, arguments);
        }
        // Create a shallow copy of the http(s) module to work around extensions that apply changes to the modules
        // See for more info: https://github.com/microsoft/vscode/issues/93167
        return { ...lookup[request] };
    };
}


/***/ }),

/***/ "../../packages/plugin-ext/lib/hosted/node/plugin-host-rpc.js":
/*!********************************************************************!*\
  !*** ../../packages/plugin-ext/lib/hosted/node/plugin-host-rpc.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginHostRPC = void 0;
const dynamic_require_1 = __webpack_require__(/*! @theia/core/lib/node/dynamic-require */ "../../packages/core/lib/node/dynamic-require.js");
const plugin_manager_1 = __webpack_require__(/*! ../../plugin/plugin-manager */ "../../packages/plugin-ext/lib/plugin/plugin-manager.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const plugin_context_1 = __webpack_require__(/*! ../../plugin/plugin-context */ "../../packages/plugin-ext/lib/plugin/plugin-context.js");
const preference_registry_1 = __webpack_require__(/*! ../../plugin/preference-registry */ "../../packages/plugin-ext/lib/plugin/preference-registry.js");
const debug_ext_1 = __webpack_require__(/*! ../../plugin/debug/debug-ext */ "../../packages/plugin-ext/lib/plugin/debug/debug-ext.js");
const editors_and_documents_1 = __webpack_require__(/*! ../../plugin/editors-and-documents */ "../../packages/plugin-ext/lib/plugin/editors-and-documents.js");
const workspace_1 = __webpack_require__(/*! ../../plugin/workspace */ "../../packages/plugin-ext/lib/plugin/workspace.js");
const message_registry_1 = __webpack_require__(/*! ../../plugin/message-registry */ "../../packages/plugin-ext/lib/plugin/message-registry.js");
const env_node_ext_1 = __webpack_require__(/*! ../../plugin/node/env-node-ext */ "../../packages/plugin-ext/lib/plugin/node/env-node-ext.js");
const clipboard_ext_1 = __webpack_require__(/*! ../../plugin/clipboard-ext */ "../../packages/plugin-ext/lib/plugin/clipboard-ext.js");
const plugin_manifest_loader_1 = __webpack_require__(/*! ./plugin-manifest-loader */ "../../packages/plugin-ext/lib/hosted/node/plugin-manifest-loader.js");
const plugin_storage_1 = __webpack_require__(/*! ../../plugin/plugin-storage */ "../../packages/plugin-ext/lib/plugin/plugin-storage.js");
const webviews_1 = __webpack_require__(/*! ../../plugin/webviews */ "../../packages/plugin-ext/lib/plugin/webviews.js");
const terminal_ext_1 = __webpack_require__(/*! ../../plugin/terminal-ext */ "../../packages/plugin-ext/lib/plugin/terminal-ext.js");
const secrets_ext_1 = __webpack_require__(/*! ../../plugin/secrets-ext */ "../../packages/plugin-ext/lib/plugin/secrets-ext.js");
const plugin_host_proxy_1 = __webpack_require__(/*! ./plugin-host-proxy */ "../../packages/plugin-ext/lib/hosted/node/plugin-host-proxy.js");
const localization_ext_1 = __webpack_require__(/*! ../../plugin/localization-ext */ "../../packages/plugin-ext/lib/plugin/localization-ext.js");
/**
 * Handle the RPC calls.
 */
class PluginHostRPC {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(rpc) {
        this.rpc = rpc;
    }
    initialize() {
        const envExt = new env_node_ext_1.EnvNodeExtImpl(this.rpc);
        const storageProxy = new plugin_storage_1.KeyValueStorageProxy(this.rpc);
        const debugExt = new debug_ext_1.DebugExtImpl(this.rpc);
        const editorsAndDocumentsExt = new editors_and_documents_1.EditorsAndDocumentsExtImpl(this.rpc);
        const messageRegistryExt = new message_registry_1.MessageRegistryExt(this.rpc);
        const workspaceExt = new workspace_1.WorkspaceExtImpl(this.rpc, editorsAndDocumentsExt, messageRegistryExt);
        const preferenceRegistryExt = new preference_registry_1.PreferenceRegistryExtImpl(this.rpc, workspaceExt);
        const clipboardExt = new clipboard_ext_1.ClipboardExt(this.rpc);
        const webviewExt = new webviews_1.WebviewsExtImpl(this.rpc, workspaceExt);
        const terminalService = new terminal_ext_1.TerminalServiceExtImpl(this.rpc);
        const secretsExt = new secrets_ext_1.SecretsExtImpl(this.rpc);
        const localizationExt = new localization_ext_1.LocalizationExtImpl(this.rpc);
        this.pluginManager = this.createPluginManager(envExt, terminalService, storageProxy, preferenceRegistryExt, webviewExt, secretsExt, localizationExt, this.rpc);
        this.rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.HOSTED_PLUGIN_MANAGER_EXT, this.pluginManager);
        this.rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.EDITORS_AND_DOCUMENTS_EXT, editorsAndDocumentsExt);
        this.rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.WORKSPACE_EXT, workspaceExt);
        this.rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.PREFERENCE_REGISTRY_EXT, preferenceRegistryExt);
        this.rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.STORAGE_EXT, storageProxy);
        this.rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.WEBVIEWS_EXT, webviewExt);
        this.rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.SECRETS_EXT, secretsExt);
        this.apiFactory = (0, plugin_context_1.createAPIFactory)(this.rpc, this.pluginManager, envExt, debugExt, preferenceRegistryExt, editorsAndDocumentsExt, workspaceExt, messageRegistryExt, clipboardExt, webviewExt, localizationExt);
        (0, plugin_host_proxy_1.connectProxyResolver)(workspaceExt, preferenceRegistryExt);
    }
    async terminate() {
        await this.pluginManager.terminate();
    }
    initContext(contextPath, plugin) {
        const { name, version } = plugin.rawModel;
        console.debug('PLUGIN_HOST(' + process.pid + '): initializing(' + name + '@' + version + ' with ' + contextPath + ')');
        try {
            const backendInit = (0, dynamic_require_1.dynamicRequire)(contextPath);
            backendInit.doInitialization(this.apiFactory, plugin);
        }
        catch (e) {
            console.error(e);
        }
    }
    createPluginManager(envExt, terminalService, storageProxy, preferencesManager, webview, secretsExt, localization, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    rpc) {
        const { extensionTestsPath } = process.env;
        const self = this;
        const pluginManager = new plugin_manager_1.PluginManagerExtImpl({
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            loadPlugin(plugin) {
                console.debug('PLUGIN_HOST(' + process.pid + '): PluginManagerExtImpl/loadPlugin(' + plugin.pluginPath + ')');
                // cleaning the cache for all files of that plug-in.
                // this prevents a memory leak on plugin host restart. See for reference:
                // https://github.com/eclipse-theia/theia/pull/4931
                // https://github.com/nodejs/node/issues/8443
                (0, dynamic_require_1.removeFromCache)(mod => mod.id.startsWith(plugin.pluginFolder));
                if (plugin.pluginPath) {
                    return (0, dynamic_require_1.dynamicRequire)(plugin.pluginPath);
                }
            },
            async init(raw) {
                console.log('PLUGIN_HOST(' + process.pid + '): PluginManagerExtImpl/init()');
                const result = [];
                const foreign = [];
                for (const plg of raw) {
                    try {
                        const pluginModel = plg.model;
                        const pluginLifecycle = plg.lifecycle;
                        const rawModel = await (0, plugin_manifest_loader_1.loadManifest)(pluginModel.packagePath);
                        rawModel.packagePath = pluginModel.packagePath;
                        if (pluginModel.entryPoint.frontend) {
                            foreign.push({
                                pluginPath: pluginModel.entryPoint.frontend,
                                pluginFolder: pluginModel.packagePath,
                                pluginUri: pluginModel.packageUri,
                                model: pluginModel,
                                lifecycle: pluginLifecycle,
                                rawModel,
                                isUnderDevelopment: !!plg.isUnderDevelopment
                            });
                        }
                        else {
                            let backendInitPath = pluginLifecycle.backendInitPath;
                            // if no init path, try to init as regular Theia plugin
                            if (!backendInitPath) {
                                backendInitPath = __dirname + '/scanners/backend-init-theia.js';
                            }
                            const plugin = {
                                pluginPath: pluginModel.entryPoint.backend,
                                pluginFolder: pluginModel.packagePath,
                                pluginUri: pluginModel.packageUri,
                                model: pluginModel,
                                lifecycle: pluginLifecycle,
                                rawModel,
                                isUnderDevelopment: !!plg.isUnderDevelopment
                            };
                            self.initContext(backendInitPath, plugin);
                            result.push(plugin);
                        }
                    }
                    catch (e) {
                        console.error(`Failed to initialize ${plg.model.id} plugin.`, e);
                    }
                }
                return [result, foreign];
            },
            initExtApi(extApi) {
                for (const api of extApi) {
                    if (api.backendInitPath) {
                        try {
                            const extApiInit = (0, dynamic_require_1.dynamicRequire)(api.backendInitPath);
                            extApiInit.provideApi(rpc, pluginManager);
                        }
                        catch (e) {
                            console.error(e);
                        }
                    }
                }
            },
            loadTests: extensionTestsPath ? async () => {
                /* eslint-disable @typescript-eslint/no-explicit-any */
                // Require the test runner via node require from the provided path
                let testRunner;
                let requireError;
                try {
                    testRunner = (0, dynamic_require_1.dynamicRequire)(extensionTestsPath);
                }
                catch (error) {
                    requireError = error;
                }
                // Execute the runner if it follows our spec
                if (testRunner && typeof testRunner.run === 'function') {
                    return new Promise((resolve, reject) => {
                        testRunner.run(extensionTestsPath, (error) => {
                            if (error) {
                                reject(error.toString());
                            }
                            else {
                                resolve(undefined);
                            }
                        });
                    });
                }
                throw new Error(requireError ?
                    requireError.toString() :
                    `Path ${extensionTestsPath} does not point to a valid extension test runner.`);
            } : undefined
        }, envExt, terminalService, storageProxy, secretsExt, preferencesManager, webview, localization, rpc);
        return pluginManager;
    }
}
exports.PluginHostRPC = PluginHostRPC;


/***/ }),

/***/ "../../packages/plugin-ext/lib/hosted/node/plugin-host.js":
/*!****************************************************************!*\
  !*** ../../packages/plugin-ext/lib/hosted/node/plugin-host.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
__webpack_require__(/*! @theia/core/shared/reflect-metadata */ "../../packages/core/shared/reflect-metadata/index.js");
const rpc_protocol_1 = __webpack_require__(/*! ../../common/rpc-protocol */ "../../packages/plugin-ext/lib/common/rpc-protocol.js");
const hosted_plugin_protocol_1 = __webpack_require__(/*! ./hosted-plugin-protocol */ "../../packages/plugin-ext/lib/hosted/node/hosted-plugin-protocol.js");
const plugin_host_rpc_1 = __webpack_require__(/*! ./plugin-host-rpc */ "../../packages/plugin-ext/lib/hosted/node/plugin-host-rpc.js");
const node_1 = __webpack_require__(/*! @theia/core/lib/node */ "../../packages/core/lib/node/index.js");
console.log('PLUGIN_HOST(' + process.pid + ') starting instance');
// override exit() function, to do not allow plugin kill this node
process.exit = function (code) {
    const err = new Error('An plugin call process.exit() and it was prevented.');
    console.warn(err.stack);
};
// same for 'crash'(works only in electron)
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const proc = process;
if (proc.crash) {
    proc.crash = function () {
        const err = new Error('An plugin call process.crash() and it was prevented.');
        console.warn(err.stack);
    };
}
process.on('uncaughtException', (err) => {
    console.error(err);
});
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const unhandledPromises = [];
// eslint-disable-next-line @typescript-eslint/no-explicit-any
process.on('unhandledRejection', (reason, promise) => {
    unhandledPromises.push(promise);
    setTimeout(() => {
        const index = unhandledPromises.indexOf(promise);
        if (index >= 0) {
            promise.catch(err => {
                unhandledPromises.splice(index, 1);
                if (terminating && (rpc_protocol_1.ConnectionClosedError.is(err) || rpc_protocol_1.ConnectionClosedError.is(reason))) {
                    // during termination it is expected that pending rpc request are rejected
                    return;
                }
                console.error(`Promise rejection not handled in one second: ${err} , reason: ${reason}`);
                if (err && err.stack) {
                    console.error(`With stack trace: ${err.stack}`);
                }
            });
        }
    }, 1000);
});
// eslint-disable-next-line @typescript-eslint/no-explicit-any
process.on('rejectionHandled', (promise) => {
    const index = unhandledPromises.indexOf(promise);
    if (index >= 0) {
        unhandledPromises.splice(index, 1);
    }
});
let terminating = false;
const channel = new node_1.IPCChannel();
const rpc = new rpc_protocol_1.RPCProtocolImpl(channel);
process.on('message', async (message) => {
    if (terminating) {
        return;
    }
    try {
        const msg = JSON.parse(message);
        if (hosted_plugin_protocol_1.ProcessTerminateMessage.is(msg)) {
            terminating = true;
            if (msg.stopTimeout) {
                await Promise.race([
                    pluginHostRPC.terminate(),
                    new Promise(resolve => setTimeout(resolve, msg.stopTimeout))
                ]);
            }
            else {
                await pluginHostRPC.terminate();
            }
            rpc.dispose();
            if (process.send) {
                process.send(JSON.stringify({ type: hosted_plugin_protocol_1.ProcessTerminatedMessage.TYPE }));
            }
        }
    }
    catch (e) {
        console.error(e);
    }
});
const pluginHostRPC = new plugin_host_rpc_1.PluginHostRPC(rpc);
pluginHostRPC.initialize();


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/authentication-ext.js":
/*!******************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/authentication-ext.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthenticationExtImpl = void 0;
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// code copied and modified from https://github.com/microsoft/vscode/blob/1.47.3/src/vs/workbench/api/common/extHostAuthentication.ts
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../packages/core/lib/common/event.js");
class AuthenticationExtImpl {
    constructor(rpc) {
        this.authenticationProviders = new Map();
        this.onDidChangeSessionsEmitter = new event_1.Emitter();
        this.onDidChangeSessions = this.onDidChangeSessionsEmitter.event;
        this.proxy = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.AUTHENTICATION_MAIN);
    }
    async getSession(requestingExtension, providerId, scopes, options = {}) {
        const extensionName = requestingExtension.model.displayName || requestingExtension.model.name;
        const extensionId = requestingExtension.model.id.toLowerCase();
        return this.proxy.$getSession(providerId, scopes, extensionId, extensionName, options);
    }
    registerAuthenticationProvider(id, label, provider, options) {
        if (this.authenticationProviders.get(id)) {
            throw new Error(`An authentication provider with id '${id}' is already registered.`);
        }
        this.authenticationProviders.set(id, provider);
        const listener = provider.onDidChangeSessions(e => {
            this.proxy.$onDidChangeSessions(id, e);
        });
        this.proxy.$registerAuthenticationProvider(id, label, !!(options === null || options === void 0 ? void 0 : options.supportsMultipleAccounts));
        return new types_impl_1.Disposable(() => {
            listener.dispose();
            this.authenticationProviders.delete(id);
            this.proxy.$unregisterAuthenticationProvider(id);
        });
    }
    $createSession(providerId, scopes) {
        const authProvider = this.authenticationProviders.get(providerId);
        if (authProvider) {
            return Promise.resolve(authProvider.createSession(scopes));
        }
        throw new Error(`Unable to find authentication provider with handle: ${providerId}`);
    }
    $removeSession(providerId, sessionId) {
        const authProvider = this.authenticationProviders.get(providerId);
        if (authProvider) {
            return Promise.resolve(authProvider.removeSession(sessionId));
        }
        throw new Error(`Unable to find authentication provider with handle: ${providerId}`);
    }
    async $getSessions(providerId, scopes) {
        const authProvider = this.authenticationProviders.get(providerId);
        if (authProvider) {
            const sessions = await authProvider.getSessions(scopes);
            /* Wrap the session object received from the plugin to prevent serialization mismatches
            e.g. if the plugin object is constructed with the help of getters they won't be serialized:
            class SessionImpl implements AuthenticationSession {
                private _id;
                get id() {
                    return _id;
                }
            ...
            } will translate to JSON as { _id: '<sessionid>' } not { id: '<sessionid>' } */
            return sessions.map(session => ({
                id: session.id,
                accessToken: session.accessToken,
                account: { id: session.account.id, label: session.account.label },
                scopes: session.scopes
            }));
        }
        throw new Error(`Unable to find authentication provider with handle: ${providerId}`);
    }
    async $onDidChangeAuthenticationSessions(provider) {
        this.onDidChangeSessionsEmitter.fire({ provider });
    }
}
exports.AuthenticationExtImpl = AuthenticationExtImpl;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/clipboard-ext.js":
/*!*************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/clipboard-ext.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 RedHat and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClipboardExt = void 0;
const common_1 = __webpack_require__(/*! ../common */ "../../packages/plugin-ext/lib/common/index.js");
class ClipboardExt {
    constructor(rpc) {
        this.proxy = rpc.getProxy(common_1.PLUGIN_RPC_CONTEXT.CLIPBOARD_MAIN);
    }
    readText() {
        return this.proxy.$readText();
    }
    writeText(value) {
        return this.proxy.$writeText(value);
    }
}
exports.ClipboardExt = ClipboardExt;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/command-registry.js":
/*!****************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/command-registry.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandsConverter = exports.CommandRegistryImpl = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const known_commands_1 = __webpack_require__(/*! ./known-commands */ "../../packages/plugin-ext/lib/plugin/known-commands.js");
class CommandRegistryImpl {
    constructor(rpc) {
        this.commands = new Set();
        this.handlers = new Map();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.COMMAND_REGISTRY_MAIN);
        this.argumentProcessors = [];
        this.commandsConverter = new CommandsConverter(this);
    }
    get converter() {
        return this.commandsConverter;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    registerCommand(command, handler, thisArg) {
        if (this.commands.has(command.id)) {
            throw new Error(`Command ${command.id} already exist`);
        }
        this.commands.add(command.id);
        this.proxy.$registerCommand(command);
        const toDispose = [];
        if (handler) {
            toDispose.push(this.registerHandler(command.id, handler, thisArg));
        }
        toDispose.push(types_impl_1.Disposable.create(() => {
            this.commands.delete(command.id);
            this.proxy.$unregisterCommand(command.id);
        }));
        return types_impl_1.Disposable.from(...toDispose);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    registerHandler(commandId, handler, thisArg) {
        if (this.handlers.has(commandId)) {
            throw new Error(`Command "${commandId}" already has handler`);
        }
        this.proxy.$registerHandler(commandId);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.handlers.set(commandId, (...args) => handler.apply(thisArg, args));
        return types_impl_1.Disposable.create(() => {
            this.handlers.delete(commandId);
            this.proxy.$unregisterHandler(commandId);
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    $executeCommand(id, ...args) {
        if (this.handlers.has(id)) {
            return this.executeLocalCommand(id, ...args);
        }
        else {
            return Promise.reject(new Error(`Command: ${id} does not exist.`));
        }
    }
    /* eslint-disable @typescript-eslint/no-explicit-any */
    executeCommand(id, ...args) {
        if (this.handlers.has(id)) {
            return this.executeLocalCommand(id, ...args);
        }
        else if (known_commands_1.KnownCommands.mapped(id)) {
            // Using the KnownCommand exclusions, convert the commands manually
            return known_commands_1.KnownCommands.map(id, args, (mappedId, mappedArgs, mappedResult) => {
                const mr = mappedResult;
                return this.proxy.$executeCommand(mappedId, ...mappedArgs || []).then((result) => {
                    if (!result) {
                        return undefined;
                    }
                    if (!mr) {
                        return result;
                    }
                    return mr(result);
                });
            });
        }
        else {
            return this.proxy.$executeCommand(id, ...args);
        }
    }
    /* eslint-enable @typescript-eslint/no-explicit-any */
    getKeyBinding(commandId) {
        return this.proxy.$getKeyBinding(commandId);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async executeLocalCommand(id, ...args) {
        const handler = this.handlers.get(id);
        if (handler) {
            return handler(...args.map(arg => this.argumentProcessors.reduce((r, p) => p.processArgument(r), arg)));
        }
        else {
            throw new Error(`No handler exists for command '${id}'`);
        }
    }
    async getCommands(filterUnderscoreCommands = false) {
        const result = await this.proxy.$getCommands();
        if (filterUnderscoreCommands) {
            return result.filter(command => command[0] !== '_');
        }
        return result;
    }
    registerArgumentProcessor(processor) {
        this.argumentProcessors.push(processor);
    }
}
exports.CommandRegistryImpl = CommandRegistryImpl;
// copied and modified from https://github.com/microsoft/vscode/blob/1.37.1/src/vs/workbench/api/common/extHostCommands.ts#L217-L259
class CommandsConverter {
    constructor(commands) {
        this.commandsMap = new Map();
        this.handle = 0;
        this.safeCommandId = `theia_safe_cmd_${Date.now().toString()}`;
        this.commands = commands;
        this.isSafeCommandRegistered = false;
    }
    toSafeCommand(command, disposables) {
        if (!command) {
            return undefined;
        }
        const result = this.toInternalCommand(command);
        if (known_commands_1.KnownCommands.mapped(result.id)) {
            return result;
        }
        if (!this.isSafeCommandRegistered) {
            this.commands.registerCommand({ id: this.safeCommandId }, this.executeSafeCommand, this);
            this.isSafeCommandRegistered = true;
        }
        if (command.arguments && command.arguments.length > 0) {
            const id = this.handle++;
            this.commandsMap.set(id, command);
            disposables.push(new types_impl_1.Disposable(() => this.commandsMap.delete(id)));
            result.id = this.safeCommandId;
            result.arguments = [id];
        }
        return result;
    }
    toInternalCommand(external) {
        // we're deprecating Command.id, so it has to be optional.
        // Existing code will have compiled against a non - optional version of the field, so asserting it to exist is ok
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return known_commands_1.KnownCommands.map(external.command, external.arguments, (mappedId, mappedArgs) => ({
            id: mappedId,
            title: external.title || ' ',
            tooltip: external.tooltip,
            arguments: mappedArgs
        }));
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    executeSafeCommand(...args) {
        const command = this.commandsMap.get(args[0]);
        if (!command || !command.command) {
            return Promise.reject(`command ${args[0]} not found`);
        }
        return this.commands.executeCommand(command.command, ...(command.arguments || []));
    }
}
exports.CommandsConverter = CommandsConverter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/comments.js":
/*!********************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/comments.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExtHostCommentThread = exports.CommentsExtImpl = void 0;
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const plugin_api_rpc_model_1 = __webpack_require__(/*! ../common/plugin-api-rpc-model */ "../../packages/plugin-ext/lib/common/plugin-api-rpc-model.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../packages/core/lib/common/event.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../packages/core/lib/common/disposable.js");
const type_converters_1 = __webpack_require__(/*! ./type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
class CommentsExtImpl {
    constructor(rpc, commands, _documents) {
        this.rpc = rpc;
        this.commands = commands;
        this._documents = _documents;
        this.handle = 0;
        this.commentControllers = new Map();
        this.commentControllersByExtension = new Map();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.COMMENTS_MAIN);
        commands.registerArgumentProcessor({
            processArgument: arg => {
                if (plugin_api_rpc_1.CommentsCommandArg.is(arg)) {
                    const commentController = this.commentControllers.get(arg.commentControlHandle);
                    if (!commentController) {
                        return arg;
                    }
                    const commentThread = commentController.getCommentThread(arg.commentThreadHandle);
                    if (!commentThread) {
                        return arg;
                    }
                    return {
                        thread: commentThread,
                        text: arg.text
                    };
                }
                else if (plugin_api_rpc_1.CommentsContextCommandArg.is(arg)) {
                    const commentController = this.commentControllers.get(arg.commentControlHandle);
                    if (!commentController) {
                        return arg;
                    }
                    const commentThread = commentController.getCommentThread(arg.commentThreadHandle);
                    if (!commentThread) {
                        return arg;
                    }
                    const comment = commentThread.getCommentByUniqueId(arg.commentUniqueId);
                    if (!comment) {
                        return arg;
                    }
                    return comment;
                }
                else if (plugin_api_rpc_1.CommentsEditCommandArg.is(arg)) {
                    const commentController = this.commentControllers.get(arg.commentControlHandle);
                    if (!commentController) {
                        return arg;
                    }
                    const commentThread = commentController.getCommentThread(arg.commentThreadHandle);
                    if (!commentThread) {
                        return arg;
                    }
                    const comment = commentThread.getCommentByUniqueId(arg.commentUniqueId);
                    if (!comment) {
                        return arg;
                    }
                    comment.body = arg.text;
                    return comment;
                }
                return arg;
            }
        });
    }
    createCommentController(plugin, id, label) {
        const handle = this.handle++;
        const commentController = new CommentController(plugin.model.id, this.proxy, handle, id, label);
        this.commentControllers.set(commentController.handle, commentController);
        const commentControllers = this.commentControllersByExtension.get(plugin.model.id.toLowerCase()) || [];
        commentControllers.push(commentController);
        this.commentControllersByExtension.set(plugin.model.id.toLowerCase(), commentControllers);
        return commentController;
    }
    $createCommentThreadTemplate(commentControllerHandle, uriComponents, range) {
        const commentController = this.commentControllers.get(commentControllerHandle);
        if (!commentController) {
            return;
        }
        commentController.$createCommentThreadTemplate(uriComponents, range);
    }
    async $updateCommentThreadTemplate(commentControllerHandle, threadHandle, range) {
        const commentController = this.commentControllers.get(commentControllerHandle);
        if (!commentController) {
            return;
        }
        commentController.$updateCommentThreadTemplate(threadHandle, range);
    }
    async $deleteCommentThread(commentControllerHandle, commentThreadHandle) {
        const commentController = this.commentControllers.get(commentControllerHandle);
        if (commentController) {
            commentController.$deleteCommentThread(commentThreadHandle);
        }
    }
    async $provideCommentingRanges(commentControllerHandle, uriComponents, token) {
        const commentController = this.commentControllers.get(commentControllerHandle);
        if (!commentController || !commentController.commentingRangeProvider) {
            return Promise.resolve(undefined);
        }
        const documentData = this._documents.getDocumentData(types_impl_1.URI.revive(uriComponents));
        if (documentData) {
            const ranges = await commentController.commentingRangeProvider.provideCommentingRanges(documentData.document, token);
            if (ranges) {
                return ranges.map(x => (0, type_converters_1.fromRange)(x));
            }
        }
    }
}
exports.CommentsExtImpl = CommentsExtImpl;
class ExtHostCommentThread {
    constructor(proxy, commentController, _id, _uri, _range, _comments, extensionId) {
        this.proxy = proxy;
        this.commentController = commentController;
        this._id = _id;
        this._uri = _uri;
        this._range = _range;
        this._comments = _comments;
        this.handle = ExtHostCommentThread._handlePool++;
        this.commentHandle = 0;
        this.modifications = Object.create(null);
        this._onDidUpdateCommentThread = new event_1.Emitter();
        this.onDidUpdateCommentThread = this._onDidUpdateCommentThread.event;
        this._canReply = true;
        this.commentsMap = new Map();
        this.acceptInputDisposables = new disposable_1.DisposableCollection();
        if (this._id === undefined) {
            this._id = `${commentController.id}.${this.handle}`;
        }
        this.proxy.$createCommentThread(this.commentController.handle, this.handle, this._id, this._uri, (0, type_converters_1.fromRange)(this._range), extensionId);
        this.localDisposables = [];
        this._isDisposed = false;
        this.localDisposables.push(this.onDidUpdateCommentThread(() => {
            this.eventuallyUpdateCommentThread();
        }));
        // set up comments after ctor to batch update events.
        this.comments = _comments;
    }
    set threadId(id) {
        this._id = id;
    }
    get threadId() {
        return this._id;
    }
    get id() {
        return this._id;
    }
    get resource() {
        return this._uri;
    }
    get uri() {
        return this._uri;
    }
    set range(range) {
        if (!range.isEqual(this._range)) {
            this._range = range;
            this.modifications.range = range;
            this._onDidUpdateCommentThread.fire();
        }
    }
    get range() {
        return this._range;
    }
    get label() {
        return this._label;
    }
    set label(label) {
        this._label = label;
        this.modifications.label = label;
        this._onDidUpdateCommentThread.fire();
    }
    get contextValue() {
        return this._contextValue;
    }
    set contextValue(context) {
        this._contextValue = context;
        this.modifications.contextValue = context;
        this._onDidUpdateCommentThread.fire();
    }
    get comments() {
        return this._comments;
    }
    set comments(newComments) {
        this._comments = newComments;
        this.modifications.comments = newComments;
        this._onDidUpdateCommentThread.fire();
    }
    get collapsibleState() {
        return this.collapseState;
    }
    set collapsibleState(newState) {
        this.collapseState = newState;
        this.modifications.collapsibleState = newState;
        this._onDidUpdateCommentThread.fire();
    }
    get state() {
        return this._state;
    }
    set state(newState) {
        if (this._state !== newState) {
            this._state = newState;
            this.modifications.state = newState;
            this._onDidUpdateCommentThread.fire();
        }
    }
    get isDisposed() {
        return this._isDisposed;
    }
    get canReply() {
        return this._canReply;
    }
    set canReply(canReply) {
        this._canReply = canReply;
        this.modifications.canReply = canReply;
        this._onDidUpdateCommentThread.fire();
    }
    eventuallyUpdateCommentThread() {
        if (this._isDisposed) {
            return;
        }
        const modified = (value) => Object.prototype.hasOwnProperty.call(this.modifications, value);
        const formattedModifications = {};
        if (modified('range')) {
            formattedModifications.range = (0, type_converters_1.fromRange)(this._range);
        }
        if (modified('label')) {
            formattedModifications.label = this.label;
        }
        if (modified('contextValue')) {
            formattedModifications.contextValue = this.contextValue;
        }
        if (modified('comments')) {
            formattedModifications.comments =
                this._comments.map(comment => convertToModeComment(this, this.commentController, comment, this.commentsMap));
        }
        if (modified('collapsibleState')) {
            formattedModifications.collapseState = convertToCollapsibleState(this.collapseState);
        }
        if (modified('state')) {
            formattedModifications.state = convertToState(this._state);
        }
        if (modified('canReply')) {
            formattedModifications.canReply = this.canReply;
        }
        this.modifications = {};
        this.proxy.$updateCommentThread(this.commentController.handle, this.handle, this._id, this._uri, formattedModifications);
    }
    getCommentByUniqueId(uniqueId) {
        for (const key of this.commentsMap) {
            const comment = key[0];
            const id = key[1];
            if (uniqueId === id) {
                return comment;
            }
        }
        return;
    }
    dispose() {
        this._isDisposed = true;
        this.acceptInputDisposables.dispose();
        this.localDisposables.forEach(disposable => disposable.dispose());
        this.proxy.$deleteCommentThread(this.commentController.handle, this.handle);
    }
}
exports.ExtHostCommentThread = ExtHostCommentThread;
ExtHostCommentThread._handlePool = 0;
class CommentController {
    constructor(extension, proxy, _handle, _id, _label) {
        this.extension = extension;
        this.proxy = proxy;
        this._handle = _handle;
        this._id = _id;
        this._label = _label;
        this.threads = new Map();
        this.proxy.$registerCommentController(this.handle, _id, _label);
    }
    get id() {
        return this._id;
    }
    get label() {
        return this._label;
    }
    get handle() {
        return this._handle;
    }
    get options() {
        return this._options;
    }
    set options(options) {
        this._options = options;
        this.proxy.$updateCommentControllerFeatures(this.handle, { options: this._options });
    }
    createCommentThread(arg0, arg1, arg2, arg3) {
        if (typeof arg0 === 'string') {
            const commentThread = new ExtHostCommentThread(this.proxy, this, arg0, arg1, arg2, arg3, this.extension);
            this.threads.set(commentThread.handle, commentThread);
            return commentThread;
        }
        else {
            const commentThread = new ExtHostCommentThread(this.proxy, this, undefined, arg0, arg1, arg2, this.extension);
            this.threads.set(commentThread.handle, commentThread);
            return commentThread;
        }
    }
    $createCommentThreadTemplate(uriComponents, range) {
        const commentThread = new ExtHostCommentThread(this.proxy, this, undefined, types_impl_1.URI.revive(uriComponents), (0, type_converters_1.toRange)(range), [], this.extension);
        commentThread.collapsibleState = plugin_api_rpc_model_1.CommentThreadCollapsibleState.Expanded;
        this.threads.set(commentThread.handle, commentThread);
        return commentThread;
    }
    $updateCommentThreadTemplate(threadHandle, range) {
        const thread = this.threads.get(threadHandle);
        if (thread) {
            thread.range = (0, type_converters_1.toRange)(range);
        }
    }
    $deleteCommentThread(threadHandle) {
        const thread = this.threads.get(threadHandle);
        if (thread) {
            thread.dispose();
        }
        this.threads.delete(threadHandle);
    }
    getCommentThread(handle) {
        return this.threads.get(handle);
    }
    dispose() {
        this.threads.forEach(value => {
            value.dispose();
        });
        this.proxy.$unregisterCommentController(this.handle);
    }
}
function convertToModeComment(thread, commentController, theiaComment, commentsMap) {
    let commentUniqueId = commentsMap.get(theiaComment);
    if (!commentUniqueId) {
        commentUniqueId = ++thread.commentHandle;
        commentsMap.set(theiaComment, commentUniqueId);
    }
    const iconPath = theiaComment.author && theiaComment.author.iconPath ? theiaComment.author.iconPath.toString() : undefined;
    const date = theiaComment.timestamp ? theiaComment.timestamp.toISOString() : undefined;
    return {
        mode: theiaComment.mode,
        contextValue: theiaComment.contextValue,
        uniqueIdInThread: commentUniqueId,
        body: (0, type_converters_1.fromMarkdown)(theiaComment.body),
        userName: theiaComment.author.name,
        userIconPath: iconPath,
        label: theiaComment.label,
        timestamp: date,
    };
}
function convertToCollapsibleState(kind) {
    if (kind !== undefined) {
        switch (kind) {
            case types_impl_1.CommentThreadCollapsibleState.Expanded:
                return plugin_api_rpc_model_1.CommentThreadCollapsibleState.Expanded;
            case types_impl_1.CommentThreadCollapsibleState.Collapsed:
                return plugin_api_rpc_model_1.CommentThreadCollapsibleState.Collapsed;
        }
    }
    return plugin_api_rpc_model_1.CommentThreadCollapsibleState.Collapsed;
}
function convertToState(kind) {
    if (kind !== undefined) {
        switch (kind) {
            case types_impl_1.CommentThreadState.Resolved:
                return plugin_api_rpc_model_1.CommentThreadState.Resolved;
            case types_impl_1.CommentThreadState.Unresolved:
                return plugin_api_rpc_model_1.CommentThreadState.Unresolved;
        }
    }
    return plugin_api_rpc_model_1.CommentThreadState.Unresolved;
}


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/custom-editors.js":
/*!**************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/custom-editors.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 SAP SE or an SAP affiliate company and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// copied and modified from https://github.com/microsoft/vscode/blob/53eac52308c4611000a171cc7bf1214293473c78/src/vs/workbench/api/common/extHostCustomEditors.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CustomEditorsExtImpl = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const webviews_1 = __webpack_require__(/*! ./webviews */ "../../packages/plugin-ext/lib/plugin/webviews.js");
const cancellation_1 = __webpack_require__(/*! @theia/core/lib/common/cancellation */ "../../packages/core/lib/common/cancellation.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../packages/core/lib/common/disposable.js");
const cache_1 = __webpack_require__(/*! ../common/cache */ "../../packages/plugin-ext/lib/common/cache.js");
class CustomEditorsExtImpl {
    constructor(rpc, documentExt, webviewExt, workspace) {
        this.documentExt = documentExt;
        this.webviewExt = webviewExt;
        this.workspace = workspace;
        this.editorProviders = new EditorProviderStore();
        this.documents = new CustomDocumentStore();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.CUSTOM_EDITORS_MAIN);
    }
    registerCustomEditorProvider(viewType, provider, options, plugin) {
        const disposables = new disposable_1.DisposableCollection();
        if ('resolveCustomTextEditor' in provider) {
            disposables.push(this.editorProviders.addTextProvider(viewType, plugin, provider));
            this.proxy.$registerTextEditorProvider(viewType, options.webviewOptions || {}, {
                supportsMove: !!provider.moveCustomTextEditor,
            });
        }
        else {
            disposables.push(this.editorProviders.addCustomProvider(viewType, plugin, provider));
            if (this.supportEditing(provider)) {
                disposables.push(provider.onDidChangeCustomDocument((e) => {
                    const entry = this.getCustomDocumentEntry(viewType, e.document.uri);
                    if (isEditEvent(e)) {
                        const editId = entry.addEdit(e);
                        this.proxy.$onDidEdit(e.document.uri, viewType, editId, e.label);
                    }
                    else {
                        this.proxy.$onContentChange(e.document.uri, viewType);
                    }
                }));
            }
            this.proxy.$registerCustomEditorProvider(viewType, options.webviewOptions || {}, !!options.supportsMultipleEditorsPerDocument);
        }
        return types_impl_1.Disposable.from(disposables, types_impl_1.Disposable.create(() => {
            this.proxy.$unregisterEditorProvider(viewType);
        }));
    }
    async $createCustomDocument(resource, viewType, openContext, cancellation) {
        const entry = this.editorProviders.get(viewType);
        if (!entry) {
            throw new Error(`No provider found for '${viewType}'`);
        }
        if (entry.type !== 1 /* Custom */) {
            throw new Error(`Invalid provide type for '${viewType}'`);
        }
        const revivedResource = types_impl_1.URI.revive(resource);
        const document = await entry.provider.openCustomDocument(revivedResource, openContext, cancellation);
        this.documents.add(viewType, document);
        return { editable: this.supportEditing(entry.provider) };
    }
    async $disposeCustomDocument(resource, viewType) {
        const entry = this.editorProviders.get(viewType);
        if (!entry) {
            throw new Error(`No provider found for '${viewType}'`);
        }
        if (entry.type !== 1 /* Custom */) {
            throw new Error(`Invalid provider type for '${viewType}'`);
        }
        const revivedResource = types_impl_1.URI.revive(resource);
        const { document } = this.getCustomDocumentEntry(viewType, revivedResource);
        this.documents.delete(viewType, document);
        document.dispose();
    }
    async $resolveWebviewEditor(resource, handler, viewType, title, widgetOpenerOptions, options, cancellation) {
        const entry = this.editorProviders.get(viewType);
        if (!entry) {
            throw new Error(`No provider found for '${viewType}'`);
        }
        const panel = this.webviewExt.createWebviewPanel(viewType, title, {}, options, entry.plugin, handler);
        const webviewOptions = webviews_1.WebviewImpl.toWebviewOptions(options, this.workspace, entry.plugin);
        await this.proxy.$createCustomEditorPanel(handler, title, widgetOpenerOptions, webviewOptions);
        const revivedResource = types_impl_1.URI.revive(resource);
        switch (entry.type) {
            case 1 /* Custom */: {
                const { document } = this.getCustomDocumentEntry(viewType, revivedResource);
                return entry.provider.resolveCustomEditor(document, panel, cancellation);
            }
            case 0 /* Text */: {
                const document = this.documentExt.getDocument(revivedResource);
                return entry.provider.resolveCustomTextEditor(document, panel, cancellation);
            }
            default: {
                throw new Error('Unknown webview provider type');
            }
        }
    }
    getCustomDocumentEntry(viewType, resource) {
        const entry = this.documents.get(viewType, types_impl_1.URI.revive(resource));
        if (!entry) {
            throw new Error('No custom document found');
        }
        return entry;
    }
    $disposeEdits(resourceComponents, viewType, editIds) {
        const document = this.getCustomDocumentEntry(viewType, resourceComponents);
        document.disposeEdits(editIds);
    }
    async $onMoveCustomEditor(handle, newResourceComponents, viewType) {
        const entry = this.editorProviders.get(viewType);
        if (!entry) {
            throw new Error(`No provider found for '${viewType}'`);
        }
        if (!entry.provider.moveCustomTextEditor) {
            throw new Error(`Provider does not implement move '${viewType}'`);
        }
        const webview = this.webviewExt.getWebviewPanel(handle);
        if (!webview) {
            throw new Error('No webview found');
        }
        const resource = types_impl_1.URI.revive(newResourceComponents);
        const document = this.documentExt.getDocument(resource);
        const cancellationSource = new cancellation_1.CancellationTokenSource();
        await entry.provider.moveCustomTextEditor(document, webview, cancellationSource.token);
    }
    async $undo(resourceComponents, viewType, editId, isDirty) {
        const entry = this.getCustomDocumentEntry(viewType, resourceComponents);
        return entry.undo(editId, isDirty);
    }
    async $redo(resourceComponents, viewType, editId, isDirty) {
        const entry = this.getCustomDocumentEntry(viewType, resourceComponents);
        return entry.redo(editId, isDirty);
    }
    async $revert(resourceComponents, viewType, cancellation) {
        const entry = this.getCustomDocumentEntry(viewType, resourceComponents);
        const provider = this.getCustomEditorProvider(viewType);
        await provider.revertCustomDocument(entry.document, cancellation);
    }
    async $onSave(resourceComponents, viewType, cancellation) {
        const entry = this.getCustomDocumentEntry(viewType, resourceComponents);
        const provider = this.getCustomEditorProvider(viewType);
        await provider.saveCustomDocument(entry.document, cancellation);
    }
    async $onSaveAs(resourceComponents, viewType, targetResource, cancellation) {
        const entry = this.getCustomDocumentEntry(viewType, resourceComponents);
        const provider = this.getCustomEditorProvider(viewType);
        return provider.saveCustomDocumentAs(entry.document, types_impl_1.URI.revive(targetResource), cancellation);
    }
    getCustomEditorProvider(viewType) {
        const entry = this.editorProviders.get(viewType);
        const provider = entry === null || entry === void 0 ? void 0 : entry.provider;
        if (!provider || !this.supportEditing(provider)) {
            throw new Error('Custom document is not editable');
        }
        return provider;
    }
    supportEditing(provider) {
        return !!provider.onDidChangeCustomDocument;
    }
}
exports.CustomEditorsExtImpl = CustomEditorsExtImpl;
function isEditEvent(e) {
    return typeof e.undo === 'function'
        && typeof e.redo === 'function';
}
class CustomDocumentStoreEntry {
    constructor(document) {
        this.document = document;
        this.edits = new cache_1.Cache('custom documents');
    }
    addEdit(item) {
        return this.edits.add([item]);
    }
    async undo(editId, isDirty) {
        await this.getEdit(editId).undo();
    }
    async redo(editId, isDirty) {
        await this.getEdit(editId).redo();
    }
    disposeEdits(editIds) {
        for (const id of editIds) {
            this.edits.delete(id);
        }
    }
    getEdit(editId) {
        const edit = this.edits.get(editId, 0);
        if (!edit) {
            throw new Error('No edit found');
        }
        return edit;
    }
}
class EditorProviderStore {
    constructor() {
        this.providers = new Map();
    }
    addTextProvider(viewType, plugin, provider) {
        return this.add(0 /* Text */, viewType, plugin, provider);
    }
    addCustomProvider(viewType, plugin, provider) {
        return this.add(1 /* Custom */, viewType, plugin, provider);
    }
    get(viewType) {
        return this.providers.get(viewType);
    }
    add(type, viewType, plugin, provider) {
        if (this.providers.has(viewType)) {
            throw new Error(`Provider for viewType:${viewType} already registered`);
        }
        this.providers.set(viewType, { type, plugin: plugin, provider });
        return new types_impl_1.Disposable(() => this.providers.delete(viewType));
    }
}
class CustomDocumentStore {
    constructor() {
        this.documents = new Map();
    }
    get(viewType, resource) {
        return this.documents.get(this.key(viewType, resource));
    }
    add(viewType, document) {
        const key = this.key(viewType, document.uri);
        if (this.documents.has(key)) {
            throw new Error(`Document already exists for viewType:${viewType} resource:${document.uri}`);
        }
        const entry = new CustomDocumentStoreEntry(document);
        this.documents.set(key, entry);
        return entry;
    }
    delete(viewType, document) {
        const key = this.key(viewType, document.uri);
        this.documents.delete(key);
    }
    key(viewType, resource) {
        return `${viewType}@@@${resource}`;
    }
}


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/debug/debug-ext.js":
/*!***************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/debug/debug-ext.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugExtImpl = void 0;
// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../packages/core/lib/common/event.js");
const path_1 = __webpack_require__(/*! @theia/core/lib/common/path */ "../../packages/core/lib/common/path.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../../packages/core/shared/vscode-uri/index.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const debug_uri_utils_1 = __webpack_require__(/*! @theia/debug/lib/common/debug-uri-utils */ "../../packages/debug/lib/common/debug-uri-utils.js");
const types_impl_1 = __webpack_require__(/*! ../types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const plugin_debug_adapter_session_1 = __webpack_require__(/*! ./plugin-debug-adapter-session */ "../../packages/plugin-ext/lib/plugin/debug/plugin-debug-adapter-session.js");
const plugin_debug_adapter_tracker_1 = __webpack_require__(/*! ./plugin-debug-adapter-tracker */ "../../packages/plugin-ext/lib/plugin/debug/plugin-debug-adapter-tracker.js");
const uuid = __webpack_require__(/*! uuid */ "../../node_modules/uuid/dist/esm-node/index.js");
const plugin_debug_adapter_creator_1 = __webpack_require__(/*! ./plugin-debug-adapter-creator */ "../../packages/plugin-ext/lib/plugin/debug/plugin-debug-adapter-creator.js");
const plugin_node_debug_adapter_creator_1 = __webpack_require__(/*! ../node/debug/plugin-node-debug-adapter-creator */ "../../packages/plugin-ext/lib/plugin/node/debug/plugin-node-debug-adapter-creator.js");
/* eslint-disable @typescript-eslint/no-explicit-any */
class DebugExtImpl {
    constructor(rpc) {
        // debug sessions by sessionId
        this.sessions = new Map();
        /**
         * Only use internally, don't send it to the frontend. It's expensive!
         * It's already there as a part of the plugin metadata.
         */
        this.debuggersContributions = new Map();
        this.descriptorFactories = new Map();
        this.trackerFactories = [];
        this.contributionPaths = new Map();
        this.contributionTypes = new Map();
        this.onDidChangeBreakpointsEmitter = new event_1.Emitter();
        this.onDidChangeActiveDebugSessionEmitter = new event_1.Emitter();
        this.onDidTerminateDebugSessionEmitter = new event_1.Emitter();
        this.onDidCreateDebugSessionEmitter = new event_1.Emitter();
        this.onDidStartDebugSessionEmitter = new event_1.Emitter();
        this.onDidReceiveDebugSessionCustomEmitter = new event_1.Emitter();
        this._breakpoints = new Map();
        this.frontendAdapterCreator = new plugin_debug_adapter_creator_1.PluginDebugAdapterCreator();
        this.backendAdapterCreator = new plugin_node_debug_adapter_creator_1.NodeDebugAdapterCreator();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.DEBUG_MAIN);
        this.activeDebugConsole = {
            append: (value) => this.proxy.$appendToDebugConsole(value),
            appendLine: (value) => this.proxy.$appendLineToDebugConsole(value)
        };
        this.configurationProviderHandleGenerator = 0;
        this.configurationProviders = [];
    }
    get breakpoints() {
        return [...this._breakpoints.values()];
    }
    /**
     * Sets dependencies.
     */
    assistedInject(connectionExt, commandRegistryExt) {
        this.connectionExt = connectionExt;
        this.commandRegistryExt = commandRegistryExt;
    }
    /**
     * Registers contributions.
     * @param pluginFolder plugin folder path
     * @param pluginType plugin type
     * @param contributions available debuggers contributions
     */
    registerDebuggersContributions(pluginFolder, pluginType, contributions) {
        contributions.forEach(contribution => {
            this.contributionPaths.set(contribution.type, pluginFolder);
            this.contributionTypes.set(contribution.type, pluginType);
            this.debuggersContributions.set(contribution.type, contribution);
            this.proxy.$registerDebuggerContribution({
                type: contribution.type,
                label: contribution.label || contribution.type
            });
            console.log(`Debugger contribution has been registered: ${contribution.type}`);
        });
    }
    get onDidReceiveDebugSessionCustomEvent() {
        return this.onDidReceiveDebugSessionCustomEmitter.event;
    }
    get onDidChangeActiveDebugSession() {
        return this.onDidChangeActiveDebugSessionEmitter.event;
    }
    get onDidTerminateDebugSession() {
        return this.onDidTerminateDebugSessionEmitter.event;
    }
    get onDidCreateDebugSession() {
        return this.onDidCreateDebugSessionEmitter.event;
    }
    get onDidStartDebugSession() {
        return this.onDidStartDebugSessionEmitter.event;
    }
    get onDidChangeBreakpoints() {
        return this.onDidChangeBreakpointsEmitter.event;
    }
    addBreakpoints(breakpoints) {
        const added = [];
        for (const b of breakpoints) {
            if (this._breakpoints.has(b.id)) {
                continue;
            }
            this._breakpoints.set(b.id, b);
            added.push(b);
        }
        if (added.length) {
            this.onDidChangeBreakpointsEmitter.fire({ added, removed: [], changed: [] });
            this.proxy.$addBreakpoints(added);
        }
    }
    removeBreakpoints(breakpoints) {
        const removed = [];
        const removedIds = [];
        for (const b of breakpoints) {
            if (!this._breakpoints.has(b.id)) {
                continue;
            }
            this._breakpoints.delete(b.id);
            removed.push(b);
            removedIds.push(b.id);
        }
        if (removed.length) {
            this.onDidChangeBreakpointsEmitter.fire({ added: [], removed, changed: [] });
            this.proxy.$removeBreakpoints(removedIds);
        }
    }
    startDebugging(folder, nameOrConfiguration, options) {
        var _a;
        return this.proxy.$startDebugging(folder, nameOrConfiguration, {
            parentSessionId: (_a = options.parentSession) === null || _a === void 0 ? void 0 : _a.id,
            compact: options.compact,
            consoleMode: options.consoleMode,
            suppressSaveBeforeStart: options.suppressSaveBeforeStart,
            suppressDebugStatusbar: options.suppressDebugStatusbar,
            suppressDebugView: options.suppressDebugView,
            lifecycleManagedByParent: options.lifecycleManagedByParent,
            noDebug: options.noDebug
        });
    }
    stopDebugging(session) {
        return this.proxy.$stopDebugging(session === null || session === void 0 ? void 0 : session.id);
    }
    asDebugSourceUri(source, session) {
        return this.getDebugSourceUri(source, session === null || session === void 0 ? void 0 : session.id);
    }
    getDebugSourceUri(raw, sessionId) {
        var _a;
        if (raw.sourceReference && raw.sourceReference > 0) {
            let query = 'ref=' + String(raw.sourceReference);
            if (sessionId) {
                query += `&session=${sessionId}`;
            }
            return types_impl_1.URI.from({ scheme: debug_uri_utils_1.DEBUG_SCHEME, path: (_a = raw.path) !== null && _a !== void 0 ? _a : '', query });
        }
        if (!raw.path) {
            throw new Error('Unrecognized source type: ' + JSON.stringify(raw));
        }
        if (raw.path.match(debug_uri_utils_1.SCHEME_PATTERN)) {
            return types_impl_1.URI.parse(raw.path);
        }
        return types_impl_1.URI.file(raw.path);
    }
    registerDebugAdapterDescriptorFactory(debugType, factory) {
        if (this.descriptorFactories.has(debugType)) {
            throw new Error(`Descriptor factory for ${debugType} has been already registered`);
        }
        this.descriptorFactories.set(debugType, factory);
        return types_impl_1.Disposable.create(() => this.descriptorFactories.delete(debugType));
    }
    registerDebugAdapterTrackerFactory(debugType, factory) {
        if (!factory) {
            return types_impl_1.Disposable.create(() => { });
        }
        this.trackerFactories.push([debugType, factory]);
        return types_impl_1.Disposable.create(() => {
            this.trackerFactories = this.trackerFactories.filter(tuple => tuple[1] !== factory);
        });
    }
    registerDebugConfigurationProvider(debugType, provider, trigger) {
        console.log(`Debug configuration provider has been registered: ${debugType}, trigger: ${trigger}`);
        const handle = this.configurationProviderHandleGenerator++;
        this.configurationProviders.push({ handle, type: debugType, trigger, provider });
        const descriptor = {
            handle,
            type: debugType,
            trigger,
            provideDebugConfiguration: !!provider.provideDebugConfigurations,
            resolveDebugConfigurations: !!provider.resolveDebugConfiguration,
            resolveDebugConfigurationWithSubstitutedVariables: !!provider.resolveDebugConfigurationWithSubstitutedVariables
        };
        this.proxy.$registerDebugConfigurationProvider(descriptor);
        return types_impl_1.Disposable.create(() => {
            this.configurationProviders = this.configurationProviders.filter(p => (p.handle !== handle));
            this.proxy.$unregisterDebugConfigurationProvider(handle);
        });
    }
    async $onSessionCustomEvent(sessionId, event, body) {
        const session = this.sessions.get(sessionId);
        if (session) {
            this.onDidReceiveDebugSessionCustomEmitter.fire({ event, body, session });
        }
    }
    async $sessionDidCreate(sessionId) {
        const session = this.sessions.get(sessionId);
        if (session) {
            this.onDidCreateDebugSessionEmitter.fire(session);
        }
    }
    async $sessionDidStart(sessionId) {
        const session = this.sessions.get(sessionId);
        if (session) {
            this.onDidStartDebugSessionEmitter.fire(session);
        }
    }
    async $sessionDidDestroy(sessionId) {
        const session = this.sessions.get(sessionId);
        if (session) {
            this.onDidTerminateDebugSessionEmitter.fire(session);
            this.sessions.delete(sessionId);
        }
    }
    async $sessionDidChange(sessionId) {
        this.activeDebugSession = sessionId ? this.sessions.get(sessionId) : undefined;
        this.onDidChangeActiveDebugSessionEmitter.fire(this.activeDebugSession);
    }
    async $breakpointsDidChange(added, removed, changed) {
        const a = [];
        const r = [];
        const c = [];
        for (const b of added) {
            if (this._breakpoints.has(b.id)) {
                continue;
            }
            const bExt = this.toBreakpointExt(b);
            if (bExt) {
                this._breakpoints.set(bExt.id, bExt);
                a.push(bExt);
            }
        }
        for (const id of removed) {
            const bExt = this._breakpoints.get(id);
            if (bExt) {
                this._breakpoints.delete(id);
                r.push(bExt);
            }
        }
        for (const b of changed) {
            const bExt = this._breakpoints.get(b.id);
            if (bExt) {
                const { functionName, location, enabled, condition, hitCondition, logMessage } = b;
                if (bExt instanceof types_impl_1.FunctionBreakpoint && functionName) {
                    Object.assign(bExt, { enabled, condition, hitCondition, logMessage, functionName });
                }
                else if (bExt instanceof types_impl_1.SourceBreakpoint && location) {
                    const range = new types_impl_1.Range(location.range.startLineNumber, location.range.startColumn, location.range.endLineNumber, location.range.endColumn);
                    Object.assign(bExt, { enabled, condition, hitCondition, logMessage, location: new types_impl_1.Location(vscode_uri_1.URI.revive(location.uri), range) });
                }
                c.push(bExt);
            }
        }
        this.onDidChangeBreakpointsEmitter.fire({ added: a, removed: r, changed: c });
    }
    toBreakpointExt({ functionName, location, enabled, condition, hitCondition, logMessage, id }) {
        if (location) {
            const range = new types_impl_1.Range(location.range.startLineNumber, location.range.startColumn, location.range.endLineNumber, location.range.endColumn);
            return new types_impl_1.SourceBreakpoint(new types_impl_1.Location(vscode_uri_1.URI.revive(location.uri), range), enabled, condition, hitCondition, logMessage, id);
        }
        if (functionName) {
            return new types_impl_1.FunctionBreakpoint(functionName, enabled, condition, hitCondition, logMessage, id);
        }
        return undefined;
    }
    async $createDebugSession(debugConfiguration, workspaceFolderUri) {
        const sessionId = uuid.v4();
        const parentSession = debugConfiguration.parentSessionId ? this.sessions.get(debugConfiguration.parentSessionId) : undefined;
        const theiaSession = {
            id: sessionId,
            type: debugConfiguration.type,
            name: debugConfiguration.name,
            parentSession: parentSession,
            workspaceFolder: this.toWorkspaceFolder(workspaceFolderUri),
            configuration: debugConfiguration,
            customRequest: async (command, args) => {
                var _a;
                const response = await this.proxy.$customRequest(sessionId, command, args);
                if (response && response.success) {
                    return response.body;
                }
                return Promise.reject(new Error((_a = response.message) !== null && _a !== void 0 ? _a : 'custom request failed'));
            },
            getDebugProtocolBreakpoint: async (breakpoint) => this.proxy.$getDebugProtocolBreakpoint(sessionId, breakpoint.id)
        };
        const tracker = await this.createDebugAdapterTracker(theiaSession);
        const communicationProvider = await this.createDebugAdapter(theiaSession, debugConfiguration);
        const debugAdapterSession = new plugin_debug_adapter_session_1.PluginDebugAdapterSession(communicationProvider, tracker, theiaSession);
        this.sessions.set(sessionId, debugAdapterSession);
        const connection = await this.connectionExt.ensureConnection(sessionId);
        debugAdapterSession.start(connection);
        return sessionId;
    }
    async $terminateDebugSession(sessionId) {
        const debugAdapterSession = this.sessions.get(sessionId);
        if (debugAdapterSession) {
            await debugAdapterSession.stop();
        }
    }
    async $getTerminalCreationOptions(debugType) {
        return this.doGetTerminalCreationOptions(debugType);
    }
    async doGetTerminalCreationOptions(debugType) {
        return undefined;
    }
    getConfigurationProviderRecord(handle) {
        const record = this.configurationProviders.find(p => p.handle === handle);
        if (!record) {
            throw new Error('No Debug configuration provider found with given handle number: ' + handle);
        }
        const { provider, type } = record;
        return { provider, type };
    }
    async $provideDebugConfigurationsByHandle(handle, workspaceFolderUri) {
        var _a;
        const { provider, type } = this.getConfigurationProviderRecord(handle);
        const configurations = await ((_a = provider.provideDebugConfigurations) === null || _a === void 0 ? void 0 : _a.call(provider, this.toWorkspaceFolder(workspaceFolderUri)));
        if (!configurations) {
            throw new Error('nothing returned from DebugConfigurationProvider.provideDebugConfigurations, type: ' + type);
        }
        return configurations;
    }
    async $resolveDebugConfigurationByHandle(handle, workspaceFolderUri, debugConfiguration) {
        var _a;
        const { provider } = this.getConfigurationProviderRecord(handle);
        return (_a = provider.resolveDebugConfiguration) === null || _a === void 0 ? void 0 : _a.call(provider, this.toWorkspaceFolder(workspaceFolderUri), debugConfiguration);
    }
    async $resolveDebugConfigurationWithSubstitutedVariablesByHandle(handle, workspaceFolderUri, debugConfiguration) {
        var _a;
        const { provider } = this.getConfigurationProviderRecord(handle);
        return (_a = provider.resolveDebugConfigurationWithSubstitutedVariables) === null || _a === void 0 ? void 0 : _a.call(provider, this.toWorkspaceFolder(workspaceFolderUri), debugConfiguration);
    }
    async createDebugAdapterTracker(session) {
        return plugin_debug_adapter_tracker_1.PluginDebugAdapterTracker.create(session, this.trackerFactories);
    }
    async createDebugAdapter(session, debugConfiguration) {
        const executable = await this.resolveDebugAdapterExecutable(debugConfiguration);
        const descriptorFactory = this.descriptorFactories.get(session.type);
        return this.getAdapterCreator(debugConfiguration).createDebugAdapter(session, debugConfiguration, executable, descriptorFactory);
    }
    async resolveDebugAdapterExecutable(debugConfiguration) {
        const { type } = debugConfiguration;
        const contribution = this.debuggersContributions.get(type);
        if (contribution) {
            if (contribution.adapterExecutableCommand) {
                const executable = await this.commandRegistryExt.executeCommand(contribution.adapterExecutableCommand);
                if (executable) {
                    return executable;
                }
            }
            else {
                const contributionPath = this.contributionPaths.get(type);
                if (contributionPath) {
                    return this.getAdapterCreator(debugConfiguration).resolveDebugAdapterExecutable(contributionPath, contribution);
                }
            }
        }
        throw new Error(`It is not possible to provide debug adapter executable for '${debugConfiguration.type}'.`);
    }
    toWorkspaceFolder(folder) {
        if (!folder) {
            return undefined;
        }
        const uri = vscode_uri_1.URI.parse(folder);
        const path = new path_1.Path(uri.path);
        return {
            uri: uri,
            name: path.base,
            index: 0
        };
    }
    getAdapterCreator(debugConfiguration) {
        const pluginType = this.contributionTypes.get(debugConfiguration.type);
        return pluginType === 'frontend' ? this.frontendAdapterCreator : this.backendAdapterCreator;
    }
}
exports.DebugExtImpl = DebugExtImpl;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/debug/plugin-debug-adapter-creator.js":
/*!**********************************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/debug/plugin-debug-adapter-creator.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 Arm and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginDebugAdapterCreator = void 0;
const types_impl_1 = __webpack_require__(/*! ../types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const inline_debug_adapter_1 = __webpack_require__(/*! @theia/debug/lib/common/inline-debug-adapter */ "../../packages/debug/lib/common/inline-debug-adapter.js");
class PluginDebugAdapterCreator {
    async resolveDebugAdapterExecutable(_pluginPath, _debuggerContribution) {
        // Node is required to run the default executable
        return undefined;
    }
    async createDebugAdapter(session, _debugConfiguration, executable, descriptorFactory) {
        if (descriptorFactory) {
            const descriptor = await descriptorFactory.createDebugAdapterDescriptor(session, executable);
            if (descriptor) {
                if (types_impl_1.DebugAdapterInlineImplementation.is(descriptor)) {
                    return this.connectInlineDebugAdapter(descriptor);
                }
            }
        }
        throw new Error('It is not possible to provide debug adapter executable.');
    }
    connectInlineDebugAdapter(adapter) {
        return new inline_debug_adapter_1.InlineDebugAdapter(adapter.implementation);
    }
}
exports.PluginDebugAdapterCreator = PluginDebugAdapterCreator;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/debug/plugin-debug-adapter-session.js":
/*!**********************************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/debug/plugin-debug-adapter-session.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginDebugAdapterSession = void 0;
const debug_adapter_session_1 = __webpack_require__(/*! @theia/debug/lib/common/debug-adapter-session */ "../../packages/debug/lib/common/debug-adapter-session.js");
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Server debug adapter session.
 */
class PluginDebugAdapterSession extends debug_adapter_session_1.DebugAdapterSessionImpl {
    constructor(debugAdapter, tracker, theiaSession) {
        super(theiaSession.id, debugAdapter);
        this.debugAdapter = debugAdapter;
        this.tracker = tracker;
        this.theiaSession = theiaSession;
    }
    get parentSession() {
        return this.theiaSession.parentSession;
    }
    get type() {
        return this.theiaSession.type;
    }
    get name() {
        return this.theiaSession.name;
    }
    ;
    get workspaceFolder() {
        return this.theiaSession.workspaceFolder;
    }
    ;
    get configuration() {
        return this.theiaSession.configuration;
    }
    ;
    async start(channel) {
        if (this.tracker.onWillStartSession) {
            this.tracker.onWillStartSession();
        }
        await super.start(channel);
    }
    async stop() {
        if (this.tracker.onWillStopSession) {
            this.tracker.onWillStopSession();
        }
        await super.stop();
    }
    async customRequest(command, args) {
        return this.theiaSession.customRequest(command, args);
    }
    async getDebugProtocolBreakpoint(breakpoint) {
        return this.theiaSession.getDebugProtocolBreakpoint(breakpoint);
    }
    onDebugAdapterError(error) {
        if (this.tracker.onError) {
            this.tracker.onError(error);
        }
        super.onDebugAdapterError(error);
    }
    send(message) {
        try {
            super.send(message);
        }
        finally {
            if (this.tracker.onDidSendMessage) {
                this.tracker.onDidSendMessage(JSON.parse(message));
            }
        }
    }
    write(message) {
        if (this.tracker.onWillReceiveMessage) {
            this.tracker.onWillReceiveMessage(JSON.parse(message));
        }
        super.write(message);
    }
    onDebugAdapterExit() {
        if (this.tracker.onExit) {
            this.tracker.onExit(undefined, undefined);
        }
        super.onDebugAdapterExit();
    }
}
exports.PluginDebugAdapterSession = PluginDebugAdapterSession;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/debug/plugin-debug-adapter-tracker.js":
/*!**********************************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/debug/plugin-debug-adapter-tracker.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginDebugAdapterTracker = void 0;
class PluginDebugAdapterTracker {
    constructor(trackers) {
        this.trackers = trackers;
    }
    static async create(session, trackerFactories) {
        const trackers = [];
        const factories = trackerFactories.filter(tuple => tuple[0] === '*' || tuple[0] === session.type).map(tuple => tuple[1]);
        for (const factory of factories) {
            const tracker = await factory.createDebugAdapterTracker(session);
            if (tracker) {
                trackers.push(tracker);
            }
        }
        return new PluginDebugAdapterTracker(trackers);
    }
    onWillStartSession() {
        this.trackers.forEach(tracker => {
            if (tracker.onWillStartSession) {
                tracker.onWillStartSession();
            }
        });
    }
    onWillReceiveMessage(message) {
        this.trackers.forEach(tracker => {
            if (tracker.onWillReceiveMessage) {
                tracker.onWillReceiveMessage(message);
            }
        });
    }
    onDidSendMessage(message) {
        this.trackers.forEach(tracker => {
            if (tracker.onDidSendMessage) {
                tracker.onDidSendMessage(message);
            }
        });
    }
    onWillStopSession() {
        this.trackers.forEach(tracker => {
            if (tracker.onWillStopSession) {
                tracker.onWillStopSession();
            }
        });
    }
    onError(error) {
        this.trackers.forEach(tracker => {
            if (tracker.onError) {
                tracker.onError(error);
            }
        });
    }
    onExit(code, signal) {
        this.trackers.forEach(tracker => {
            if (tracker.onExit) {
                tracker.onExit(code, signal);
            }
        });
    }
}
exports.PluginDebugAdapterTracker = PluginDebugAdapterTracker;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/decorations.js":
/*!***********************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/decorations.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DecorationsExtImpl = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const path_1 = __webpack_require__(/*! path */ "path");
class DecorationsExtImpl {
    constructor(rpc) {
        this.rpc = rpc;
        this.proxy = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.DECORATIONS_MAIN);
        this.providersMap = new Map();
    }
    registerFileDecorationProvider(provider, pluginInfo) {
        const handle = DecorationsExtImpl.handle++;
        this.providersMap.set(handle, { provider, pluginInfo });
        this.proxy.$registerDecorationProvider(handle);
        const listener = provider.onDidChangeFileDecorations && provider.onDidChangeFileDecorations(e => {
            if (!e) {
                this.proxy.$onDidChange(handle, null);
                return;
            }
            const array = Array.isArray(e) ? e : [e];
            if (array.length <= DecorationsExtImpl.maxEventSize) {
                this.proxy.$onDidChange(handle, array);
                return;
            }
            // too many resources per event. pick one resource per folder, starting
            // with parent folders
            const mapped = array.map(uri => ({ uri, rank: (uri.path.match(/\//g) || []).length }));
            const groups = groupBy(mapped, (a, b) => a.rank - b.rank);
            const picked = [];
            outer: for (const uris of groups) {
                let lastDirname;
                for (const obj of uris) {
                    const myDirname = (0, path_1.dirname)(obj.uri.path);
                    if (lastDirname !== myDirname) {
                        lastDirname = myDirname;
                        if (picked.push(obj.uri) >= DecorationsExtImpl.maxEventSize) {
                            break outer;
                        }
                    }
                }
            }
            this.proxy.$onDidChange(handle, picked);
        });
        return new types_impl_1.Disposable(() => {
            listener === null || listener === void 0 ? void 0 : listener.dispose();
            this.proxy.$unregisterDecorationProvider(handle);
            this.providersMap.delete(handle);
        });
        function groupBy(data, compareFn) {
            const result = [];
            let currentGroup = undefined;
            for (const element of data.slice(0).sort(compareFn)) {
                if (!currentGroup || compareFn(currentGroup[0], element) !== 0) {
                    currentGroup = [element];
                    result.push(currentGroup);
                }
                else {
                    currentGroup.push(element);
                }
            }
            return result;
        }
    }
    async $provideDecorations(handle, requests, token) {
        if (!this.providersMap.has(handle)) {
            // might have been unregistered in the meantime
            return Object.create(null);
        }
        const result = Object.create(null);
        const { provider, pluginInfo } = this.providersMap.get(handle);
        await Promise.all(requests.map(async (request) => {
            try {
                const { uri, id } = request;
                const data = await Promise.resolve(provider.provideFileDecoration(types_impl_1.URI.revive(uri), token));
                if (!data) {
                    return;
                }
                try {
                    types_impl_1.FileDecoration.validate(data);
                    result[id] = [data.propagate, data.tooltip, data.badge, data.color];
                }
                catch (e) {
                    console.warn(`INVALID decoration from extension '${pluginInfo.name}': ${e}`);
                }
            }
            catch (err) {
                console.error(err);
            }
        }));
        return result;
    }
}
exports.DecorationsExtImpl = DecorationsExtImpl;
DecorationsExtImpl.handle = 0;
DecorationsExtImpl.maxEventSize = 250;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/dialogs.js":
/*!*******************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/dialogs.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DialogsExtImpl = void 0;
// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
class DialogsExtImpl {
    constructor(rpc) {
        this.proxy = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.DIALOGS_MAIN);
    }
    showOpenDialog(options) {
        const optionsMain = {
            title: options.title,
            openLabel: options.openLabel,
            defaultUri: options.defaultUri ? options.defaultUri.path : undefined,
            canSelectFiles: typeof options.canSelectFiles === 'boolean' ? options.canSelectFiles : true,
            canSelectFolders: typeof options.canSelectFolders === 'boolean' ? options.canSelectFolders : false,
            canSelectMany: options.canSelectMany,
            filters: options.filters
        };
        return new Promise((resolve, reject) => {
            this.proxy.$showOpenDialog(optionsMain).then(result => {
                if (result) {
                    const uris = [];
                    for (let i = 0; i < result.length; i++) {
                        const uri = types_impl_1.URI.parse('file://' + result[i]);
                        uris.push(uri);
                    }
                    resolve(uris);
                }
                else {
                    resolve(undefined);
                }
            }).catch(reason => {
                reject(reason);
            });
        });
    }
    showSaveDialog(options) {
        const optionsMain = {
            title: options.title,
            saveLabel: options.saveLabel,
            defaultUri: options.defaultUri ? options.defaultUri.path : undefined,
            filters: options.filters
        };
        return new Promise((resolve, reject) => {
            this.proxy.$showSaveDialog(optionsMain).then(result => {
                if (result) {
                    resolve(types_impl_1.URI.parse('file://' + result));
                }
                else {
                    resolve(undefined);
                }
            }).catch(reason => {
                reject(reason);
            });
        });
    }
    showUploadDialog(options) {
        const optionsMain = {
            defaultUri: options.defaultUri ? options.defaultUri.path : undefined
        };
        return new Promise((resolve, reject) => {
            this.proxy.$showUploadDialog(optionsMain).then(result => {
                if (result) {
                    resolve(result.map(uri => types_impl_1.URI.parse(uri)));
                }
                else {
                    resolve(undefined);
                }
            }).catch(reason => {
                reject(reason);
            });
        });
    }
}
exports.DialogsExtImpl = DialogsExtImpl;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/document-data.js":
/*!*************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/document-data.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.regExpLeadsToEndlessLoop = exports.DocumentDataExt = exports.getWordDefinitionFor = exports.setWordDefinitionFor = void 0;
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const assert_1 = __webpack_require__(/*! ../common/assert */ "../../packages/plugin-ext/lib/common/assert.js");
const prefix_sum_computer_1 = __webpack_require__(/*! ./prefix-sum-computer */ "../../packages/plugin-ext/lib/plugin/prefix-sum-computer.js");
const word_helper_1 = __webpack_require__(/*! ./word-helper */ "../../packages/plugin-ext/lib/plugin/word-helper.js");
const _modeId2WordDefinition = new Map();
function setWordDefinitionFor(modeId, wordDefinition) {
    _modeId2WordDefinition.set(modeId, wordDefinition);
}
exports.setWordDefinitionFor = setWordDefinitionFor;
function getWordDefinitionFor(modeId) {
    return _modeId2WordDefinition.get(modeId);
}
exports.getWordDefinitionFor = getWordDefinitionFor;
class DocumentDataExt {
    constructor(proxy, uri, lines, eol, languageId, versionId, isDirty) {
        this.proxy = proxy;
        this.uri = uri;
        this.lines = lines;
        this.eol = eol;
        this.languageId = languageId;
        this.versionId = versionId;
        this.disposed = false;
        this.textLines = new Array();
        this.dirty = isDirty;
    }
    dispose() {
        (0, assert_1.ok)(!this.disposed);
        this.dirty = false;
        this.disposed = true;
    }
    onEvents(e) {
        if (e.eol && e.eol !== this.eol) {
            this.eol = e.eol;
            this.lineStarts = undefined;
        }
        // Update my lines
        const changes = e.changes;
        // tslint:disable-next-line:one-variable-per-declaration
        for (let i = 0, len = changes.length; i < len; i++) {
            const change = changes[i];
            this.acceptDeleteRange(change.range);
            this.acceptInsertText(new types_impl_1.Position(change.range.startLineNumber, change.range.startColumn), change.text);
        }
        this.versionId = e.versionId;
    }
    acceptIsDirty(isDirty) {
        (0, assert_1.ok)(!this.disposed);
        this.dirty = isDirty;
    }
    acceptLanguageId(langId) {
        (0, assert_1.ok)(!this.disposed);
        this.languageId = langId;
    }
    get document() {
        if (!this._document) {
            const that = this;
            this._document = {
                get uri() { return that.uri; },
                get fileName() { return that.uri.fsPath; },
                get isUntitled() { return that.uri.scheme === 'untitled'; },
                get languageId() { return that.languageId; },
                get version() { return that.versionId; },
                get isClosed() { return that.disposed; },
                get isDirty() { return that.dirty; },
                save() { return that.save(); },
                getText(range) { return range ? that.getTextInRange(range) : that.getText(); },
                get eol() { return that.eol === '\n' ? types_impl_1.EndOfLine.LF : types_impl_1.EndOfLine.CRLF; },
                get lineCount() { return that.lines.length; },
                lineAt(lineOrPos) { return that.lineAt(lineOrPos); },
                offsetAt(pos) { return that.offsetAt(pos); },
                positionAt(offset) { return that.positionAt(offset); },
                validateRange(ran) { return that.validateRange(ran); },
                validatePosition(pos) { return that.validatePosition(pos); },
                getWordRangeAtPosition(pos, regexp) { return that.getWordRangeAtPosition(pos, regexp); }
            };
        }
        return Object.freeze(this._document);
    }
    acceptInsertText(position, insertText) {
        if (insertText.length === 0) {
            // Nothing to insert
            return;
        }
        const insertLines = insertText.split(/\r\n|\r|\n/);
        if (insertLines.length === 1) {
            // Inserting text on one line
            this.setLineText(position.line - 1, this.lines[position.line - 1].substring(0, position.character - 1)
                + insertLines[0]
                + this.lines[position.line - 1].substring(position.character - 1));
            return;
        }
        // Append overflowing text from first line to the end of text to insert
        insertLines[insertLines.length - 1] += this.lines[position.line - 1].substring(position.character - 1);
        // Delete overflowing text from first line and insert text on first line
        this.setLineText(position.line - 1, this.lines[position.line - 1].substring(0, position.character - 1)
            + insertLines[0]);
        // Insert new lines & store lengths
        const newLengths = new Uint32Array(insertLines.length - 1);
        for (let i = 1; i < insertLines.length; i++) {
            this.lines.splice(position.line + i - 1, 0, insertLines[i]);
            newLengths[i - 1] = insertLines[i].length + this.eol.length;
        }
        if (this.lineStarts) {
            // update prefix sum
            this.lineStarts.insertValues(position.line, newLengths);
        }
    }
    acceptDeleteRange(range) {
        if (range.startLineNumber === range.endLineNumber) {
            if (range.startColumn === range.endColumn) {
                // Nothing to delete
                return;
            }
            // Delete text on the affected line
            this.setLineText(range.startLineNumber - 1, this.lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)
                + this.lines[range.startLineNumber - 1].substring(range.endColumn - 1));
            return;
        }
        // Take remaining text on last line and append it to remaining text on first line
        this.setLineText(range.startLineNumber - 1, this.lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)
            + this.lines[range.endLineNumber - 1].substring(range.endColumn - 1));
        // Delete middle lines
        this.lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);
        if (this.lineStarts) {
            this.lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);
        }
    }
    setLineText(lineIndex, newValue) {
        this.lines[lineIndex] = newValue;
        if (this.lineStarts) {
            this.lineStarts.changeValue(lineIndex, this.lines[lineIndex].length + this.eol.length);
        }
    }
    save() {
        if (this.disposed) {
            return Promise.reject(new Error('Document is closed'));
        }
        return this.proxy.$trySaveDocument(this.uri);
    }
    getTextInRange(_range) {
        const range = this.validateRange(_range);
        if (range.isEmpty) {
            return '';
        }
        if (range.isSingleLine) {
            return this.lines[range.start.line].substring(range.start.character, range.end.character);
        }
        const lineEnding = this.eol;
        const startLineIndex = range.start.line;
        const endLineIndex = range.end.line;
        const resultLines = [];
        resultLines.push(this.lines[startLineIndex].substring(range.start.character));
        for (let i = startLineIndex + 1; i < endLineIndex; i++) {
            resultLines.push(this.lines[i]);
        }
        resultLines.push(this.lines[endLineIndex].substring(0, range.end.character));
        return resultLines.join(lineEnding);
    }
    validateRange(range) {
        if (!(range instanceof types_impl_1.Range)) {
            throw new Error('Invalid argument');
        }
        const start = this.validatePosition(range.start);
        const end = this.validatePosition(range.end);
        if (start === range.start && end === range.end) {
            return range;
        }
        return new types_impl_1.Range(start.line, start.character, end.line, end.character);
    }
    getText() {
        return this.lines.join(this.eol);
    }
    validatePosition(position) {
        if (!(position instanceof types_impl_1.Position)) {
            throw new Error('Invalid argument');
        }
        let { line, character } = position;
        let hasChanged = false;
        if (line < 0) {
            line = 0;
            character = 0;
            hasChanged = true;
        }
        else if (line >= this.lines.length) {
            line = this.lines.length - 1;
            character = this.lines[line].length;
            hasChanged = true;
        }
        else {
            const maxCharacter = this.lines[line].length;
            if (character < 0) {
                character = 0;
                hasChanged = true;
            }
            else if (character > maxCharacter) {
                character = maxCharacter;
                hasChanged = true;
            }
        }
        if (!hasChanged) {
            return position;
        }
        return new types_impl_1.Position(line, character);
    }
    lineAt(lineOrPosition) {
        let line = -1;
        if (lineOrPosition instanceof types_impl_1.Position) {
            line = lineOrPosition.line;
        }
        else if (typeof lineOrPosition === 'number') {
            line = lineOrPosition;
        }
        if (line < 0 || line >= this.lines.length) {
            throw new Error('Illegal value for `line`');
        }
        let result = this.textLines[line];
        if (!result || result.lineNumber !== line || result.text !== this.lines[line]) {
            const text = this.lines[line];
            const firstNonWhitespaceCharacterIndex = /^(\s*)/.exec(text)[1].length;
            const range = new types_impl_1.Range(line, 0, line, text.length);
            const rangeIncludingLineBreak = line < this.lines.length - 1
                ? new types_impl_1.Range(line, 0, line + 1, 0)
                : range;
            result = Object.freeze({
                lineNumber: line,
                range,
                rangeIncludingLineBreak,
                text,
                firstNonWhitespaceCharacterIndex,
                isEmptyOrWhitespace: firstNonWhitespaceCharacterIndex === text.length
            });
            this.textLines[line] = result;
        }
        return result;
    }
    offsetAt(position) {
        position = this.validatePosition(position);
        this.ensureLineStarts();
        return this.lineStarts.getAccumulatedValue(position.line - 1) + position.character;
    }
    ensureLineStarts() {
        if (!this.lineStarts) {
            const eolLength = this.eol.length;
            const linesLength = this.lines.length;
            const lineStartValues = new Uint32Array(linesLength);
            for (let i = 0; i < linesLength; i++) {
                lineStartValues[i] = this.lines[i].length + eolLength;
            }
            this.lineStarts = new prefix_sum_computer_1.PrefixSumComputer(lineStartValues);
        }
    }
    positionAt(offset) {
        offset = Math.floor(offset);
        offset = Math.max(0, offset);
        this.ensureLineStarts();
        const out = this.lineStarts.getIndexOf(offset);
        const lineLength = this.lines[out.index].length;
        return new types_impl_1.Position(out.index, Math.min(out.remainder, lineLength));
    }
    getWordRangeAtPosition(_position, regexp) {
        const position = this.validatePosition(_position);
        if (!regexp) {
            // use default when custom-regexp isn't provided
            regexp = getWordDefinitionFor(this.languageId);
        }
        else if (regExpLeadsToEndlessLoop(regexp)) {
            // use default when custom-regexp is bad
            console.warn(`[getWordRangeAtPosition]: ignoring custom regexp '${regexp.source}' because it matches the empty string.`);
            regexp = getWordDefinitionFor(this.languageId);
        }
        const wordAtText = (0, word_helper_1.getWordAtText)(position.character + 1, (0, word_helper_1.ensureValidWordDefinition)(regexp), this.lines[position.line], 0);
        if (wordAtText) {
            return new types_impl_1.Range(position.line, wordAtText.startColumn - 1, position.line, wordAtText.endColumn - 1);
        }
        return undefined;
    }
}
exports.DocumentDataExt = DocumentDataExt;
function regExpLeadsToEndlessLoop(regexp) {
    // Exit early if it's one of these special cases which are meant to match
    // against an empty string
    if (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$' || regexp.source === '^\\s*$') {
        return false;
    }
    // We check against an empty string. If the regular expression doesn't advance
    // (e.g. ends in an endless loop) it will match an empty string.
    const match = regexp.exec('');
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return (match && regexp.lastIndex === 0);
}
exports.regExpLeadsToEndlessLoop = regExpLeadsToEndlessLoop;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/documents.js":
/*!*********************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/documents.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentsExtImpl = void 0;
// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * based on https://github.com/Microsoft/vscode/blob/bf9a27ec01f2ef82fc45f69e0c946c7d74a57d3e/src/vs/workbench/api/node/extHostDocumentSaveParticipant.ts
 */
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../packages/core/lib/common/event.js");
const document_data_1 = __webpack_require__(/*! ./document-data */ "../../packages/plugin-ext/lib/plugin/document-data.js");
const Converter = __webpack_require__(/*! ./type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../packages/core/lib/common/disposable.js");
class DocumentsExtImpl {
    constructor(rpc, editorsAndDocuments) {
        this.editorsAndDocuments = editorsAndDocuments;
        this.toDispose = new disposable_1.DisposableCollection();
        this._onDidAddDocument = new event_1.Emitter();
        this._onDidRemoveDocument = new event_1.Emitter();
        this._onDidChangeDocument = new event_1.Emitter();
        this._onDidSaveTextDocument = new event_1.Emitter();
        this._onWillSaveTextDocument = new event_1.Emitter();
        this.onDidAddDocument = this._onDidAddDocument.event;
        this.onDidRemoveDocument = this._onDidRemoveDocument.event;
        this.onDidChangeDocument = this._onDidChangeDocument.event;
        this.onDidSaveTextDocument = this._onDidSaveTextDocument.event;
        this.onWillSaveTextDocument = this._onWillSaveTextDocument.event;
        this.loadingDocuments = new Map();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.DOCUMENTS_MAIN);
        this.toDispose.push(this.editorsAndDocuments.onDidAddDocuments(documents => {
            for (const document of documents) {
                this._onDidAddDocument.fire(document.document);
            }
        }));
        this.toDispose.push(this.editorsAndDocuments.onDidRemoveDocuments(documents => {
            for (const data of documents) {
                this._onDidRemoveDocument.fire(data.document);
            }
        }));
    }
    $acceptModelModeChanged(startUrl, oldModeId, newModeId) {
        const uri = types_impl_1.URI.revive(startUrl);
        const uriString = uri.toString();
        const data = this.editorsAndDocuments.getDocument(uriString);
        if (data) {
            this._onDidRemoveDocument.fire(data.document);
            data.acceptLanguageId(newModeId);
            this._onDidAddDocument.fire(data.document);
        }
    }
    $acceptModelSaved(strUrl) {
        const uri = types_impl_1.URI.revive(strUrl);
        const uriString = uri.toString();
        const data = this.editorsAndDocuments.getDocument(uriString);
        this.$acceptDirtyStateChanged(strUrl, false);
        if (data) {
            this._onDidSaveTextDocument.fire(data.document);
        }
    }
    async $acceptModelWillSave(strUrl, reason, saveTimeout) {
        const uri = types_impl_1.URI.revive(strUrl).toString();
        const operations = [];
        let didTimeout = false;
        // try to timeout early to squeeze edits at least from some save participants
        const didTimeoutHandle = setTimeout(() => didTimeout = true, saveTimeout - 250);
        try {
            await this._onWillSaveTextDocument.sequence(async (fireEvent) => {
                if (didTimeout) {
                    return false;
                }
                try {
                    const documentData = this.editorsAndDocuments.getDocument(uri);
                    if (documentData) {
                        const { document } = documentData;
                        await this.fireTextDocumentWillSaveEvent({
                            document, reason, fireEvent,
                            accept: operation => operations.push(operation)
                        });
                    }
                }
                catch (e) {
                    console.error(e);
                }
                return !didTimeout;
            });
        }
        finally {
            clearTimeout(didTimeoutHandle);
        }
        return operations;
    }
    /* eslint-disable @typescript-eslint/no-explicit-any */
    async fireTextDocumentWillSaveEvent({ document, reason, fireEvent, accept }) {
        const promises = [];
        fireEvent(Object.freeze({
            document, reason,
            waitUntil(p) {
                if (Object.isFrozen(promises)) {
                    throw new Error('waitUntil can not be called async');
                }
                promises.push(p);
            }
        }));
        Object.freeze(promises);
        await Promise.all(promises).then(allEdits => allEdits.forEach(edits => {
            if (Array.isArray(edits)) {
                edits.forEach(edit => {
                    if (types_impl_1.TextEdit.isTextEdit(edit)) {
                        accept(Converter.fromTextEdit(edit));
                    }
                });
            }
        }));
    }
    /* eslint-enable  @typescript-eslint/no-explicit-any */
    $acceptDirtyStateChanged(strUrl, isDirty) {
        const uri = types_impl_1.URI.revive(strUrl);
        const uriString = uri.toString();
        const data = this.editorsAndDocuments.getDocument(uriString);
        if (!data) {
            throw new Error('unknown document');
        }
        data.acceptIsDirty(isDirty);
        this._onDidChangeDocument.fire({
            document: data.document,
            contentChanges: [],
            reason: undefined,
        });
    }
    $acceptModelChanged(strUrl, e, isDirty) {
        const uri = types_impl_1.URI.revive(strUrl);
        const uriString = uri.toString();
        const data = this.editorsAndDocuments.getDocument(uriString);
        if (!data) {
            throw new Error('unknown document');
        }
        data.acceptIsDirty(isDirty);
        data.onEvents(e);
        this._onDidChangeDocument.fire({
            document: data.document,
            reason: e.reason,
            contentChanges: e.changes.map(change => ({
                range: Converter.toRange(change.range),
                rangeOffset: change.rangeOffset,
                rangeLength: change.rangeLength,
                text: change.text
            }))
        });
    }
    getAllDocumentData() {
        return this.editorsAndDocuments.allDocuments();
    }
    getDocumentData(resource) {
        if (resource) {
            return this.editorsAndDocuments.getDocument(resource.toString());
        }
        return undefined;
    }
    getDocument(resource) {
        const data = this.getDocumentData(resource);
        if (!(data === null || data === void 0 ? void 0 : data.document)) {
            throw new Error(`Unable to retrieve document from URI '${resource}'`);
        }
        return data.document;
    }
    /**
     * Retrieve document and open it in the editor if need.
     *
     * @param uri path to the resource
     * @param options if options exists, resource will be opened in editor, otherwise only document object is returned
     */
    async showDocument(uri, options) {
        // Determine whether the document is already loading
        const loadingDocument = this.loadingDocuments.get(uri.toString());
        if (loadingDocument) {
            // return the promise if document is already loading
            return loadingDocument;
        }
        try {
            // start opening document
            const document = this.loadDocument(uri, options);
            // add loader to the map
            this.loadingDocuments.set(uri.toString(), document);
            // wait the document being opened
            await document;
            // return opened document
            return document;
        }
        catch (error) {
            return Promise.reject(error);
        }
        finally {
            // remove loader from the map
            this.loadingDocuments.delete(uri.toString());
        }
    }
    async openDocument(uri) {
        const cached = this.editorsAndDocuments.getDocument(uri.toString());
        if (cached) {
            return cached;
        }
        await this.proxy.$tryOpenDocument(uri);
        return this.editorsAndDocuments.getDocument(uri.toString());
    }
    async loadDocument(uri, options) {
        let documentOptions;
        if (options) {
            let selection;
            if (options.selection) {
                const { start, end } = options.selection;
                selection = {
                    startLineNumber: start.line + 1,
                    startColumn: start.character + 1,
                    endLineNumber: end.line + 1,
                    endColumn: end.character + 1
                };
            }
            documentOptions = {
                selection,
                preserveFocus: options.preserveFocus,
                preview: options.preview,
                viewColumn: options.viewColumn
            };
        }
        await this.proxy.$tryShowDocument(uri, documentOptions);
        return this.editorsAndDocuments.getDocument(uri.toString());
    }
    async createDocumentData(options) {
        return this.proxy.$tryCreateDocument(options).then(data => types_impl_1.URI.revive(data));
    }
    setWordDefinitionFor(modeId, wordDefinition) {
        (0, document_data_1.setWordDefinitionFor)(modeId, wordDefinition);
    }
}
exports.DocumentsExtImpl = DocumentsExtImpl;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/editors-and-documents.js":
/*!*********************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/editors-and-documents.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EditorsAndDocumentsExtImpl = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const text_editor_1 = __webpack_require__(/*! ./text-editor */ "../../packages/plugin-ext/lib/plugin/text-editor.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../packages/core/lib/common/event.js");
const document_data_1 = __webpack_require__(/*! ./document-data */ "../../packages/plugin-ext/lib/plugin/document-data.js");
const assert_1 = __webpack_require__(/*! ../common/assert */ "../../packages/plugin-ext/lib/common/assert.js");
const Converter = __webpack_require__(/*! ./type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const disposable_util_1 = __webpack_require__(/*! ../common/disposable-util */ "../../packages/plugin-ext/lib/common/disposable-util.js");
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
class EditorsAndDocumentsExtImpl {
    constructor(rpc) {
        this.rpc = rpc;
        this.activeEditorId = null;
        this._onDidAddDocuments = new event_1.Emitter();
        this._onDidRemoveDocuments = new event_1.Emitter();
        this._onDidChangeVisibleTextEditors = new event_1.Emitter();
        this._onDidChangeActiveTextEditor = new event_1.Emitter();
        this.onDidAddDocuments = this._onDidAddDocuments.event;
        this.onDidRemoveDocuments = this._onDidRemoveDocuments.event;
        this.onDidChangeVisibleTextEditors = this._onDidChangeVisibleTextEditors.event;
        this.onDidChangeActiveTextEditor = this._onDidChangeActiveTextEditor.event;
        this.documents = new Map();
        this.editors = new Map();
    }
    async $acceptEditorsAndDocumentsDelta(delta) {
        const removedDocuments = new Array();
        const addedDocuments = new Array();
        const removedEditors = new Array();
        if (delta.removedDocuments) {
            for (const uriComponent of delta.removedDocuments) {
                const uri = types_impl_1.URI.revive(uriComponent);
                const id = uri.toString();
                const data = this.documents.get(id);
                this.documents.delete(id);
                if (data) {
                    removedDocuments.push(data);
                }
            }
        }
        if (delta.addedDocuments) {
            for (const data of delta.addedDocuments) {
                const resource = types_impl_1.URI.revive(data.uri);
                (0, assert_1.ok)(!this.documents.has(resource.toString()), `document '${resource}' already exists!`);
                const documentData = new document_data_1.DocumentDataExt(this.rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.DOCUMENTS_MAIN), resource, data.lines, data.EOL, data.modeId, data.versionId, data.isDirty);
                this.documents.set(resource.toString(), documentData);
                addedDocuments.push(documentData);
            }
        }
        if (delta.removedEditors) {
            for (const id of delta.removedEditors) {
                const editor = this.editors.get(id);
                this.editors.delete(id);
                if (editor) {
                    removedEditors.push(editor);
                }
            }
        }
        if (delta.addedEditors) {
            for (const data of delta.addedEditors) {
                const resource = types_impl_1.URI.revive(data.documentUri);
                (0, assert_1.ok)(this.documents.has(resource.toString()), `document '${resource}' doesn't exist`);
                (0, assert_1.ok)(!this.editors.has(data.id), `editor '${data.id}' already exists!`);
                const documentData = this.documents.get(resource.toString());
                const editor = new text_editor_1.TextEditorExt(this.rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.TEXT_EDITORS_MAIN), data.id, documentData, data.selections.map(Converter.toSelection), data.options, data.visibleRanges.map(Converter.toRange), Converter.toViewColumn(data.editorPosition));
                this.editors.set(data.id, editor);
            }
        }
        // TODO investigate how to get rid of it to align with VS Code extension host code
        if (this.activeEditorId && delta.removedEditors && delta.removedEditors.indexOf(this.activeEditorId) !== -1 && this.editors.size !== 0) {
            // to be compatible with VSCode, when active editor is closed onDidChangeActiveTextEditor
            // should be triggered with undefined before next editor, if any, become active.
            this.activeEditorId = null;
            this._onDidChangeActiveTextEditor.fire(undefined);
        }
        if (delta.newActiveEditor !== undefined) {
            (0, assert_1.ok)(delta.newActiveEditor === null || this.editors.has(delta.newActiveEditor), `active editor '${delta.newActiveEditor}' does not exist`);
            this.activeEditorId = delta.newActiveEditor;
        }
        (0, disposable_util_1.dispose)(removedDocuments);
        (0, disposable_util_1.dispose)(removedEditors);
        // now that the internal state is complete, fire events
        if (delta.removedDocuments) {
            this._onDidRemoveDocuments.fire(removedDocuments);
        }
        if (delta.addedDocuments) {
            this._onDidAddDocuments.fire(addedDocuments);
        }
        if (delta.removedEditors || delta.addedEditors) {
            this._onDidChangeVisibleTextEditors.fire(this.allEditors());
        }
        if (delta.newActiveEditor !== undefined) {
            this._onDidChangeActiveTextEditor.fire(this.activeEditor());
        }
    }
    allEditors() {
        const result = new Array();
        this.editors.forEach(editor => result.push(editor));
        return result;
    }
    activeEditor() {
        if (!this.activeEditorId) {
            return undefined;
        }
        else {
            return this.editors.get(this.activeEditorId);
        }
    }
    allDocuments() {
        const result = new Array();
        this.documents.forEach(data => result.push(data));
        return result;
    }
    getDocument(uri) {
        return this.documents.get(uri);
    }
    getEditor(id) {
        return this.editors.get(id);
    }
}
exports.EditorsAndDocumentsExtImpl = EditorsAndDocumentsExtImpl;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/env.js":
/*!***************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/env.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnvExtImpl = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const uuid_1 = __webpack_require__(/*! uuid */ "../../node_modules/uuid/dist/esm-node/index.js");
class EnvExtImpl {
    constructor(rpc) {
        this.proxy = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.ENV_MAIN);
        this.envSessionId = (0, uuid_1.v4)();
        this.envMachineId = (0, uuid_1.v4)();
        this._remoteName = undefined;
    }
    getEnvVariable(envVarName) {
        return this.proxy.$getEnvVariable(envVarName).then(x => {
            if (x === null) {
                return undefined;
            }
            return x;
        });
    }
    getQueryParameter(queryParamName) {
        return this.queryParameters[queryParamName];
    }
    getQueryParameters() {
        return this.queryParameters;
    }
    setQueryParameters(queryParams) {
        this.queryParameters = queryParams;
    }
    setApplicationName(applicationName) {
        this.applicationName = applicationName;
    }
    setLanguage(lang) {
        this.lang = lang;
    }
    setShell(shell) {
        this.defaultShell = shell;
    }
    setUIKind(uiKind) {
        this.ui = uiKind;
    }
    setAppHost(appHost) {
        this.host = appHost;
    }
    getClientOperatingSystem() {
        return this.proxy.$getClientOperatingSystem();
    }
    get appName() {
        return this.applicationName;
    }
    get appHost() {
        return this.host;
    }
    get remoteName() {
        return this._remoteName;
    }
    get language() {
        return this.lang;
    }
    get machineId() {
        return this.envMachineId;
    }
    get sessionId() {
        return this.envSessionId;
    }
    get uriScheme() {
        return 'theia';
    }
    get shell() {
        return this.defaultShell;
    }
    get uiKind() {
        return this.ui;
    }
}
exports.EnvExtImpl = EnvExtImpl;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/file-system-event-service-ext-impl.js":
/*!**********************************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/file-system-event-service-ext-impl.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * **IMPORTANT** this code is running in the plugin host process and should be closed as possible to VS Code counterpart:
 * https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/workbench/api/common/extHostFileSystemEventService.ts
 * One should be able to diff them to see differences.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExtHostFileSystemEventService = void 0;
/* eslint-disable max-len */
/* eslint-disable @typescript-eslint/no-shadow */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/tslint/config */
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../packages/core/lib/common/event.js");
const glob_1 = __webpack_require__(/*! @theia/core/lib/common/glob */ "../../packages/core/lib/common/glob.js");
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const typeConverter = __webpack_require__(/*! ./type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const arrays_1 = __webpack_require__(/*! ../common/arrays */ "../../packages/plugin-ext/lib/common/arrays.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
class FileSystemWatcher {
    constructor(dispatcher, globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
        this._onDidCreate = new event_1.Emitter();
        this._onDidChange = new event_1.Emitter();
        this._onDidDelete = new event_1.Emitter();
        this._config = 0;
        if (ignoreCreateEvents) {
            this._config += 0b001;
        }
        if (ignoreChangeEvents) {
            this._config += 0b010;
        }
        if (ignoreDeleteEvents) {
            this._config += 0b100;
        }
        const parsedPattern = (0, glob_1.parse)(globPattern);
        const subscription = dispatcher(events => {
            if (!ignoreCreateEvents) {
                for (const created of events.created) {
                    const uri = types_impl_1.URI.revive(created);
                    if (parsedPattern(uri.fsPath)) {
                        this._onDidCreate.fire(uri);
                    }
                }
            }
            if (!ignoreChangeEvents) {
                for (const changed of events.changed) {
                    const uri = types_impl_1.URI.revive(changed);
                    if (parsedPattern(uri.fsPath)) {
                        this._onDidChange.fire(uri);
                    }
                }
            }
            if (!ignoreDeleteEvents) {
                for (const deleted of events.deleted) {
                    const uri = types_impl_1.URI.revive(deleted);
                    if (parsedPattern(uri.fsPath)) {
                        this._onDidDelete.fire(uri);
                    }
                }
            }
        });
        this._disposable = types_impl_1.Disposable.from(this._onDidCreate, this._onDidChange, this._onDidDelete, subscription);
    }
    get ignoreCreateEvents() {
        return Boolean(this._config & 0b001);
    }
    get ignoreChangeEvents() {
        return Boolean(this._config & 0b010);
    }
    get ignoreDeleteEvents() {
        return Boolean(this._config & 0b100);
    }
    dispose() {
        this._disposable.dispose();
    }
    get onDidCreate() {
        return this._onDidCreate.event;
    }
    get onDidChange() {
        return this._onDidChange.event;
    }
    get onDidDelete() {
        return this._onDidDelete.event;
    }
}
class ExtHostFileSystemEventService {
    constructor(rpc, _extHostDocumentsAndEditors, _mainThreadTextEditors = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.TEXT_EDITORS_MAIN)) {
        this._extHostDocumentsAndEditors = _extHostDocumentsAndEditors;
        this._mainThreadTextEditors = _mainThreadTextEditors;
        this._onFileSystemEvent = new event_1.Emitter();
        this._onDidRenameFile = new event_1.Emitter();
        this._onDidCreateFile = new event_1.Emitter();
        this._onDidDeleteFile = new event_1.Emitter();
        this._onWillRenameFile = new event_1.AsyncEmitter();
        this._onWillCreateFile = new event_1.AsyncEmitter();
        this._onWillDeleteFile = new event_1.AsyncEmitter();
        this.onDidRenameFile = this._onDidRenameFile.event;
        this.onDidCreateFile = this._onDidCreateFile.event;
        this.onDidDeleteFile = this._onDidDeleteFile.event;
        //
    }
    // --- file events
    createFileSystemWatcher(globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
        return new FileSystemWatcher(this._onFileSystemEvent.event, globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents);
    }
    $onFileEvent(events) {
        this._onFileSystemEvent.fire(events);
    }
    // --- file operations
    $onDidRunFileOperation(operation, target, source) {
        switch (operation) {
            case 2 /* MOVE */:
                this._onDidRenameFile.fire(Object.freeze({ files: [{ oldUri: types_impl_1.URI.revive(source), newUri: types_impl_1.URI.revive(target) }] }));
                break;
            case 1 /* DELETE */:
                this._onDidDeleteFile.fire(Object.freeze({ files: [types_impl_1.URI.revive(target)] }));
                break;
            case 0 /* CREATE */:
                this._onDidCreateFile.fire(Object.freeze({ files: [types_impl_1.URI.revive(target)] }));
                break;
            default:
            // ignore, dont send
        }
    }
    getOnWillRenameFileEvent(extension) {
        return this._createWillExecuteEvent(extension, this._onWillRenameFile);
    }
    getOnWillCreateFileEvent(extension) {
        return this._createWillExecuteEvent(extension, this._onWillCreateFile);
    }
    getOnWillDeleteFileEvent(extension) {
        return this._createWillExecuteEvent(extension, this._onWillDeleteFile);
    }
    _createWillExecuteEvent(extension, emitter) {
        return (listener, thisArg, disposables) => {
            const wrappedListener = function wrapped(e) { listener.call(thisArg, e); };
            wrappedListener.extension = extension;
            return emitter.event(wrappedListener, undefined, disposables);
        };
    }
    async $onWillRunFileOperation(operation, target, source, timeout, token) {
        switch (operation) {
            case 2 /* MOVE */:
                await this._fireWillEvent(this._onWillRenameFile, { files: [{ oldUri: types_impl_1.URI.revive(source), newUri: types_impl_1.URI.revive(target) }] }, timeout, token);
                break;
            case 1 /* DELETE */:
                await this._fireWillEvent(this._onWillDeleteFile, { files: [types_impl_1.URI.revive(target)] }, timeout, token);
                break;
            case 0 /* CREATE */:
                await this._fireWillEvent(this._onWillCreateFile, { files: [types_impl_1.URI.revive(target)] }, timeout, token);
                break;
            default:
            // ignore, dont send
        }
    }
    async _fireWillEvent(emitter, data, timeout, token) {
        const edits = [];
        await emitter.fire(data, token, async (thenable, listener) => {
            var _a;
            // ignore all results except for WorkspaceEdits. Those are stored in an array.
            const now = Date.now();
            const result = await Promise.resolve(thenable);
            if (result instanceof types_impl_1.WorkspaceEdit) {
                edits.push(result);
            }
            if (Date.now() - now > timeout) {
                console.warn('SLOW file-participant', (_a = listener.extension) === null || _a === void 0 ? void 0 : _a.model.id);
            }
        });
        if (token.isCancellationRequested) {
            return;
        }
        if (edits.length > 0) {
            // flatten all WorkspaceEdits collected via waitUntil-call
            // and apply them in one go.
            const allEdits = new Array();
            for (const edit of edits) {
                const { edits } = typeConverter.fromWorkspaceEdit(edit, this._extHostDocumentsAndEditors);
                allEdits.push(edits);
            }
            return this._mainThreadTextEditors.$tryApplyWorkspaceEdit({ edits: (0, arrays_1.flatten)(allEdits) });
        }
    }
}
exports.ExtHostFileSystemEventService = ExtHostFileSystemEventService;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/file-system-ext-impl.js":
/*!********************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/file-system-ext-impl.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * **IMPORTANT** this code is running in the plugin host process and should be closed as possible to VS Code counterpart:
 * https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/workbench/api/common/extHostFileSystem.ts
 * One should be able to diff them to see differences.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileSystemExtImpl = exports.FsLinkProvider = void 0;
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const files = __webpack_require__(/*! @theia/filesystem/lib/common/files */ "../../packages/filesystem/lib/common/files.js");
const typeConverter = __webpack_require__(/*! ./type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const uri_components_1 = __webpack_require__(/*! ../common/uri-components */ "../../packages/plugin-ext/lib/common/uri-components.js");
const link_computer_1 = __webpack_require__(/*! ../common/link-computer */ "../../packages/plugin-ext/lib/common/link-computer.js");
const strings_1 = __webpack_require__(/*! @theia/core/lib/common/strings */ "../../packages/core/lib/common/strings.js");
const buffer_1 = __webpack_require__(/*! @theia/core/lib/common/buffer */ "../../packages/core/lib/common/buffer.js");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "../../packages/core/shared/vscode-languageserver-protocol/index.js");
class FsLinkProvider {
    constructor() {
        this._schemes = [];
    }
    add(scheme) {
        this._stateMachine = undefined;
        this._schemes.push(scheme);
    }
    delete(scheme) {
        const idx = this._schemes.indexOf(scheme);
        if (idx >= 0) {
            this._schemes.splice(idx, 1);
            this._stateMachine = undefined;
        }
    }
    _initStateMachine() {
        if (!this._stateMachine) {
            // sort and compute common prefix with previous scheme
            // then build state transitions based on the data
            const schemes = this._schemes.sort();
            const edges = [];
            let prevScheme;
            let prevState;
            let lastState = 14 /* LastKnownState */;
            let nextState = 14 /* LastKnownState */;
            for (const scheme of schemes) {
                // skip the common prefix of the prev scheme
                // and continue with its last state
                let pos = !prevScheme ? 0 : (0, strings_1.commonPrefixLength)(prevScheme, scheme);
                if (pos === 0) {
                    prevState = 1 /* Start */;
                }
                else {
                    prevState = nextState;
                }
                for (; pos < scheme.length; pos++) {
                    // keep creating new (next) states until the
                    // end (and the BeforeColon-state) is reached
                    if (pos + 1 === scheme.length) {
                        // Save the last state here, because we need to continue for the next scheme
                        lastState = nextState;
                        nextState = 9 /* BeforeColon */;
                    }
                    else {
                        nextState += 1;
                    }
                    edges.push([prevState, scheme.toUpperCase().charCodeAt(pos), nextState]);
                    edges.push([prevState, scheme.toLowerCase().charCodeAt(pos), nextState]);
                    prevState = nextState;
                }
                prevScheme = scheme;
                // Restore the last state
                nextState = lastState;
            }
            // all link must match this pattern `<scheme>:/<more>`
            edges.push([9 /* BeforeColon */, 58 /* Colon */, 10 /* AfterColon */]);
            edges.push([10 /* AfterColon */, 47 /* Slash */, 12 /* End */]);
            this._stateMachine = new link_computer_1.StateMachine(edges);
        }
    }
    provideDocumentLinks(document) {
        this._initStateMachine();
        const result = [];
        const links = link_computer_1.LinkComputer.computeLinks({
            getLineContent(lineNumber) {
                return document.lineAt(lineNumber - 1).text;
            },
            getLineCount() {
                return document.lineCount;
            }
        }, this._stateMachine);
        for (const link of links) {
            const docLink = typeConverter.DocumentLink.to(link);
            if (docLink.target) {
                result.push(docLink);
            }
        }
        return result;
    }
}
exports.FsLinkProvider = FsLinkProvider;
class ConsumerFileSystem {
    constructor(_proxy, _capabilities) {
        this._proxy = _proxy;
        this._capabilities = _capabilities;
    }
    stat(uri) {
        return this._proxy.$stat(uri).catch(ConsumerFileSystem._handleError);
    }
    readDirectory(uri) {
        return this._proxy.$readdir(uri).catch(ConsumerFileSystem._handleError);
    }
    createDirectory(uri) {
        return this._proxy.$mkdir(uri).catch(ConsumerFileSystem._handleError);
    }
    readFile(uri) {
        return this._proxy.$readFile(uri).then(buff => buff.buffer).catch(ConsumerFileSystem._handleError);
    }
    writeFile(uri, content) {
        return this._proxy.$writeFile(uri, buffer_1.BinaryBuffer.wrap(content)).catch(ConsumerFileSystem._handleError);
    }
    delete(uri, options) {
        return this._proxy.$delete(uri, { ...{ recursive: false, useTrash: false }, ...options }).catch(ConsumerFileSystem._handleError);
    }
    rename(oldUri, newUri, options) {
        return this._proxy.$rename(oldUri, newUri, { ...{ overwrite: false }, ...options }).catch(ConsumerFileSystem._handleError);
    }
    copy(source, destination, options) {
        return this._proxy.$copy(source, destination, { ...{ overwrite: false }, ...options }).catch(ConsumerFileSystem._handleError);
    }
    isWritableFileSystem(scheme) {
        const capabilities = this._capabilities.get(scheme);
        if (typeof capabilities === 'number') {
            return (capabilities & 2048 /* Readonly */) === 0;
        }
        return undefined;
    }
    static _handleError(err) {
        // generic error
        if (!(err instanceof Error)) {
            throw new types_impl_1.FileSystemError(String(err));
        }
        // no provider (unknown scheme) error
        if (err.name === 'ENOPRO') {
            throw types_impl_1.FileSystemError.Unavailable(err.message);
        }
        // file system error
        switch (err.name) {
            case files.FileSystemProviderErrorCode.FileExists: throw types_impl_1.FileSystemError.FileExists(err.message);
            case files.FileSystemProviderErrorCode.FileNotFound: throw types_impl_1.FileSystemError.FileNotFound(err.message);
            case files.FileSystemProviderErrorCode.FileNotADirectory: throw types_impl_1.FileSystemError.FileNotADirectory(err.message);
            case files.FileSystemProviderErrorCode.FileIsADirectory: throw types_impl_1.FileSystemError.FileIsADirectory(err.message);
            case files.FileSystemProviderErrorCode.NoPermissions: throw types_impl_1.FileSystemError.NoPermissions(err.message);
            case files.FileSystemProviderErrorCode.Unavailable: throw types_impl_1.FileSystemError.Unavailable(err.message);
            default: throw new types_impl_1.FileSystemError(err.message, err.name);
        }
    }
}
class FileSystemExtImpl {
    constructor(rpc) {
        this._linkProvider = new FsLinkProvider();
        this._fsProvider = new Map();
        this._capabilities = new Map();
        this._usedSchemes = new Set();
        this._watches = new Map();
        this.onWillRegisterFileSystemProviderEmitter = new vscode_languageserver_protocol_1.Emitter();
        this.onWillRegisterFileSystemProvider = this.onWillRegisterFileSystemProviderEmitter.event;
        this._handlePool = 0;
        this._proxy = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.FILE_SYSTEM_MAIN);
        this.fileSystem = new ConsumerFileSystem(this._proxy, this._capabilities);
        // register used schemes
        Object.keys(uri_components_1.Schemes).forEach(scheme => this._usedSchemes.add(scheme));
    }
    dispose() {
        this.onWillRegisterFileSystemProviderEmitter.dispose();
    }
    registerFileSystemProvider(scheme, provider, options = {}) {
        if (this._usedSchemes.has(scheme)) {
            throw new Error(`a provider for the scheme '${scheme}' is already registered`);
        }
        this.onWillRegisterFileSystemProviderEmitter.fire(this._linkProvider);
        const handle = this._handlePool++;
        this._linkProvider.add(scheme);
        this._usedSchemes.add(scheme);
        this._fsProvider.set(handle, provider);
        let capabilities = 2 /* FileReadWrite */;
        if (options.isCaseSensitive) {
            capabilities += 1024 /* PathCaseSensitive */;
        }
        if (options.isReadonly) {
            capabilities += 2048 /* Readonly */;
        }
        if (typeof provider.copy === 'function') {
            capabilities += 8 /* FileFolderCopy */;
        }
        if (typeof provider.open === 'function' && typeof provider.close === 'function'
            && typeof provider.read === 'function' && typeof provider.write === 'function') {
            capabilities += 4 /* FileOpenReadWriteClose */;
        }
        this._proxy.$registerFileSystemProvider(handle, scheme, capabilities);
        const subscription = provider.onDidChangeFile(event => {
            const mapped = [];
            for (const e of event) {
                const { uri: resource, type } = e;
                if (resource.scheme !== scheme) {
                    // dropping events for wrong scheme
                    continue;
                }
                let newType;
                switch (type) {
                    case types_impl_1.FileChangeType.Changed:
                        newType = 0 /* UPDATED */;
                        break;
                    case types_impl_1.FileChangeType.Created:
                        newType = 1 /* ADDED */;
                        break;
                    case types_impl_1.FileChangeType.Deleted:
                        newType = 2 /* DELETED */;
                        break;
                    default:
                        throw new Error('Unknown FileChangeType');
                }
                mapped.push({ resource, type: newType });
            }
            this._proxy.$onFileSystemChange(handle, mapped);
        });
        return {
            dispose: () => {
                subscription.dispose();
                this._linkProvider.delete(scheme);
                this._usedSchemes.delete(scheme);
                this._fsProvider.delete(handle);
                this._proxy.$unregisterProvider(handle);
            }
        };
    }
    static _asIStat(stat) {
        const { type, ctime, mtime, size, permissions } = stat;
        return { type, ctime, mtime, size, permissions };
    }
    $acceptProviderInfos(scheme, capabilities) {
        if (typeof capabilities === 'number') {
            this._capabilities.set(scheme, capabilities);
        }
        else {
            this._capabilities.delete(scheme);
        }
    }
    $stat(handle, resource) {
        return Promise.resolve(this._getFsProvider(handle).stat(types_impl_1.URI.revive(resource))).then(FileSystemExtImpl._asIStat);
    }
    $readdir(handle, resource) {
        return Promise.resolve(this._getFsProvider(handle).readDirectory(types_impl_1.URI.revive(resource)));
    }
    $readFile(handle, resource) {
        return Promise.resolve(this._getFsProvider(handle).readFile(types_impl_1.URI.revive(resource))).then(data => buffer_1.BinaryBuffer.wrap(data));
    }
    $writeFile(handle, resource, content, opts) {
        return Promise.resolve(this._getFsProvider(handle).writeFile(types_impl_1.URI.revive(resource), content.buffer, opts));
    }
    $delete(handle, resource, opts) {
        return Promise.resolve(this._getFsProvider(handle).delete(types_impl_1.URI.revive(resource), opts));
    }
    $rename(handle, oldUri, newUri, opts) {
        return Promise.resolve(this._getFsProvider(handle).rename(types_impl_1.URI.revive(oldUri), types_impl_1.URI.revive(newUri), opts));
    }
    $copy(handle, oldUri, newUri, opts) {
        const provider = this._getFsProvider(handle);
        if (!provider.copy) {
            throw new Error('FileSystemProvider does not implement "copy"');
        }
        return Promise.resolve(provider.copy(types_impl_1.URI.revive(oldUri), types_impl_1.URI.revive(newUri), opts));
    }
    $mkdir(handle, resource) {
        return Promise.resolve(this._getFsProvider(handle).createDirectory(types_impl_1.URI.revive(resource)));
    }
    $watch(handle, session, resource, opts) {
        const subscription = this._getFsProvider(handle).watch(types_impl_1.URI.revive(resource), opts);
        this._watches.set(session, subscription);
    }
    $unwatch(_handle, session) {
        const subscription = this._watches.get(session);
        if (subscription) {
            subscription.dispose();
            this._watches.delete(session);
        }
    }
    $open(handle, resource, opts) {
        const provider = this._getFsProvider(handle);
        if (!provider.open) {
            throw new Error('FileSystemProvider does not implement "open"');
        }
        return Promise.resolve(provider.open(types_impl_1.URI.revive(resource), opts));
    }
    $close(handle, fd) {
        const provider = this._getFsProvider(handle);
        if (!provider.close) {
            throw new Error('FileSystemProvider does not implement "close"');
        }
        return Promise.resolve(provider.close(fd));
    }
    $read(handle, fd, pos, length) {
        const provider = this._getFsProvider(handle);
        if (!provider.read) {
            throw new Error('FileSystemProvider does not implement "read"');
        }
        const data = buffer_1.BinaryBuffer.alloc(length);
        return Promise.resolve(provider.read(fd, pos, data.buffer, 0, length)).then(read => {
            return data.slice(0, read); // don't send zeros
        });
    }
    $write(handle, fd, pos, data) {
        const provider = this._getFsProvider(handle);
        if (!provider.write) {
            throw new Error('FileSystemProvider does not implement "write"');
        }
        return Promise.resolve(provider.write(fd, pos, data.buffer, 0, data.byteLength));
    }
    _getFsProvider(handle) {
        const provider = this._fsProvider.get(handle);
        if (!provider) {
            const err = new Error();
            err.name = 'ENOPRO';
            err.message = `no provider`;
            throw err;
        }
        return provider;
    }
}
exports.FileSystemExtImpl = FileSystemExtImpl;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/known-commands.js":
/*!**************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/known-commands.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KnownCommands = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "../../packages/core/shared/vscode-languageserver-protocol/index.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../../packages/core/lib/common/uri.js");
const objects_1 = __webpack_require__(/*! ../common/objects */ "../../packages/plugin-ext/lib/common/objects.js");
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const type_converters_1 = __webpack_require__(/*! ./type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
// Here is a mapping of VSCode commands to monaco commands with their conversions
var KnownCommands;
(function (KnownCommands) {
    /**
     * Commands that you want to apply custom conversions to rather than pass through the automatic args converter.
     * Would be useful in the case where theia provides some command and you need to provide custom conversions
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const mappings = {};
    mappings['editor.action.showReferences'] = ['textEditor.commands.showReferences', createConversionFunction((uri) => uri.toString(), fromPositionToP, toArrayConversion(fromLocationToL)),
        createConversionFunction()];
    /**
     * Mapping of all editor.action commands to their conversion function.
     * executeCommand<T> inside of the plugin command registry will automatically convert
     * incoming arguments from vscode api types to monaco types
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const CONVERT_VSCODE_TO_MONACO = (args) => {
        if (!args) {
            return args;
        }
        const argStack = [];
        args.forEach(_ => {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            argStack.push((arg) => vscodeToMonacoArgsConverter(arg));
        });
        if (args) {
            return createConversionFunction(...argStack)(args);
        }
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const identity = (args) => args;
    mappings['editor.action.select.all'] = ['editor.action.select.all', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.toggleHighContrast'] = ['editor.action.toggleHighContrast', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.moveCarretLeftAction'] = ['editor.action.moveCarretLeftAction', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.moveCarretRightAction'] = ['editor.action.moveCarretRightAction', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.transposeLetters'] = ['editor.action.transposeLetters', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.clipboardCopyWithSyntaxHighlightingAction'] = ['editor.action.clipboardCopyWithSyntaxHighlightingAction', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.commentLine'] = ['editor.action.commentLine', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.addCommentLine'] = ['editor.action.addCommentLine', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.removeCommentLine'] = ['editor.action.removeCommentLine', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.blockComment'] = ['editor.action.blockComment', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.showContextMenu'] = ['editor.action.showContextMenu', CONVERT_VSCODE_TO_MONACO];
    mappings['cursorUndo'] = ['cursorUndo', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.unfold'] = ['editor.unfold', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.unfoldRecursively'] = ['editor.unfoldRecursively', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.fold'] = ['editor.fold', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.foldRecursively'] = ['editor.foldRecursively', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.foldAll'] = ['editor.foldAll', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.unfoldAll'] = ['editor.unfoldAll', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.foldAllBlockComments'] = ['editor.foldAllBlockComments', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.foldAllMarkerRegions'] = ['editor.foldAllMarkerRegions', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.unfoldAllMarkerRegions'] = ['editor.unfoldAllMarkerRegions', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.foldLevel1'] = ['editor.foldLevel1', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.foldLevel2'] = ['editor.foldLevel2', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.foldLevel3'] = ['editor.foldLevel3', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.foldLevel4'] = ['editor.foldLevel4', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.foldLevel5'] = ['editor.foldLevel5', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.foldLevel6'] = ['editor.foldLevel6', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.foldLevel7'] = ['editor.foldLevel7', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.fontZoomIn'] = ['editor.action.fontZoomIn', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.fontZoomOut'] = ['editor.action.fontZoomOut', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.fontZoomReset'] = ['editor.action.fontZoomReset', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.formatDocument'] = ['editor.action.formatDocument', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.formatSelection'] = ['editor.action.formatSelection', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.copyLinesUpAction'] = ['editor.action.copyLinesUpAction', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.copyLinesDownAction'] = ['editor.action.copyLinesDownAction', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.moveLinesUpAction'] = ['editor.action.moveLinesUpAction', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.moveLinesDownAction'] = ['editor.action.moveLinesDownAction', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.sortLinesAscending'] = ['editor.action.sortLinesAscending', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.sortLinesDescending'] = ['editor.action.sortLinesDescending', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.trimTrailingWhitespace'] = ['editor.action.trimTrailingWhitespace', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.deleteLines'] = ['editor.action.deleteLines', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.indentLines'] = ['editor.action.indentLines', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.outdentLines'] = ['editor.action.outdentLines', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.insertLineBefore'] = ['editor.action.insertLineBefore', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.insertLineAfter'] = ['editor.action.insertLineAfter', CONVERT_VSCODE_TO_MONACO];
    mappings['deleteAllLeft'] = ['deleteAllLeft', CONVERT_VSCODE_TO_MONACO];
    mappings['deleteAllRight'] = ['deleteAllRight', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.joinLines'] = ['editor.action.joinLines', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.transpose'] = ['editor.action.transpose', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.transformToUppercase'] = ['editor.action.transformToUppercase', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.transformToLowercase'] = ['editor.action.transformToLowercase', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.transformToTitlecase'] = ['editor.action.transformToTitlecase', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.smartSelect.expand'] = ['editor.action.smartSelect.expand', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.smartSelect.shrink'] = ['editor.action.smartSelect.shrink', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.forceRetokenize'] = ['editor.action.forceRetokenize', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.toggleTabFocusMode'] = ['editor.action.toggleTabFocusMode', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.gotoLine'] = ['editor.action.gotoLine', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.quickOutline'] = ['editor.action.quickOutline', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.inPlaceReplace.up'] = ['editor.action.inPlaceReplace.up', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.inPlaceReplace.down'] = ['editor.action.inPlaceReplace.down', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.diffReview.next'] = ['editor.action.diffReview.next', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.diffReview.prev'] = ['editor.action.diffReview.prev', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.selectToBracket'] = ['editor.action.selectToBracket', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.jumpToBracket'] = ['editor.action.jumpToBracket', CONVERT_VSCODE_TO_MONACO];
    mappings['actions.findWithSelection'] = ['actions.findWithSelection', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.nextMatchFindAction'] = ['editor.action.nextMatchFindAction', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.previousMatchFindAction'] = ['editor.action.previousMatchFindAction', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.nextSelectionMatchFindAction'] = ['editor.action.nextSelectionMatchFindAction', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.previousSelectionMatchFindAction'] = ['editor.action.previousSelectionMatchFindAction', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.openLink'] = ['editor.action.openLink', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.quickFix'] = ['editor.action.quickFix', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.refactor'] = ['editor.action.refactor', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.sourceAction'] = ['editor.action.sourceAction', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.organizeImports'] = ['editor.action.organizeImports', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.autoFix'] = ['editor.action.autoFix', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.fixAll'] = ['editor.action.fixAll', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.rename'] = ['editor.action.rename', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.insertCursorAbove'] = ['editor.action.insertCursorAbove', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.insertCursorBelow'] = ['editor.action.insertCursorBelow', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.insertCursorAtEndOfEachLineSelected'] = ['editor.action.insertCursorAtEndOfEachLineSelected', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.addSelectionToNextFindMatch'] = ['editor.action.addSelectionToNextFindMatch', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.addSelectionToPreviousFindMatch'] = ['editor.action.addSelectionToPreviousFindMatch', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.moveSelectionToNextFindMatch'] = ['editor.action.moveSelectionToNextFindMatch', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.moveSelectionToPreviousFindMatch'] = ['editor.action.moveSelectionToPreviousFindMatch', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.selectHighlights'] = ['editor.action.selectHighlights', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.changeAll'] = ['editor.action.changeAll', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.addCursorsToBottom'] = ['editor.action.addCursorsToBottom', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.addCursorsToTop'] = ['editor.action.addCursorsToTop', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.triggerParameterHints'] = ['editor.action.triggerParameterHints', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.wordHighlight.next'] = ['editor.action.wordHighlight.next', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.wordHighlight.prev'] = ['editor.action.wordHighlight.prev', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.wordHighlight.trigger'] = ['editor.action.wordHighlight.trigger', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.showAccessibilityHelp'] = ['editor.action.showAccessibilityHelp', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.inspectTokens'] = ['editor.action.inspectTokens', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.marker.next'] = ['editor.action.marker.next', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.marker.prev'] = ['editor.action.marker.prev', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.marker.nextInFiles'] = ['editor.action.marker.nextInFiles', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.marker.prevInFiles'] = ['editor.action.marker.prevInFiles', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.showHover'] = ['editor.action.showHover', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.revealDefinition'] = ['editor.action.revealDefinition', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.revealDefinitionAside'] = ['editor.action.revealDefinitionAside', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.peekDefinition'] = ['editor.action.peekDefinition', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.revealDeclaration'] = ['editor.action.revealDeclaration', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.peekDeclaration'] = ['editor.action.peekDeclaration', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.goToImplementation'] = ['editor.action.goToImplementation', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.peekImplementation'] = ['editor.action.peekImplementation', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.goToTypeDefinition'] = ['editor.action.goToTypeDefinition', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.peekTypeDefinition'] = ['editor.action.peekTypeDefinition', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.referenceSearch.trigger'] = ['editor.action.referenceSearch.trigger', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.triggerSuggest'] = ['editor.action.triggerSuggest', CONVERT_VSCODE_TO_MONACO];
    mappings['closeReferenceSearchEditor'] = ['closeReferenceSearchEditor', CONVERT_VSCODE_TO_MONACO];
    mappings['cancelSelection'] = ['cancelSelection', CONVERT_VSCODE_TO_MONACO];
    mappings['cursorBottom'] = ['cursorBottom', CONVERT_VSCODE_TO_MONACO];
    mappings['cursorBottomSelect'] = ['cursorBottomSelect', CONVERT_VSCODE_TO_MONACO];
    mappings['cursorDown'] = ['cursorDown', CONVERT_VSCODE_TO_MONACO];
    mappings['cursorDownSelect'] = ['cursorDownSelect', CONVERT_VSCODE_TO_MONACO];
    mappings['cursorEnd'] = ['cursorEnd', CONVERT_VSCODE_TO_MONACO];
    mappings['cursorEndSelect'] = ['cursorEndSelect', CONVERT_VSCODE_TO_MONACO];
    mappings['cursorHome'] = ['cursorHome', CONVERT_VSCODE_TO_MONACO];
    mappings['cursorHomeSelect'] = ['cursorHomeSelect', CONVERT_VSCODE_TO_MONACO];
    mappings['cursorLeft'] = ['cursorLeft', CONVERT_VSCODE_TO_MONACO];
    mappings['cursorLeftSelect'] = ['cursorLeftSelect', CONVERT_VSCODE_TO_MONACO];
    mappings['cursorPageDown'] = ['cursorPageDown', CONVERT_VSCODE_TO_MONACO];
    mappings['cursorPageDownSelect'] = ['cursorPageDownSelect', CONVERT_VSCODE_TO_MONACO];
    mappings['cursorPageUp'] = ['cursorPageUp', CONVERT_VSCODE_TO_MONACO];
    mappings['cursorPageUpSelect'] = ['cursorPageUpSelect', CONVERT_VSCODE_TO_MONACO];
    mappings['cursorRight'] = ['cursorRight', CONVERT_VSCODE_TO_MONACO];
    mappings['cursorRightSelect'] = ['cursorRightSelect', CONVERT_VSCODE_TO_MONACO];
    mappings['cursorTop'] = ['cursorTop', CONVERT_VSCODE_TO_MONACO];
    mappings['cursorTopSelect'] = ['cursorTopSelect', CONVERT_VSCODE_TO_MONACO];
    mappings['cursorUp'] = ['cursorUp', CONVERT_VSCODE_TO_MONACO];
    mappings['cursorUpSelect'] = ['cursorUpSelect', CONVERT_VSCODE_TO_MONACO];
    mappings['deleteLeft'] = ['deleteLeft', CONVERT_VSCODE_TO_MONACO];
    mappings['deleteRight'] = ['deleteRight', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.selectAll'] = ['editor.action.selectAll', CONVERT_VSCODE_TO_MONACO];
    mappings['expandLineSelection'] = ['expandLineSelection', CONVERT_VSCODE_TO_MONACO];
    mappings['outdent'] = ['outdent', CONVERT_VSCODE_TO_MONACO];
    mappings['scrollLineDown'] = ['scrollLineDown', CONVERT_VSCODE_TO_MONACO];
    mappings['scrollLineUp'] = ['scrollLineUp', CONVERT_VSCODE_TO_MONACO];
    mappings['scrollPageDown'] = ['scrollPageDown', CONVERT_VSCODE_TO_MONACO];
    mappings['scrollPageUp'] = ['scrollPageUp', CONVERT_VSCODE_TO_MONACO];
    mappings['tab'] = ['tab', CONVERT_VSCODE_TO_MONACO];
    mappings['removeSecondaryCursors'] = ['removeSecondaryCursors', CONVERT_VSCODE_TO_MONACO];
    mappings['cursorWordRight'] = ['cursorWordEndRight', CONVERT_VSCODE_TO_MONACO];
    mappings['cursorWordEndRight'] = ['cursorWordEndRight', CONVERT_VSCODE_TO_MONACO];
    mappings['cursorWordEndRightSelect'] = ['cursorWordEndRightSelect', CONVERT_VSCODE_TO_MONACO];
    mappings['cursorWordLeft'] = ['cursorWordStartLeft', CONVERT_VSCODE_TO_MONACO];
    mappings['cursorWordStartLeft'] = ['cursorWordStartLeft', CONVERT_VSCODE_TO_MONACO];
    mappings['cursorWordStartLeftSelect'] = ['cursorWordStartLeftSelect', CONVERT_VSCODE_TO_MONACO];
    mappings['deleteWordLeft'] = ['deleteWordLeft', CONVERT_VSCODE_TO_MONACO];
    mappings['deleteWordRight'] = ['deleteWordRight', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.cancelOperation'] = ['editor.cancelOperation', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.gotoNextSymbolFromResult'] = ['editor.gotoNextSymbolFromResult', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.gotoNextSymbolFromResult.cancel'] = ['editor.gotoNextSymbolFromResult.cancel', CONVERT_VSCODE_TO_MONACO];
    mappings['openReferenceToSide'] = ['openReferenceToSide', CONVERT_VSCODE_TO_MONACO];
    mappings['toggleExplainMode'] = ['toggleExplainMode', CONVERT_VSCODE_TO_MONACO];
    mappings['closeFindWidget'] = ['closeFindWidget', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.replaceAll'] = ['editor.action.replaceAll', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.replaceOne'] = ['editor.action.replaceOne', CONVERT_VSCODE_TO_MONACO];
    mappings['editor.action.selectAllMatches'] = ['editor.action.selectAllMatches', CONVERT_VSCODE_TO_MONACO];
    mappings['toggleFindCaseSensitive'] = ['toggleFindCaseSensitive', CONVERT_VSCODE_TO_MONACO];
    mappings['toggleFindInSelection'] = ['toggleFindInSelection', CONVERT_VSCODE_TO_MONACO];
    mappings['toggleFindRegex'] = ['toggleFindRegex', CONVERT_VSCODE_TO_MONACO];
    mappings['toggleFindWholeWord'] = ['toggleFindWholeWord', CONVERT_VSCODE_TO_MONACO];
    mappings['jumpToNextSnippetPlaceholder'] = ['jumpToNextSnippetPlaceholder', CONVERT_VSCODE_TO_MONACO];
    mappings['jumpToPrevSnippetPlaceholder'] = ['jumpToPrevSnippetPlaceholder', CONVERT_VSCODE_TO_MONACO];
    mappings['leaveEditorMessage'] = ['leaveEditorMessage', CONVERT_VSCODE_TO_MONACO];
    mappings['leaveSnippet'] = ['leaveSnippet', CONVERT_VSCODE_TO_MONACO];
    mappings['closeMarkersNavigation'] = ['closeMarkersNavigation', CONVERT_VSCODE_TO_MONACO];
    mappings['goToNextReferenceFromEmbeddedEditor'] = ['goToNextReferenceFromEmbeddedEditor', CONVERT_VSCODE_TO_MONACO];
    mappings['goToPreviousReferenceFromEmbeddedEditor'] = ['goToPreviousReferenceFromEmbeddedEditor', CONVERT_VSCODE_TO_MONACO];
    mappings['closeParameterHints'] = ['closeParameterHints', CONVERT_VSCODE_TO_MONACO];
    mappings['showNextParameterHint'] = ['showNextParameterHint', CONVERT_VSCODE_TO_MONACO];
    mappings['showPrevParameterHint'] = ['showPrevParameterHint', CONVERT_VSCODE_TO_MONACO];
    mappings['acceptSelectedSuggestion'] = ['acceptSelectedSuggestion', CONVERT_VSCODE_TO_MONACO];
    mappings['acceptSelectedSuggestionOnEnter'] = ['acceptSelectedSuggestionOnEnter', CONVERT_VSCODE_TO_MONACO];
    mappings['hideSuggestWidget'] = ['hideSuggestWidget', CONVERT_VSCODE_TO_MONACO];
    mappings['insertBestCompletion'] = ['insertBestCompletion', CONVERT_VSCODE_TO_MONACO];
    mappings['insertNextSuggestion'] = ['insertNextSuggestion', CONVERT_VSCODE_TO_MONACO];
    mappings['insertPrevSuggestion'] = ['insertPrevSuggestion', CONVERT_VSCODE_TO_MONACO];
    mappings['selectNextPageSuggestion'] = ['selectNextPageSuggestion', CONVERT_VSCODE_TO_MONACO];
    mappings['selectNextSuggestion'] = ['selectNextSuggestion', CONVERT_VSCODE_TO_MONACO];
    mappings['selectPrevPageSuggestion'] = ['selectPrevPageSuggestion', CONVERT_VSCODE_TO_MONACO];
    mappings['selectPrevSuggestion'] = ['selectPrevSuggestion', CONVERT_VSCODE_TO_MONACO];
    mappings['toggleSuggestionDetails'] = ['toggleSuggestionDetails', CONVERT_VSCODE_TO_MONACO];
    mappings['toggleSuggestionFocus'] = ['toggleSuggestionFocus', CONVERT_VSCODE_TO_MONACO];
    mappings['acceptRenameInput'] = ['acceptRenameInput', CONVERT_VSCODE_TO_MONACO];
    mappings['cancelRenameInput'] = ['cancelRenameInput', CONVERT_VSCODE_TO_MONACO];
    mappings['closeAccessibilityHelp'] = ['closeAccessibilityHelp', CONVERT_VSCODE_TO_MONACO];
    mappings['history.showNext'] = ['history.showNext', CONVERT_VSCODE_TO_MONACO];
    mappings['history.showPrevious'] = ['history.showPrevious', CONVERT_VSCODE_TO_MONACO];
    mappings['closeReferenceSearch'] = ['closeReferenceSearch', CONVERT_VSCODE_TO_MONACO];
    mappings['goToNextReference'] = ['goToNextReference', CONVERT_VSCODE_TO_MONACO];
    mappings['goToPreviousReference'] = ['goToPreviousReference', CONVERT_VSCODE_TO_MONACO];
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const CONVERT_MONACO_TO_VSCODE = (args) => {
        if (!args) {
            return args;
        }
        if (!Array.isArray(args)) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return monacoToVscodeArgsConverter(args);
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const argsArray = args;
        const argStack = [];
        argsArray.forEach(_ => {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            argStack.push((arg) => monacoToVscodeArgsConverter(arg));
        });
        if (argsArray) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return createConversionFunction(...argStack)(argsArray);
        }
    };
    // vscode-'executeXXX'-like commands
    mappings['vscode.executeReferenceProvider'] = ['vscode.executeReferenceProvider', CONVERT_VSCODE_TO_MONACO, CONVERT_MONACO_TO_VSCODE];
    mappings['vscode.executeImplementationProvider'] = ['vscode.executeImplementationProvider', CONVERT_VSCODE_TO_MONACO, CONVERT_MONACO_TO_VSCODE];
    mappings['vscode.executeDefinitionProvider'] = ['vscode.executeDefinitionProvider', CONVERT_VSCODE_TO_MONACO, CONVERT_MONACO_TO_VSCODE];
    mappings['vscode.executeDeclarationProvider'] = ['vscode.executeDeclarationProvider', CONVERT_VSCODE_TO_MONACO, CONVERT_MONACO_TO_VSCODE];
    mappings['vscode.executeTypeDefinitionProvider'] = ['vscode.executeTypeDefinitionProvider', CONVERT_VSCODE_TO_MONACO, CONVERT_MONACO_TO_VSCODE];
    mappings['vscode.executeHoverProvider'] = ['vscode.executeHoverProvider', CONVERT_VSCODE_TO_MONACO, CONVERT_MONACO_TO_VSCODE];
    mappings['vscode.executeDocumentHighlights'] = ['vscode.executeDocumentHighlights', CONVERT_VSCODE_TO_MONACO, CONVERT_MONACO_TO_VSCODE];
    mappings['vscode.executeFormatDocumentProvider'] = ['vscode.executeFormatDocumentProvider', CONVERT_VSCODE_TO_MONACO, CONVERT_MONACO_TO_VSCODE];
    mappings['vscode.executeFormatRangeProvider'] = ['vscode.executeFormatRangeProvider', CONVERT_VSCODE_TO_MONACO, CONVERT_MONACO_TO_VSCODE];
    mappings['vscode.executeFormatOnTypeProvider'] = ['vscode.executeFormatOnTypeProvider', CONVERT_VSCODE_TO_MONACO, CONVERT_MONACO_TO_VSCODE];
    mappings['vscode.prepareCallHierarchy'] = ['vscode.prepareCallHierarchy', CONVERT_VSCODE_TO_MONACO, CONVERT_MONACO_TO_VSCODE];
    mappings['vscode.provideIncomingCalls'] = ['vscode.provideIncomingCalls', CONVERT_VSCODE_TO_MONACO, CONVERT_MONACO_TO_VSCODE];
    mappings['vscode.provideOutgoingCalls'] = ['vscode.provideOutgoingCalls', CONVERT_VSCODE_TO_MONACO, CONVERT_MONACO_TO_VSCODE];
    mappings['vscode.prepareTypeHierarchy'] = ['vscode.prepareTypeHierarchy', CONVERT_VSCODE_TO_MONACO, CONVERT_MONACO_TO_VSCODE];
    mappings['vscode.provideSupertypes'] = ['vscode.provideSupertypes', CONVERT_VSCODE_TO_MONACO, CONVERT_MONACO_TO_VSCODE];
    mappings['vscode.provideSubtypes'] = ['vscode.provideSubtypes', CONVERT_VSCODE_TO_MONACO, CONVERT_MONACO_TO_VSCODE];
    mappings['vscode.open'] = ['vscode.open', CONVERT_VSCODE_TO_MONACO];
    mappings['vscode.diff'] = ['vscode.diff', CONVERT_VSCODE_TO_MONACO];
    // terminal commands
    mappings['workbench.action.terminal.new'] = ['terminal:new', identity];
    mappings['workbench.action.terminal.newWithProfile'] = ['terminal:new:profile', identity];
    mappings['workbench.action.terminal.selectDefaultShell'] = ['terminal:profile:default', identity];
    mappings['workbench.action.terminal.newInActiveWorkspace'] = ['terminal:new:active:workspace', identity];
    mappings['workbench.action.terminal.clear'] = ['terminal:clear', identity];
    mappings['openInTerminal'] = ['terminal:context', createConversionFunction((uri) => new uri_1.URI(uri))];
    mappings['workbench.action.terminal.split'] = ['terminal:split', identity];
    mappings['workbench.action.terminal.focusFind'] = ['terminal:find', identity];
    mappings['workbench.action.terminal.hideFind'] = ['terminal:find:cancel', identity];
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function map(id, args, toDo) {
        if (mappings[id]) {
            return toDo(mappings[id][0], mappings[id][1](args), mappings[id][2] ? (result => mappings[id][2](result)) : undefined);
        }
        else {
            return toDo(id, args, undefined);
        }
    }
    KnownCommands.map = map;
    function mapped(id) {
        return !!mappings[id];
    }
    KnownCommands.mapped = mapped;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function createConversionFunction(...conversions) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return function (args) {
            if (!args) {
                return args;
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return args.map(function (arg, index) {
                if (index < conversions.length) {
                    const conversion = conversions[index];
                    if (conversion) {
                        return conversion(arg);
                    }
                }
                return arg;
            });
        };
    }
    function fromPositionToP(p) {
        return vscode_languageserver_protocol_1.Position.create(p.line, p.character);
    }
    function fromRangeToR(r) {
        return vscode_languageserver_protocol_1.Range.create(fromPositionToP(r.start), fromPositionToP(r.end));
    }
    function fromLocationToL(l) {
        return vscode_languageserver_protocol_1.Location.create(l.uri.toString(), fromRangeToR(l.range));
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/tslint/config
    function vscodeToMonacoArgsConverter(args) {
        // tslint:disable-next-line:typedef
        return (0, objects_1.cloneAndChange)(args, function (value) {
            if (types_impl_1.CallHierarchyItem.isCallHierarchyItem(value)) {
                return (0, type_converters_1.fromCallHierarchyItem)(value);
            }
            if (types_impl_1.TypeHierarchyItem.isTypeHierarchyItem(value)) {
                return (0, type_converters_1.fromTypeHierarchyItem)(value);
            }
            if (types_impl_1.TextDocumentShowOptions.isTextDocumentShowOptions(value)) {
                return (0, type_converters_1.fromTextDocumentShowOptions)(value);
            }
            if (types_impl_1.Position.isPosition(value)) {
                return (0, type_converters_1.fromPosition)(value);
            }
            if (types_impl_1.Range.isRange(value)) {
                return (0, type_converters_1.fromRange)(value);
            }
            if (types_impl_1.Location.isLocation(value)) {
                return (0, type_converters_1.fromLocation)(value);
            }
            if (!Array.isArray(value)) {
                return value;
            }
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/tslint/config
    function monacoToVscodeArgsConverter(args) {
        // tslint:disable-next-line:typedef
        return (0, objects_1.cloneAndChange)(args, function (value) {
            if ((0, type_converters_1.isModelCallHierarchyItem)(value)) {
                return (0, type_converters_1.toCallHierarchyItem)(value);
            }
            if ((0, type_converters_1.isModelTypeHierarchyItem)(value)) {
                return (0, type_converters_1.toTypeHierarchyItem)(value);
            }
            if ((0, type_converters_1.isModelCallHierarchyIncomingCall)(value)) {
                return (0, type_converters_1.toCallHierarchyIncomingCall)(value);
            }
            if ((0, type_converters_1.isModelCallHierarchyOutgoingCall)(value)) {
                return (0, type_converters_1.toCallHierarchyOutgoingCall)(value);
            }
            if ((0, type_converters_1.isModelLocation)(value)) {
                return (0, type_converters_1.toLocation)(value);
            }
            if (!Array.isArray(value)) {
                return value;
            }
        });
    }
})(KnownCommands = exports.KnownCommands || (exports.KnownCommands = {}));
function toArrayConversion(f) {
    // tslint:disable-next-line:typedef
    return function (a) {
        return a.map(f);
    };
}


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/label-service.js":
/*!*************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/label-service.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LabelServiceExtImpl = void 0;
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../packages/core/lib/common/disposable.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
class LabelServiceExtImpl {
    constructor(rpc) {
        this.rpc = rpc;
        this.handle = 0;
        this.proxy = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.LABEL_SERVICE_MAIN);
    }
    $registerResourceLabelFormatter(formatter) {
        const handle = this.handle++;
        this.proxy.$registerResourceLabelFormatter(handle, formatter);
        return disposable_1.Disposable.create(() => {
            this.proxy.$unregisterResourceLabelFormatter(handle);
        });
    }
}
exports.LabelServiceExtImpl = LabelServiceExtImpl;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages-utils.js":
/*!***************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages-utils.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.serializeIndentation = exports.serializeRegExp = exports.serializeEnterRules = void 0;
function serializeEnterRules(rules) {
    if (typeof rules === 'undefined' || rules === null) {
        return undefined;
    }
    return rules.map(r => ({
        beforeText: serializeRegExp(r.beforeText),
        afterText: serializeRegExp(r.afterText),
        previousLineText: serializeRegExp(r.previousLineText),
        action: r.action,
    }));
}
exports.serializeEnterRules = serializeEnterRules;
function serializeRegExp(regexp) {
    if (typeof regexp === 'undefined' || regexp === null) {
        return undefined;
    }
    return {
        pattern: regexp.source,
        flags: (regexp.global ? 'g' : '') + (regexp.ignoreCase ? 'i' : '') + (regexp.multiline ? 'm' : '')
    };
}
exports.serializeRegExp = serializeRegExp;
function serializeIndentation(indentationRules) {
    if (typeof indentationRules === 'undefined' || indentationRules === null) {
        return undefined;
    }
    return {
        increaseIndentPattern: serializeRegExp(indentationRules.increaseIndentPattern),
        decreaseIndentPattern: serializeRegExp(indentationRules.decreaseIndentPattern),
        indentNextLinePattern: serializeRegExp(indentationRules.indentNextLinePattern),
        unIndentedLinePattern: serializeRegExp(indentationRules.unIndentedLinePattern)
    };
}
exports.serializeIndentation = serializeIndentation;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages.js":
/*!*********************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LanguagesExtImpl = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const completion_1 = __webpack_require__(/*! ./languages/completion */ "../../packages/plugin-ext/lib/plugin/languages/completion.js");
const diagnostics_1 = __webpack_require__(/*! ./languages/diagnostics */ "../../packages/plugin-ext/lib/plugin/languages/diagnostics.js");
const signature_1 = __webpack_require__(/*! ./languages/signature */ "../../packages/plugin-ext/lib/plugin/languages/signature.js");
const hover_1 = __webpack_require__(/*! ./languages/hover */ "../../packages/plugin-ext/lib/plugin/languages/hover.js");
const evaluatable_expression_1 = __webpack_require__(/*! ./languages/evaluatable-expression */ "../../packages/plugin-ext/lib/plugin/languages/evaluatable-expression.js");
const inline_values_1 = __webpack_require__(/*! ./languages/inline-values */ "../../packages/plugin-ext/lib/plugin/languages/inline-values.js");
const document_highlight_1 = __webpack_require__(/*! ./languages/document-highlight */ "../../packages/plugin-ext/lib/plugin/languages/document-highlight.js");
const document_formatting_1 = __webpack_require__(/*! ./languages/document-formatting */ "../../packages/plugin-ext/lib/plugin/languages/document-formatting.js");
const range_formatting_1 = __webpack_require__(/*! ./languages/range-formatting */ "../../packages/plugin-ext/lib/plugin/languages/range-formatting.js");
const on_type_formatting_1 = __webpack_require__(/*! ./languages/on-type-formatting */ "../../packages/plugin-ext/lib/plugin/languages/on-type-formatting.js");
const definition_1 = __webpack_require__(/*! ./languages/definition */ "../../packages/plugin-ext/lib/plugin/languages/definition.js");
const implementation_1 = __webpack_require__(/*! ./languages/implementation */ "../../packages/plugin-ext/lib/plugin/languages/implementation.js");
const type_definition_1 = __webpack_require__(/*! ./languages/type-definition */ "../../packages/plugin-ext/lib/plugin/languages/type-definition.js");
const code_action_1 = __webpack_require__(/*! ./languages/code-action */ "../../packages/plugin-ext/lib/plugin/languages/code-action.js");
const link_provider_1 = __webpack_require__(/*! ./languages/link-provider */ "../../packages/plugin-ext/lib/plugin/languages/link-provider.js");
const lens_1 = __webpack_require__(/*! ./languages/lens */ "../../packages/plugin-ext/lib/plugin/languages/lens.js");
const outline_1 = __webpack_require__(/*! ./languages/outline */ "../../packages/plugin-ext/lib/plugin/languages/outline.js");
const reference_1 = __webpack_require__(/*! ./languages/reference */ "../../packages/plugin-ext/lib/plugin/languages/reference.js");
const workspace_symbol_1 = __webpack_require__(/*! ./languages/workspace-symbol */ "../../packages/plugin-ext/lib/plugin/languages/workspace-symbol.js");
const folding_1 = __webpack_require__(/*! ./languages/folding */ "../../packages/plugin-ext/lib/plugin/languages/folding.js");
const selection_range_1 = __webpack_require__(/*! ./languages/selection-range */ "../../packages/plugin-ext/lib/plugin/languages/selection-range.js");
const color_1 = __webpack_require__(/*! ./languages/color */ "../../packages/plugin-ext/lib/plugin/languages/color.js");
const rename_1 = __webpack_require__(/*! ./languages/rename */ "../../packages/plugin-ext/lib/plugin/languages/rename.js");
const declaration_1 = __webpack_require__(/*! ./languages/declaration */ "../../packages/plugin-ext/lib/plugin/languages/declaration.js");
const call_hierarchy_1 = __webpack_require__(/*! ./languages/call-hierarchy */ "../../packages/plugin-ext/lib/plugin/languages/call-hierarchy.js");
const type_hierarchy_1 = __webpack_require__(/*! ./languages/type-hierarchy */ "../../packages/plugin-ext/lib/plugin/languages/type-hierarchy.js");
const semantic_highlighting_1 = __webpack_require__(/*! ./languages/semantic-highlighting */ "../../packages/plugin-ext/lib/plugin/languages/semantic-highlighting.js");
const arrays_1 = __webpack_require__(/*! ../common/arrays */ "../../packages/plugin-ext/lib/common/arrays.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../packages/core/lib/common/disposable.js");
const severity_1 = __webpack_require__(/*! @theia/core/lib/common/severity */ "../../packages/core/lib/common/severity.js");
const linked_editing_range_1 = __webpack_require__(/*! ./languages/linked-editing-range */ "../../packages/plugin-ext/lib/plugin/languages/linked-editing-range.js");
const languages_utils_1 = __webpack_require__(/*! ./languages-utils */ "../../packages/plugin-ext/lib/plugin/languages-utils.js");
const inlay_hints_1 = __webpack_require__(/*! ./languages/inlay-hints */ "../../packages/plugin-ext/lib/plugin/languages/inlay-hints.js");
const inline_completion_1 = __webpack_require__(/*! ./languages/inline-completion */ "../../packages/plugin-ext/lib/plugin/languages/inline-completion.js");
const document_drop_edit_1 = __webpack_require__(/*! ./languages/document-drop-edit */ "../../packages/plugin-ext/lib/plugin/languages/document-drop-edit.js");
class LanguagesExtImpl {
    constructor(rpc, documents, commands, filesSystem) {
        this.documents = documents;
        this.commands = commands;
        this.filesSystem = filesSystem;
        this.callId = 0;
        this.adaptersMap = new Map();
        // Copied from https://github.com/microsoft/vscode/blob/7d9b1c37f8e5ae3772782ba3b09d827eb3fdd833/src/vs/workbench/api/common/extHostLanguages.ts
        this.statusItemHandlePool = 0;
        this.statusItemIds = new Set();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.LANGUAGES_MAIN);
        this.diagnostics = new diagnostics_1.Diagnostics(rpc);
        filesSystem.onWillRegisterFileSystemProvider(linkProvider => this.registerLinkProviderIfNotYetRegistered(linkProvider));
    }
    dispose() {
        if (this.linkProviderRegistration) {
            this.linkProviderRegistration.dispose();
        }
    }
    get onDidChangeDiagnostics() {
        return this.diagnostics.onDidChangeDiagnostics;
    }
    getLanguages() {
        return this.proxy.$getLanguages();
    }
    changeLanguage(uri, languageId) {
        return this.proxy.$changeLanguage(uri, languageId).then(() => {
            const doc = this.documents.getDocumentData(uri);
            if (!doc) {
                throw new Error('No document found by URI ' + uri.toString());
            }
            return doc.document;
        });
    }
    setLanguageConfiguration(language, configuration) {
        const { wordPattern } = configuration;
        if (wordPattern) {
            this.documents.setWordDefinitionFor(language, wordPattern);
        }
        else {
            this.documents.setWordDefinitionFor(language, null);
        }
        const callId = this.nextCallId();
        const config = {
            brackets: configuration.brackets,
            comments: configuration.comments,
            onEnterRules: (0, languages_utils_1.serializeEnterRules)(configuration.onEnterRules),
            wordPattern: (0, languages_utils_1.serializeRegExp)(configuration.wordPattern),
            indentationRules: (0, languages_utils_1.serializeIndentation)(configuration.indentationRules)
        };
        this.proxy.$setLanguageConfiguration(callId, language, config);
        return this.createDisposable(callId);
    }
    nextCallId() {
        return this.callId++;
    }
    createDisposable(callId, onDispose) {
        return new types_impl_1.Disposable(() => {
            this.adaptersMap.delete(callId);
            this.proxy.$unregister(callId);
            onDispose === null || onDispose === void 0 ? void 0 : onDispose();
        });
    }
    addNewAdapter(adapter) {
        const callId = this.nextCallId();
        this.adaptersMap.set(callId, adapter);
        return callId;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async withAdapter(handle, ctor, callback, fallbackValue) {
        const adapter = this.adaptersMap.get(handle);
        if (!adapter) {
            return fallbackValue;
        }
        if (adapter instanceof ctor) {
            return callback(adapter);
        }
        throw new Error('no adapter found');
    }
    transformDocumentSelector(selector) {
        if ((0, arrays_1.isReadonlyArray)(selector)) {
            return selector.map(sel => this.doTransformDocumentSelector(sel));
        }
        return [this.doTransformDocumentSelector(selector)];
    }
    doTransformDocumentSelector(selector) {
        if (typeof selector === 'string') {
            return {
                $serialized: true,
                language: selector
            };
        }
        if (selector) {
            return {
                $serialized: true,
                language: selector.language,
                scheme: selector.scheme,
                pattern: selector.pattern,
                notebookType: selector.notebookType
            };
        }
        return undefined;
    }
    registerLinkProviderIfNotYetRegistered(linkProvider) {
        if (!this.linkProviderRegistration) {
            this.linkProviderRegistration = this.registerDocumentLinkProvider('*', linkProvider, {
                id: 'theia.fs-ext-impl',
                name: 'fs-ext-impl'
            });
        }
    }
    // ### Completion begin
    $provideCompletionItems(handle, resource, position, context, token) {
        return this.withAdapter(handle, completion_1.CompletionAdapter, adapter => adapter.provideCompletionItems(types_impl_1.URI.revive(resource), position, context, token), undefined);
    }
    $resolveCompletionItem(handle, chainedId, token) {
        return this.withAdapter(handle, completion_1.CompletionAdapter, adapter => adapter.resolveCompletionItem(chainedId, token), undefined);
    }
    $releaseCompletionItems(handle, id) {
        this.withAdapter(handle, completion_1.CompletionAdapter, async (adapter) => adapter.releaseCompletionItems(id), undefined);
    }
    registerCompletionItemProvider(selector, provider, triggerCharacters, pluginInfo) {
        const callId = this.addNewAdapter(new completion_1.CompletionAdapter(provider, this.documents, this.commands));
        this.proxy.$registerCompletionSupport(callId, pluginInfo, this.transformDocumentSelector(selector), triggerCharacters, completion_1.CompletionAdapter.hasResolveSupport(provider));
        return this.createDisposable(callId);
    }
    // ### Completion end
    // ### Inline completion provider begin
    registerInlineCompletionsProvider(selector, provider) {
        const callId = this.addNewAdapter(new inline_completion_1.InlineCompletionAdapter(this.documents, provider, this.commands));
        this.proxy.$registerInlineCompletionsSupport(callId, this.transformDocumentSelector(selector));
        return this.createDisposable(callId);
    }
    $provideInlineCompletions(handle, resource, position, context, token) {
        return this.withAdapter(handle, inline_completion_1.InlineCompletionAdapterBase, adapter => adapter.provideInlineCompletions(types_impl_1.URI.revive(resource), position, context, token), undefined);
    }
    $freeInlineCompletionsList(handle, pid) {
        this.withAdapter(handle, inline_completion_1.InlineCompletionAdapterBase, async (adapter) => { adapter.disposeCompletions(pid); }, undefined);
    }
    // ### Inline completion provider end
    // ### Definition provider begin
    $provideDefinition(handle, resource, position, token) {
        return this.withAdapter(handle, definition_1.DefinitionAdapter, adapter => adapter.provideDefinition(types_impl_1.URI.revive(resource), position, token), undefined);
    }
    registerDefinitionProvider(selector, provider, pluginInfo) {
        const callId = this.addNewAdapter(new definition_1.DefinitionAdapter(provider, this.documents));
        this.proxy.$registerDefinitionProvider(callId, pluginInfo, this.transformDocumentSelector(selector));
        return this.createDisposable(callId);
    }
    // ### Definition provider end
    // ### Declaration provider begin
    $provideDeclaration(handle, resource, position, token) {
        return this.withAdapter(handle, declaration_1.DeclarationAdapter, adapter => adapter.provideDeclaration(types_impl_1.URI.revive(resource), position, token), undefined);
    }
    registerDeclarationProvider(selector, provider, pluginInfo) {
        const callId = this.addNewAdapter(new declaration_1.DeclarationAdapter(provider, this.documents));
        this.proxy.$registerDeclarationProvider(callId, pluginInfo, this.transformDocumentSelector(selector));
        return this.createDisposable(callId);
    }
    // ### Declaration provider end
    // ### Signature help begin
    $provideSignatureHelp(handle, resource, position, context, token) {
        return this.withAdapter(handle, signature_1.SignatureHelpAdapter, adapter => adapter.provideSignatureHelp(types_impl_1.URI.revive(resource), position, token, context), undefined);
    }
    $releaseSignatureHelp(handle, id) {
        this.withAdapter(handle, signature_1.SignatureHelpAdapter, async (adapter) => adapter.releaseSignatureHelp(id), undefined);
    }
    registerSignatureHelpProvider(selector, provider, metadata, pluginInfo) {
        const callId = this.addNewAdapter(new signature_1.SignatureHelpAdapter(provider, this.documents));
        this.proxy.$registerSignatureHelpProvider(callId, pluginInfo, this.transformDocumentSelector(selector), metadata);
        return this.createDisposable(callId);
    }
    // ### Signature help end
    // ### Diagnostics begin
    getDiagnostics(resource) {
        return this.diagnostics.getDiagnostics(resource);
    }
    createDiagnosticCollection(name) {
        return this.diagnostics.createDiagnosticCollection(name);
    }
    // ### Diagnostics end
    // ### Implementation provider begin
    $provideImplementation(handle, resource, position, token) {
        return this.withAdapter(handle, implementation_1.ImplementationAdapter, adapter => adapter.provideImplementation(types_impl_1.URI.revive(resource), position, token), undefined);
    }
    registerImplementationProvider(selector, provider, pluginInfo) {
        const callId = this.addNewAdapter(new implementation_1.ImplementationAdapter(provider, this.documents));
        this.proxy.$registerImplementationProvider(callId, pluginInfo, this.transformDocumentSelector(selector));
        return this.createDisposable(callId);
    }
    // ### Implementation provider end
    // ### Type Definition provider begin
    $provideTypeDefinition(handle, resource, position, token) {
        return this.withAdapter(handle, type_definition_1.TypeDefinitionAdapter, adapter => adapter.provideTypeDefinition(types_impl_1.URI.revive(resource), position, token), undefined);
    }
    registerTypeDefinitionProvider(selector, provider, pluginInfo) {
        const callId = this.addNewAdapter(new type_definition_1.TypeDefinitionAdapter(provider, this.documents));
        this.proxy.$registerTypeDefinitionProvider(callId, pluginInfo, this.transformDocumentSelector(selector));
        return this.createDisposable(callId);
    }
    // ### Type Definition provider end
    // ### Hover Provider begin
    registerHoverProvider(selector, provider, pluginInfo) {
        const callId = this.addNewAdapter(new hover_1.HoverAdapter(provider, this.documents));
        this.proxy.$registerHoverProvider(callId, pluginInfo, this.transformDocumentSelector(selector));
        return this.createDisposable(callId);
    }
    $provideHover(handle, resource, position, token) {
        return this.withAdapter(handle, hover_1.HoverAdapter, adapter => adapter.provideHover(types_impl_1.URI.revive(resource), position, token), undefined);
    }
    // ### Hover Provider end
    // ### EvaluatableExpression Provider begin
    registerEvaluatableExpressionProvider(selector, provider, pluginInfo) {
        const callId = this.addNewAdapter(new evaluatable_expression_1.EvaluatableExpressionAdapter(provider, this.documents));
        this.proxy.$registerEvaluatableExpressionProvider(callId, pluginInfo, this.transformDocumentSelector(selector));
        return this.createDisposable(callId);
    }
    $provideEvaluatableExpression(handle, resource, position, token) {
        return this.withAdapter(handle, evaluatable_expression_1.EvaluatableExpressionAdapter, adapter => adapter.provideEvaluatableExpression(types_impl_1.URI.revive(resource), position, token), undefined);
    }
    // ### EvaluatableExpression Provider end
    // ### InlineValues Provider begin
    registerInlineValuesProvider(selector, provider, pluginInfo) {
        const eventHandle = typeof provider.onDidChangeInlineValues === 'function' ? this.nextCallId() : undefined;
        const callId = this.addNewAdapter(new inline_values_1.InlineValuesAdapter(provider, this.documents));
        this.proxy.$registerInlineValuesProvider(callId, pluginInfo, this.transformDocumentSelector(selector));
        let result = this.createDisposable(callId);
        if (eventHandle !== undefined) {
            const subscription = provider.onDidChangeInlineValues(_ => this.proxy.$emitInlineValuesEvent(eventHandle));
            result = types_impl_1.Disposable.from(result, subscription);
        }
        return result;
    }
    $provideInlineValues(handle, resource, range, context, token) {
        return this.withAdapter(handle, inline_values_1.InlineValuesAdapter, adapter => adapter.provideInlineValues(types_impl_1.URI.revive(resource), range, context, token), undefined);
    }
    // ### InlineValue Provider end
    // ### Document Highlight Provider begin
    registerDocumentHighlightProvider(selector, provider, pluginInfo) {
        const callId = this.addNewAdapter(new document_highlight_1.DocumentHighlightAdapter(provider, this.documents));
        this.proxy.$registerDocumentHighlightProvider(callId, pluginInfo, this.transformDocumentSelector(selector));
        return this.createDisposable(callId);
    }
    $provideDocumentHighlights(handle, resource, position, token) {
        return this.withAdapter(handle, document_highlight_1.DocumentHighlightAdapter, adapter => adapter.provideDocumentHighlights(types_impl_1.URI.revive(resource), position, token), undefined);
    }
    // ### Document Highlight Provider end
    // ### WorkspaceSymbol Provider begin
    registerWorkspaceSymbolProvider(provider, pluginInfo) {
        const callId = this.addNewAdapter(new workspace_symbol_1.WorkspaceSymbolAdapter(provider));
        this.proxy.$registerWorkspaceSymbolProvider(callId, pluginInfo);
        return this.createDisposable(callId);
    }
    $provideWorkspaceSymbols(handle, query, token) {
        return this.withAdapter(handle, workspace_symbol_1.WorkspaceSymbolAdapter, adapter => adapter.provideWorkspaceSymbols(query, token), []);
    }
    $resolveWorkspaceSymbol(handle, symbol, token) {
        return this.withAdapter(handle, workspace_symbol_1.WorkspaceSymbolAdapter, adapter => adapter.resolveWorkspaceSymbol(symbol, token), undefined);
    }
    // ### WorkspaceSymbol Provider end
    // ### Document Formatting Edit begin
    registerDocumentFormattingEditProvider(selector, provider, pluginInfo) {
        const callId = this.addNewAdapter(new document_formatting_1.DocumentFormattingAdapter(provider, this.documents));
        this.proxy.$registerDocumentFormattingSupport(callId, pluginInfo, this.transformDocumentSelector(selector));
        return this.createDisposable(callId);
    }
    $provideDocumentFormattingEdits(handle, resource, options, token) {
        return this.withAdapter(handle, document_formatting_1.DocumentFormattingAdapter, adapter => adapter.provideDocumentFormattingEdits(types_impl_1.URI.revive(resource), options, token), undefined);
    }
    // ### Document Formatting Edit end
    // ### Drop Edit Provider start
    $provideDocumentDropEdits(handle, resource, position, dataTransfer, token) {
        return this.withAdapter(handle, document_drop_edit_1.DocumentDropEditAdapter, adapter => adapter.provideDocumentDropEdits(types_impl_1.URI.revive(resource), position, dataTransfer, token), undefined);
    }
    registerDocumentDropEditProvider(selector, provider, metadata) {
        const callId = this.addNewAdapter(new document_drop_edit_1.DocumentDropEditAdapter(provider, this.documents, this.filesSystem));
        this.proxy.$registerDocumentDropEditProvider(callId, this.transformDocumentSelector(selector), metadata);
        return this.createDisposable(callId);
    }
    // ### Drop Edit Provider end
    // ### Document Range Formatting Edit begin
    registerDocumentRangeFormattingEditProvider(selector, provider, pluginInfo) {
        const callId = this.addNewAdapter(new range_formatting_1.RangeFormattingAdapter(provider, this.documents));
        this.proxy.$registerRangeFormattingSupport(callId, pluginInfo, this.transformDocumentSelector(selector));
        return this.createDisposable(callId);
    }
    $provideDocumentRangeFormattingEdits(handle, resource, range, options, token) {
        return this.withAdapter(handle, range_formatting_1.RangeFormattingAdapter, adapter => adapter.provideDocumentRangeFormattingEdits(types_impl_1.URI.revive(resource), range, options, token), undefined);
    }
    // ### Document Range Formatting Edit end
    // ### On Type Formatting Edit begin
    registerOnTypeFormattingEditProvider(selector, provider, triggerCharacters, pluginInfo) {
        const callId = this.addNewAdapter(new on_type_formatting_1.OnTypeFormattingAdapter(provider, this.documents));
        this.proxy.$registerOnTypeFormattingProvider(callId, pluginInfo, this.transformDocumentSelector(selector), triggerCharacters);
        return this.createDisposable(callId);
    }
    $provideOnTypeFormattingEdits(handle, resource, position, ch, options, token) {
        return this.withAdapter(handle, on_type_formatting_1.OnTypeFormattingAdapter, adapter => adapter.provideOnTypeFormattingEdits(types_impl_1.URI.revive(resource), position, ch, options, token), undefined);
    }
    // ### On Type Formatting Edit end
    // ### Document Link Provider begin
    $provideDocumentLinks(handle, resource, token) {
        return this.withAdapter(handle, link_provider_1.LinkProviderAdapter, adapter => adapter.provideLinks(types_impl_1.URI.revive(resource), token), undefined);
    }
    $resolveDocumentLink(handle, link, token) {
        return this.withAdapter(handle, link_provider_1.LinkProviderAdapter, adapter => adapter.resolveLink(link, token), undefined);
    }
    registerDocumentLinkProvider(selector, provider, pluginInfo) {
        const callId = this.addNewAdapter(new link_provider_1.LinkProviderAdapter(provider, this.documents));
        this.proxy.$registerDocumentLinkProvider(callId, pluginInfo, this.transformDocumentSelector(selector));
        return this.createDisposable(callId);
    }
    $releaseDocumentLinks(handle, ids) {
        this.withAdapter(handle, link_provider_1.LinkProviderAdapter, async (adapter) => adapter.releaseDocumentLinks(ids), undefined);
    }
    // ### Document Link Provider end
    // ### Code Actions Provider begin
    registerCodeActionsProvider(selector, provider, pluginModel, pluginInfo, metadata) {
        const callId = this.addNewAdapter(new code_action_1.CodeActionAdapter(provider, this.documents, this.diagnostics, pluginModel ? pluginModel.id : '', this.commands));
        let documentation;
        let disposables;
        if (metadata && metadata.documentation) {
            disposables = new disposable_1.DisposableCollection();
            documentation = metadata.documentation.map(doc => ({
                kind: doc.kind.value,
                command: this.commands.converter.toSafeCommand(doc.command, disposables)
            }));
        }
        this.proxy.$registerQuickFixProvider(callId, pluginInfo, this.transformDocumentSelector(selector), metadata && metadata.providedCodeActionKinds ? metadata.providedCodeActionKinds.map(kind => kind.value) : undefined, documentation);
        return this.createDisposable(callId, disposables === null || disposables === void 0 ? void 0 : disposables.dispose);
    }
    $provideCodeActions(handle, resource, rangeOrSelection, context, token) {
        return this.withAdapter(handle, code_action_1.CodeActionAdapter, adapter => adapter.provideCodeAction(types_impl_1.URI.revive(resource), rangeOrSelection, context, token), undefined);
    }
    $releaseCodeActions(handle, cacheIds) {
        this.withAdapter(handle, code_action_1.CodeActionAdapter, adapter => adapter.releaseCodeActions(cacheIds), undefined);
    }
    $resolveCodeAction(handle, cacheId, token) {
        return this.withAdapter(handle, code_action_1.CodeActionAdapter, adapter => adapter.resolveCodeAction(cacheId, token), undefined);
    }
    ;
    // ### Code Actions Provider end
    // ### Code Lens Provider begin
    registerCodeLensProvider(selector, provider, pluginInfo) {
        const callId = this.addNewAdapter(new lens_1.CodeLensAdapter(provider, this.documents, this.commands));
        const eventHandle = typeof provider.onDidChangeCodeLenses === 'function' ? this.nextCallId() : undefined;
        this.proxy.$registerCodeLensSupport(callId, pluginInfo, this.transformDocumentSelector(selector), eventHandle);
        let result = this.createDisposable(callId);
        if (eventHandle !== undefined && provider.onDidChangeCodeLenses) {
            const subscription = provider.onDidChangeCodeLenses(e => this.proxy.$emitCodeLensEvent(eventHandle));
            result = types_impl_1.Disposable.from(result, subscription);
        }
        return result;
    }
    $provideCodeLenses(handle, resource, token) {
        return this.withAdapter(handle, lens_1.CodeLensAdapter, adapter => adapter.provideCodeLenses(types_impl_1.URI.revive(resource), token), undefined);
    }
    $resolveCodeLens(handle, resource, symbol, token) {
        return this.withAdapter(handle, lens_1.CodeLensAdapter, adapter => adapter.resolveCodeLens(types_impl_1.URI.revive(resource), symbol, token), undefined);
    }
    $releaseCodeLenses(handle, ids) {
        this.withAdapter(handle, lens_1.CodeLensAdapter, async (adapter) => adapter.releaseCodeLenses(ids), undefined);
    }
    // ### Code Lens Provider end
    // ### Code Reference Provider begin
    $provideReferences(handle, resource, position, context, token) {
        return this.withAdapter(handle, reference_1.ReferenceAdapter, adapter => adapter.provideReferences(types_impl_1.URI.revive(resource), position, context, token), undefined);
    }
    registerReferenceProvider(selector, provider, pluginInfo) {
        const callId = this.addNewAdapter(new reference_1.ReferenceAdapter(provider, this.documents));
        this.proxy.$registerReferenceProvider(callId, pluginInfo, this.transformDocumentSelector(selector));
        return this.createDisposable(callId);
    }
    // ### Code Reference Provider end
    // ### Document Symbol Provider begin
    registerDocumentSymbolProvider(selector, provider, pluginInfo, metadata) {
        const callId = this.addNewAdapter(new outline_1.OutlineAdapter(this.documents, provider));
        const displayName = (metadata && metadata.label) || getPluginLabel(pluginInfo);
        this.proxy.$registerOutlineSupport(callId, pluginInfo, this.transformDocumentSelector(selector), displayName);
        return this.createDisposable(callId);
    }
    $provideDocumentSymbols(handle, resource, token) {
        return this.withAdapter(handle, outline_1.OutlineAdapter, adapter => adapter.provideDocumentSymbols(types_impl_1.URI.revive(resource), token), undefined);
    }
    // ### Document Symbol Provider end
    // ### Color Provider begin
    registerColorProvider(selector, provider, pluginInfo) {
        const callId = this.addNewAdapter(new color_1.ColorProviderAdapter(this.documents, provider));
        this.proxy.$registerDocumentColorProvider(callId, pluginInfo, this.transformDocumentSelector(selector));
        return this.createDisposable(callId);
    }
    $provideDocumentColors(handle, resource, token) {
        return this.withAdapter(handle, color_1.ColorProviderAdapter, adapter => adapter.provideColors(types_impl_1.URI.revive(resource), token), []);
    }
    $provideColorPresentations(handle, resource, colorInfo, token) {
        return this.withAdapter(handle, color_1.ColorProviderAdapter, adapter => adapter.provideColorPresentations(types_impl_1.URI.revive(resource), colorInfo, token), []);
    }
    // ### Color Provider end
    // ### InlayHints Provider begin
    registerInlayHintsProvider(selector, provider, pluginInfo) {
        const eventHandle = typeof provider.onDidChangeInlayHints === 'function' ? this.nextCallId() : undefined;
        const callId = this.addNewAdapter(new inlay_hints_1.InlayHintsAdapter(provider, this.documents, this.commands));
        this.proxy.$registerInlayHintsProvider(callId, pluginInfo, this.transformDocumentSelector(selector));
        let result = this.createDisposable(callId);
        if (eventHandle !== undefined) {
            const subscription = provider.onDidChangeInlayHints(() => this.proxy.$emitInlayHintsEvent(eventHandle));
            result = types_impl_1.Disposable.from(result, subscription);
        }
        return result;
    }
    $provideInlayHints(handle, resource, range, token) {
        return this.withAdapter(handle, inlay_hints_1.InlayHintsAdapter, adapter => adapter.provideInlayHints(types_impl_1.URI.revive(resource), range, token), undefined);
    }
    $resolveInlayHint(handle, id, token) {
        return this.withAdapter(handle, inlay_hints_1.InlayHintsAdapter, adapter => adapter.resolveInlayHint(id, token), undefined);
    }
    $releaseInlayHints(handle, id) {
        this.withAdapter(handle, inlay_hints_1.InlayHintsAdapter, async (adapter) => adapter.releaseHints(id), undefined);
    }
    // ### InlayHints Provider end
    // ### Folding Range Provider begin
    registerFoldingRangeProvider(selector, provider, pluginInfo) {
        const callId = this.addNewAdapter(new folding_1.FoldingProviderAdapter(provider, this.documents));
        const eventHandle = typeof provider.onDidChangeFoldingRanges === 'function' ? this.nextCallId() : undefined;
        this.proxy.$registerFoldingRangeProvider(callId, pluginInfo, this.transformDocumentSelector(selector), eventHandle);
        let result = this.createDisposable(callId);
        if (eventHandle !== undefined) {
            const subscription = provider.onDidChangeFoldingRanges(() => this.proxy.$emitFoldingRangeEvent(eventHandle));
            result = types_impl_1.Disposable.from(result, subscription);
        }
        return result;
    }
    $provideFoldingRange(callId, resource, context, token) {
        return this.withAdapter(callId, folding_1.FoldingProviderAdapter, adapter => adapter.provideFoldingRanges(types_impl_1.URI.revive(resource), context, token), undefined);
    }
    // ### Folding Range Provider end
    registerSelectionRangeProvider(selector, provider, pluginInfo) {
        const callId = this.addNewAdapter(new selection_range_1.SelectionRangeProviderAdapter(provider, this.documents));
        this.proxy.$registerSelectionRangeProvider(callId, pluginInfo, this.transformDocumentSelector(selector));
        return this.createDisposable(callId);
    }
    $provideSelectionRanges(handle, resource, positions, token) {
        return this.withAdapter(handle, selection_range_1.SelectionRangeProviderAdapter, adapter => adapter.provideSelectionRanges(types_impl_1.URI.revive(resource), positions, token), []);
    }
    // ### Rename Provider begin
    registerRenameProvider(selector, provider, pluginInfo) {
        const callId = this.addNewAdapter(new rename_1.RenameAdapter(provider, this.documents));
        this.proxy.$registerRenameProvider(callId, pluginInfo, this.transformDocumentSelector(selector), rename_1.RenameAdapter.supportsResolving(provider));
        return this.createDisposable(callId);
    }
    $provideRenameEdits(handle, resource, position, newName, token) {
        return this.withAdapter(handle, rename_1.RenameAdapter, adapter => adapter.provideRenameEdits(types_impl_1.URI.revive(resource), position, newName, token), undefined);
    }
    $resolveRenameLocation(handle, resource, position, token) {
        return this.withAdapter(handle, rename_1.RenameAdapter, adapter => adapter.resolveRenameLocation(types_impl_1.URI.revive(resource), position, token), undefined);
    }
    // ### Rename Provider end
    // ### Call Hierarchy Provider begin
    registerCallHierarchyProvider(selector, provider) {
        const callId = this.addNewAdapter(new call_hierarchy_1.CallHierarchyAdapter(provider, this.documents));
        this.proxy.$registerCallHierarchyProvider(callId, this.transformDocumentSelector(selector));
        return this.createDisposable(callId);
    }
    $provideRootDefinition(handle, resource, location, token) {
        return this.withAdapter(handle, call_hierarchy_1.CallHierarchyAdapter, adapter => adapter.provideRootDefinition(types_impl_1.URI.revive(resource), location, token), undefined);
    }
    $provideCallers(handle, definition, token) {
        return this.withAdapter(handle, call_hierarchy_1.CallHierarchyAdapter, adapter => adapter.provideCallers(definition, token), undefined);
    }
    $provideCallees(handle, definition, token) {
        return this.withAdapter(handle, call_hierarchy_1.CallHierarchyAdapter, adapter => adapter.provideCallees(definition, token), undefined);
    }
    $releaseCallHierarchy(handle, session) {
        return this.withAdapter(handle, call_hierarchy_1.CallHierarchyAdapter, adapter => adapter.releaseSession(session), false);
    }
    // ### Call Hierarchy Provider end
    // ### Type hierarchy Provider begin
    registerTypeHierarchyProvider(selector, provider) {
        const callId = this.addNewAdapter(new type_hierarchy_1.TypeHierarchyAdapter(provider, this.documents));
        this.proxy.$registerTypeHierarchyProvider(callId, this.transformDocumentSelector(selector));
        return this.createDisposable(callId);
    }
    $prepareTypeHierarchy(handle, resource, location, token) {
        return this.withAdapter(handle, type_hierarchy_1.TypeHierarchyAdapter, adapter => adapter.prepareSession(types_impl_1.URI.revive(resource), location, token), undefined);
    }
    $provideSuperTypes(handle, sessionId, itemId, token) {
        return this.withAdapter(handle, type_hierarchy_1.TypeHierarchyAdapter, adapter => adapter.provideSupertypes(sessionId, itemId, token), undefined);
    }
    $provideSubTypes(handle, sessionId, itemId, token) {
        return this.withAdapter(handle, type_hierarchy_1.TypeHierarchyAdapter, adapter => adapter.provideSubtypes(sessionId, itemId, token), undefined);
    }
    $releaseTypeHierarchy(handle, session) {
        return this.withAdapter(handle, type_hierarchy_1.TypeHierarchyAdapter, adapter => adapter.releaseSession(session), false);
    }
    // ### Type hierarchy Provider end
    // ### Linked Editing Range Provider begin
    registerLinkedEditingRangeProvider(selector, provider) {
        const handle = this.addNewAdapter(new linked_editing_range_1.LinkedEditingRangeAdapter(this.documents, provider));
        this.proxy.$registerLinkedEditingRangeProvider(handle, this.transformDocumentSelector(selector));
        return this.createDisposable(handle);
    }
    $provideLinkedEditingRanges(handle, resource, position, token) {
        return this.withAdapter(handle, linked_editing_range_1.LinkedEditingRangeAdapter, async (adapter) => adapter.provideRanges(types_impl_1.URI.revive(resource), position, token), undefined);
    }
    // ### Linked Editing Range Provider end
    // #region semantic coloring
    registerDocumentSemanticTokensProvider(selector, provider, legend, pluginInfo) {
        const eventHandle = (typeof provider.onDidChangeSemanticTokens === 'function' ? this.nextCallId() : undefined);
        const handle = this.addNewAdapter(new semantic_highlighting_1.DocumentSemanticTokensAdapter(this.documents, provider));
        this.proxy.$registerDocumentSemanticTokensProvider(handle, pluginInfo, this.transformDocumentSelector(selector), legend, eventHandle);
        let result = this.createDisposable(handle);
        if (eventHandle) {
            // eslint-disable-next-line no-unsanitized/method
            const subscription = provider.onDidChangeSemanticTokens(_ => this.proxy.$emitDocumentSemanticTokensEvent(eventHandle));
            result = types_impl_1.Disposable.from(result, subscription);
        }
        return result;
    }
    $provideDocumentSemanticTokens(handle, resource, previousResultId, token) {
        return this.withAdapter(handle, semantic_highlighting_1.DocumentSemanticTokensAdapter, adapter => adapter.provideDocumentSemanticTokens(types_impl_1.URI.revive(resource), previousResultId, token), null);
    }
    $releaseDocumentSemanticTokens(handle, semanticColoringResultId) {
        this.withAdapter(handle, semantic_highlighting_1.DocumentSemanticTokensAdapter, adapter => adapter.releaseDocumentSemanticColoring(semanticColoringResultId), undefined);
    }
    registerDocumentRangeSemanticTokensProvider(selector, provider, legend, pluginInfo) {
        const handle = this.addNewAdapter(new semantic_highlighting_1.DocumentRangeSemanticTokensAdapter(this.documents, provider));
        this.proxy.$registerDocumentRangeSemanticTokensProvider(handle, pluginInfo, this.transformDocumentSelector(selector), legend);
        return this.createDisposable(handle);
    }
    $provideDocumentRangeSemanticTokens(handle, resource, range, token) {
        return this.withAdapter(handle, semantic_highlighting_1.DocumentRangeSemanticTokensAdapter, adapter => adapter.provideDocumentRangeSemanticTokens(types_impl_1.URI.revive(resource), range, token), null);
    }
    createLanguageStatusItem(extension, id, selector) {
        var _a;
        const handle = this.statusItemHandlePool++;
        const proxy = this.proxy;
        const ids = this.statusItemIds;
        // enforce extension unique identifier
        const fullyQualifiedId = `${extension.model.id}/${id}`;
        if (ids.has(fullyQualifiedId)) {
            throw new Error(`LanguageStatusItem with id '${id}' ALREADY exists`);
        }
        ids.add(fullyQualifiedId);
        const data = {
            selector,
            id,
            name: (_a = extension.model.displayName) !== null && _a !== void 0 ? _a : extension.model.name,
            severity: types_impl_1.LanguageStatusSeverity.Information,
            command: undefined,
            text: '',
            detail: '',
            busy: false
        };
        let soonHandle;
        const commandDisposables = new disposable_1.DisposableCollection();
        const updateAsync = () => {
            soonHandle === null || soonHandle === void 0 ? void 0 : soonHandle.dispose();
            soonHandle = (0, disposable_1.disposableTimeout)(() => {
                var _a, _b, _c, _d;
                commandDisposables.dispose();
                commandDisposables.push({ dispose: () => { } }); // Mark disposable as undisposed.
                this.proxy.$setLanguageStatus(handle, {
                    id: fullyQualifiedId,
                    name: (_b = (_a = data.name) !== null && _a !== void 0 ? _a : extension.model.displayName) !== null && _b !== void 0 ? _b : extension.model.name,
                    source: (_c = extension.model.displayName) !== null && _c !== void 0 ? _c : extension.model.name,
                    selector: this.transformDocumentSelector(data.selector),
                    label: data.text,
                    detail: (_d = data.detail) !== null && _d !== void 0 ? _d : '',
                    severity: data.severity === types_impl_1.LanguageStatusSeverity.Error ? severity_1.Severity.Error : data.severity === types_impl_1.LanguageStatusSeverity.Warning ? severity_1.Severity.Warning : severity_1.Severity.Info,
                    command: data.command && this.commands.converter.toSafeCommand(data.command, commandDisposables),
                    accessibilityInfo: data.accessibilityInformation,
                    busy: data.busy
                });
            }, 0);
        };
        const result = {
            dispose() {
                commandDisposables.dispose();
                soonHandle === null || soonHandle === void 0 ? void 0 : soonHandle.dispose();
                proxy.$removeLanguageStatus(handle);
                ids.delete(fullyQualifiedId);
            },
            get id() {
                return data.id;
            },
            get name() {
                return data.name;
            },
            set name(value) {
                data.name = value;
                updateAsync();
            },
            get selector() {
                return data.selector;
            },
            set selector(value) {
                data.selector = value;
                updateAsync();
            },
            get text() {
                return data.text;
            },
            set text(value) {
                data.text = value;
                updateAsync();
            },
            get detail() {
                return data.detail;
            },
            set detail(value) {
                data.detail = value;
                updateAsync();
            },
            get severity() {
                return data.severity;
            },
            set severity(value) {
                data.severity = value;
                updateAsync();
            },
            get accessibilityInformation() {
                return data.accessibilityInformation;
            },
            set accessibilityInformation(value) {
                data.accessibilityInformation = value;
                updateAsync();
            },
            get command() {
                return data.command;
            },
            set command(value) {
                data.command = value;
                updateAsync();
            },
            get busy() {
                return data.busy;
            },
            set busy(value) {
                data.busy = value;
                updateAsync();
            }
        };
        updateAsync();
        return result;
    }
    // #endregion
    // region DocumentPaste
    /** @stubbed */
    registerDocumentPasteEditProvider(extension, selector, provider, metadata) {
        return types_impl_1.Disposable.NULL;
    }
}
exports.LanguagesExtImpl = LanguagesExtImpl;
function getPluginLabel(pluginInfo) {
    return pluginInfo.displayName || pluginInfo.name;
}


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/call-hierarchy.js":
/*!************************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/call-hierarchy.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallHierarchyAdapter = void 0;
const types = __webpack_require__(/*! ../types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const type_converters_1 = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
class CallHierarchyAdapter {
    constructor(provider, documents) {
        this.provider = provider;
        this.documents = documents;
        this.sessionIds = 0;
        this.cache = new Map();
    }
    async provideRootDefinition(resource, position, token) {
        const documentData = this.documents.getDocumentData(resource);
        if (!documentData) {
            return Promise.reject(new Error(`There is no document for ${resource}`));
        }
        const definition = await this.provider.prepareCallHierarchy(documentData.document, new types.Position(position.lineNumber, position.column), token);
        if (!definition) {
            return undefined;
        }
        const sessionId = (this.sessionIds++).toString(36);
        this.cache.set(sessionId, new Map());
        return Array.isArray(definition) ? definition.map(item => this.fromCallHierarchyItem(item, sessionId)) : [this.fromCallHierarchyItem(definition, sessionId)];
    }
    async provideCallers(definition, token) {
        const callers = await this.provider.provideCallHierarchyIncomingCalls(this.toCallHierarchyItem(definition), token);
        if (!callers) {
            return undefined;
        }
        return callers.map(item => this.fromCallHierarchyIncomingCall(item, definition._sessionId));
    }
    async provideCallees(definition, token) {
        const callees = await this.provider.provideCallHierarchyOutgoingCalls(this.toCallHierarchyItem(definition), token);
        if (!callees) {
            return undefined;
        }
        return callees.map(item => this.fromCallHierarchyOutgoingCall(item, definition._sessionId));
    }
    fromCallHierarchyItem(item, sessionId) {
        const sessionCache = this.cache.get(sessionId);
        const itemId = sessionCache.size.toString(36);
        const definition = {
            uri: item.uri,
            range: (0, type_converters_1.fromRange)(item.range),
            selectionRange: (0, type_converters_1.fromRange)(item.selectionRange),
            name: item.name,
            kind: type_converters_1.SymbolKind.fromSymbolKind(item.kind),
            tags: item.tags,
            _itemId: itemId,
            _sessionId: sessionId,
        };
        sessionCache.set(itemId, item);
        return definition;
    }
    toCallHierarchyItem(definition) {
        var _a;
        const cached = (_a = this.cache.get(definition._sessionId)) === null || _a === void 0 ? void 0 : _a.get(definition._itemId);
        if (!cached) {
            throw new Error(`Found no cached item corresponding to ${definition.name} in ${definition.uri.path} with ID ${definition.data}.`);
        }
        return cached;
    }
    fromCallHierarchyIncomingCall(caller, sessionId) {
        return {
            from: this.fromCallHierarchyItem(caller.from, sessionId),
            fromRanges: caller.fromRanges.map(r => (0, type_converters_1.fromRange)(r))
        };
    }
    fromCallHierarchyOutgoingCall(caller, sessionId) {
        return {
            to: this.fromCallHierarchyItem(caller.to, sessionId),
            fromRanges: caller.fromRanges.map(r => (0, type_converters_1.fromRange)(r)),
        };
    }
    releaseSession(session) {
        if (session !== undefined) {
            return Promise.resolve(this.cache.delete(session));
        }
        else {
            this.cache.clear();
            return Promise.resolve(true);
        }
    }
}
exports.CallHierarchyAdapter = CallHierarchyAdapter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/code-action.js":
/*!*********************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/code-action.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CodeActionAdapter = void 0;
const Converter = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const types_impl_1 = __webpack_require__(/*! ../types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../packages/core/lib/common/disposable.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../../packages/core/lib/common/index.js");
class CodeActionAdapter {
    constructor(provider, document, diagnostics, pluginId, commands) {
        this.provider = provider;
        this.document = document;
        this.diagnostics = diagnostics;
        this.pluginId = pluginId;
        this.commands = commands;
        this.cache = new Map();
        this.disposables = new Map();
        this.cacheId = 0;
    }
    async provideCodeAction(resource, rangeOrSelection, context, token) {
        const document = this.document.getDocumentData(resource);
        if (!document) {
            return Promise.reject(new Error(`There are no document for ${resource}`));
        }
        const doc = document.document;
        const ran = CodeActionAdapter._isSelection(rangeOrSelection)
            ? Converter.toSelection(rangeOrSelection)
            : Converter.toRange(rangeOrSelection);
        const allDiagnostics = [];
        for (const diagnostic of this.diagnostics.getDiagnostics(resource)) {
            if (ran.intersection(diagnostic.range)) {
                allDiagnostics.push(diagnostic);
            }
        }
        const codeActionContext = {
            diagnostics: allDiagnostics,
            only: context.only ? new types_impl_1.CodeActionKind(context.only) : undefined,
            triggerKind: Converter.toCodeActionTriggerKind(context.trigger)
        };
        const commandsOrActions = await this.provider.provideCodeActions(doc, ran, codeActionContext, token);
        if (!Array.isArray(commandsOrActions) || commandsOrActions.length === 0) {
            return undefined;
        }
        const result = [];
        for (const candidate of commandsOrActions) {
            if (!candidate) {
                continue;
            }
            // Cache candidates and created commands.
            const nextCacheId = this.nextCacheId();
            const toDispose = new disposable_1.DisposableCollection();
            this.cache.set(nextCacheId, candidate);
            this.disposables.set(nextCacheId, toDispose);
            if (CodeActionAdapter._isCommand(candidate)) {
                result.push({
                    cacheId: nextCacheId,
                    title: candidate.title || '',
                    command: this.commands.converter.toSafeCommand(candidate, toDispose)
                });
            }
            else {
                if (codeActionContext.only) {
                    if (!candidate.kind) {
                        /* eslint-disable-next-line max-len */
                        console.warn(`${this.pluginId} - Code actions of kind '${codeActionContext.only.value}' requested but returned code action does not have a 'kind'. Code action will be dropped. Please set 'CodeAction.kind'.`);
                    }
                    else if (!codeActionContext.only.contains(candidate.kind)) {
                        /* eslint-disable-next-line max-len */
                        console.warn(`${this.pluginId} - Code actions of kind '${codeActionContext.only.value}' requested but returned code action is of kind '${candidate.kind.value}'. Code action will be dropped. Please check 'CodeActionContext.only' to only return requested code action.`);
                    }
                }
                result.push({
                    cacheId: nextCacheId,
                    title: candidate.title,
                    command: this.commands.converter.toSafeCommand(candidate.command, toDispose),
                    diagnostics: candidate.diagnostics && candidate.diagnostics.map(Converter.convertDiagnosticToMarkerData),
                    edit: candidate.edit && Converter.fromWorkspaceEdit(candidate.edit),
                    kind: candidate.kind && candidate.kind.value,
                    disabled: candidate.disabled,
                    isPreferred: candidate.isPreferred
                });
            }
        }
        return result;
    }
    async releaseCodeActions(cacheIds) {
        cacheIds.forEach(id => {
            this.cache.delete(id);
            const toDispose = this.disposables.get(id);
            if (toDispose) {
                toDispose.dispose();
                this.disposables.delete(id);
            }
        });
    }
    async resolveCodeAction(cacheId, token) {
        if (!this.provider.resolveCodeAction) {
            return undefined;
        }
        // Code actions are only resolved if they are not legacy commands and don't have an edit property
        // https://code.visualstudio.com/api/references/vscode-api#CodeActionProvider
        const candidate = this.cache.get(cacheId);
        if (!candidate || CodeActionAdapter._isCommand(candidate) || candidate.edit) {
            return undefined;
        }
        const resolved = await this.provider.resolveCodeAction(candidate, token);
        return (resolved === null || resolved === void 0 ? void 0 : resolved.edit) && Converter.fromWorkspaceEdit(resolved.edit);
    }
    nextCacheId() {
        return this.cacheId++;
    }
    static _isCommand(arg) {
        return (0, common_1.isObject)(arg) && typeof arg.command === 'string';
    }
    static _isSelection(arg) {
        return (0, common_1.isObject)(arg)
            && typeof arg.selectionStartLineNumber === 'number'
            && typeof arg.selectionStartColumn === 'number'
            && typeof arg.positionLineNumber === 'number'
            && typeof arg.positionColumn === 'number';
    }
}
exports.CodeActionAdapter = CodeActionAdapter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/color.js":
/*!***************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/color.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorProviderAdapter = void 0;
const Converter = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
class ColorProviderAdapter {
    constructor(documents, provider) {
        this.documents = documents;
        this.provider = provider;
    }
    provideColors(resource, token) {
        const document = this.documents.getDocumentData(resource);
        if (!document) {
            return Promise.reject(new Error(`There are no document for ${resource}`));
        }
        const doc = document.document;
        return Promise.resolve(this.provider.provideDocumentColors(doc, token)).then(colors => {
            if (!Array.isArray(colors)) {
                return [];
            }
            const colorInfos = colors.map(colorInfo => ({
                color: Converter.fromColor(colorInfo.color),
                range: Converter.fromRange(colorInfo.range)
            }));
            return colorInfos;
        });
    }
    provideColorPresentations(resource, raw, token) {
        const document = this.documents.getDocumentData(resource);
        if (!document) {
            return Promise.reject(new Error(`There are no document for ${resource}`));
        }
        const doc = document.document;
        const range = Converter.toRange(raw.range);
        const color = Converter.toColor(raw.color);
        return Promise.resolve(this.provider.provideColorPresentations(color, { document: doc, range: range }, token)).then(value => {
            if (!Array.isArray(value)) {
                return [];
            }
            return value.map(Converter.fromColorPresentation);
        });
    }
}
exports.ColorProviderAdapter = ColorProviderAdapter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/completion.js":
/*!********************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/completion.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CompletionAdapter = void 0;
const types_impl_1 = __webpack_require__(/*! ../types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const Converter = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const plugin_api_rpc_model_1 = __webpack_require__(/*! ../../common/plugin-api-rpc-model */ "../../packages/plugin-ext/lib/common/plugin-api-rpc-model.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../packages/core/lib/common/disposable.js");
class CompletionAdapter {
    constructor(delegate, documents, commands) {
        this.delegate = delegate;
        this.documents = documents;
        this.commands = commands;
        this.cacheId = 0;
        this.cache = new Map();
        this.disposables = new Map();
    }
    provideCompletionItems(resource, position, context, token) {
        const document = this.documents.getDocumentData(resource);
        if (!document) {
            return Promise.reject(new Error(`There are no document for  ${resource}`));
        }
        const doc = document.document;
        const pos = Converter.toPosition(position);
        // The default insert/replace ranges. It's important to compute them
        // before asynchronously asking the provider for its results. See
        // https://github.com/microsoft/vscode/issues/83400#issuecomment-546851421
        const replacing = doc.getWordRangeAtPosition(pos) || new types_impl_1.Range(pos, pos);
        const inserting = replacing.with({ end: pos });
        return Promise.resolve(this.delegate.provideCompletionItems(doc, pos, token, context)).then(value => {
            const id = this.cacheId++;
            const toDispose = new disposable_1.DisposableCollection();
            this.disposables.set(id, toDispose);
            const result = {
                id,
                completions: [],
                defaultRange: {
                    insert: Converter.fromRange(inserting),
                    replace: Converter.fromRange(replacing)
                }
            };
            let list;
            if (!value) {
                return undefined;
            }
            else if (Array.isArray(value)) {
                list = new types_impl_1.CompletionList(value);
            }
            else {
                list = value;
                result.incomplete = list.isIncomplete;
            }
            for (let i = 0; i < list.items.length; i++) {
                const suggestion = this.convertCompletionItem(list.items[i], i, id, inserting, replacing);
                if (suggestion) {
                    result.completions.push(suggestion);
                }
            }
            this.cache.set(id, list.items);
            return result;
        });
    }
    async resolveCompletionItem(chainedId, token) {
        var _a;
        const [parentId, id] = chainedId;
        if (typeof this.delegate.resolveCompletionItem !== 'function') {
            return undefined;
        }
        const item = (_a = this.cache.get(parentId)) === null || _a === void 0 ? void 0 : _a[id];
        if (!item) {
            return undefined;
        }
        const resolvedItem = await this.delegate.resolveCompletionItem(item, token);
        if (!resolvedItem) {
            return undefined;
        }
        return this.convertCompletionItem(resolvedItem, id, parentId);
    }
    async releaseCompletionItems(id) {
        this.cache.delete(id);
        const toDispose = this.disposables.get(id);
        if (toDispose) {
            toDispose.dispose();
            this.disposables.delete(id);
        }
    }
    convertCompletionItem(item, id, parentId, defaultInserting, defaultReplacing) {
        var _a, _b;
        const itemLabel = typeof item.label === 'string' ? item.label : item.label.label;
        if (itemLabel.length === 0) {
            console.warn('Invalid Completion Item -> must have at least a label');
            return undefined;
        }
        const toDispose = this.disposables.get(parentId);
        if (!toDispose) {
            throw Error('DisposableCollection is missing...');
        }
        let insertText = itemLabel;
        let insertTextRules = item.keepWhitespace ? plugin_api_rpc_model_1.CompletionItemInsertTextRule.KeepWhitespace : 0;
        if (item.textEdit) {
            insertText = item.textEdit.newText;
        }
        else if (typeof item.insertText === 'string') {
            insertText = item.insertText;
        }
        else if (item.insertText instanceof types_impl_1.SnippetString) {
            insertText = item.insertText.value;
            insertTextRules |= plugin_api_rpc_model_1.CompletionItemInsertTextRule.InsertAsSnippet;
        }
        let range;
        const itemRange = ((_a = item.textEdit) === null || _a === void 0 ? void 0 : _a.range) || item.range;
        if (types_impl_1.Range.isRange(itemRange)) {
            range = Converter.fromRange(itemRange);
        }
        else if (itemRange && (!(defaultInserting === null || defaultInserting === void 0 ? void 0 : defaultInserting.isEqual(itemRange.inserting)) || !(defaultReplacing === null || defaultReplacing === void 0 ? void 0 : defaultReplacing.isEqual(itemRange.replacing)))) {
            range = {
                insert: Converter.fromRange(itemRange.inserting),
                replace: Converter.fromRange(itemRange.replacing)
            };
        }
        const tags = (!!((_b = item.tags) === null || _b === void 0 ? void 0 : _b.length) || item.deprecated === true)
            ? [types_impl_1.CompletionItemTag.Deprecated]
            : undefined;
        const documentation = typeof item.documentation !== 'undefined'
            ? Converter.fromMarkdown(item.documentation)
            : undefined;
        return {
            id,
            parentId,
            label: item.label,
            kind: Converter.fromCompletionItemKind(item.kind),
            detail: item.detail,
            documentation,
            filterText: item.filterText,
            sortText: item.sortText,
            preselect: item.preselect,
            insertText,
            insertTextRules,
            range,
            additionalTextEdits: item.additionalTextEdits && item.additionalTextEdits.map(Converter.fromTextEdit),
            command: this.commands.converter.toSafeCommand(item.command, toDispose),
            commitCharacters: item.commitCharacters,
            tags
        };
    }
    static hasResolveSupport(provider) {
        return typeof provider.resolveCompletionItem === 'function';
    }
}
exports.CompletionAdapter = CompletionAdapter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/declaration.js":
/*!*********************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/declaration.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeclarationAdapter = void 0;
const types = __webpack_require__(/*! ../types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const Converter = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const util_1 = __webpack_require__(/*! ./util */ "../../packages/plugin-ext/lib/plugin/languages/util.js");
class DeclarationAdapter {
    constructor(provider, documents) {
        this.provider = provider;
        this.documents = documents;
    }
    provideDeclaration(resource, position, token) {
        const documentData = this.documents.getDocumentData(resource);
        if (!documentData) {
            return Promise.reject(new Error(`There is no document for ${resource}`));
        }
        const document = documentData.document;
        const zeroBasedPosition = Converter.toPosition(position);
        return Promise.resolve(this.provider.provideDeclaration(document, zeroBasedPosition, token)).then(definition => {
            if (!definition) {
                return undefined;
            }
            if (definition instanceof types.Location) {
                return Converter.fromLocation(definition);
            }
            if ((0, util_1.isLocationArray)(definition)) {
                const locations = [];
                for (const location of definition) {
                    locations.push(Converter.fromLocation(location));
                }
                return locations;
            }
            if ((0, util_1.isDefinitionLinkArray)(definition)) {
                const definitionLinks = [];
                for (const definitionLink of definition) {
                    definitionLinks.push(Converter.fromDefinitionLink(definitionLink));
                }
                return definitionLinks;
            }
        });
    }
}
exports.DeclarationAdapter = DeclarationAdapter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/definition.js":
/*!********************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/definition.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefinitionAdapter = void 0;
const types = __webpack_require__(/*! ../types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const Converter = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const util_1 = __webpack_require__(/*! ./util */ "../../packages/plugin-ext/lib/plugin/languages/util.js");
class DefinitionAdapter {
    constructor(delegate, documents) {
        this.delegate = delegate;
        this.documents = documents;
    }
    provideDefinition(resource, position, token) {
        const documentData = this.documents.getDocumentData(resource);
        if (!documentData) {
            return Promise.reject(new Error(`There is no document for ${resource}`));
        }
        const document = documentData.document;
        const zeroBasedPosition = Converter.toPosition(position);
        return Promise.resolve(this.delegate.provideDefinition(document, zeroBasedPosition, token)).then(definition => {
            if (!definition) {
                return undefined;
            }
            if (definition instanceof types.Location) {
                return Converter.fromLocation(definition);
            }
            if ((0, util_1.isLocationArray)(definition)) {
                const locations = [];
                for (const location of definition) {
                    locations.push(Converter.fromLocation(location));
                }
                return locations;
            }
            if ((0, util_1.isDefinitionLinkArray)(definition)) {
                const definitionLinks = [];
                for (const definitionLink of definition) {
                    definitionLinks.push(Converter.fromDefinitionLink(definitionLink));
                }
                return definitionLinks;
            }
        });
    }
}
exports.DefinitionAdapter = DefinitionAdapter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/diagnostics.js":
/*!*********************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/diagnostics.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Diagnostics = exports.DiagnosticCollection = void 0;
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../packages/core/lib/common/event.js");
const type_converters_1 = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const types_impl_1 = __webpack_require__(/*! ../types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../../packages/core/shared/vscode-uri/index.js");
const uuid_1 = __webpack_require__(/*! uuid */ "../../node_modules/uuid/dist/esm-node/index.js");
class DiagnosticCollection {
    constructor(name, maxCountPerFile, proxy, onDidChangeDiagnosticsEmitter) {
        this.collectionName = name;
        this.diagnosticsLimitPerResource = maxCountPerFile;
        this.proxy = proxy;
        this.onDidChangeDiagnosticsEmitter = onDidChangeDiagnosticsEmitter;
        this.diagnostics = new Map();
        this.isDisposed = false;
        this.onDisposeCallback = undefined;
    }
    get name() {
        return this.collectionName;
    }
    set(arg, diagnostics) {
        this.ensureNotDisposed();
        if (arg instanceof vscode_uri_1.URI) {
            this.setDiagnosticsForUri(arg, diagnostics);
        }
        else if (!arg) {
            this.clear();
        }
        else if (arg instanceof Array) {
            this.setDiagnostics(arg);
        }
    }
    setDiagnosticsForUri(uri, diagnostics) {
        if (!diagnostics) {
            this.diagnostics.delete(uri.toString());
        }
        else {
            this.diagnostics.set(uri.toString(), diagnostics);
        }
        this.fireDiagnosticChangeEvent(uri);
        this.sendChangesToEditor([uri]);
    }
    setDiagnostics(entries) {
        const delta = [];
        // clear old diagnostics for given resources
        for (const [uri] of entries) {
            this.diagnostics.delete(uri.toString());
        }
        for (const [uri, diagnostics] of entries) {
            const uriString = uri.toString();
            if (!diagnostics) {
                // clear existed
                this.diagnostics.delete(uriString);
                delta.push(uri);
            }
            else {
                // merge with existed if any
                const existedDiagnostics = this.diagnostics.get(uriString);
                if (existedDiagnostics) {
                    existedDiagnostics.push(...diagnostics);
                }
                else {
                    this.diagnostics.set(uriString, diagnostics);
                }
            }
            if (delta.indexOf(uri) === -1) {
                delta.push(uri);
            }
        }
        this.fireDiagnosticChangeEvent(delta);
        this.sendChangesToEditor(delta);
    }
    delete(uri) {
        if (this.has(uri)) {
            this.fireDiagnosticChangeEvent(uri);
            this.diagnostics.delete(uri.toString());
            this.proxy.$changeDiagnostics(this.name, [[uri.toString(), []]]);
        }
    }
    clear() {
        this.ensureNotDisposed();
        this.fireDiagnosticChangeEvent(this.getAllResourcesUris());
        this.diagnostics.clear();
        this.proxy.$clearDiagnostics(this.name);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    forEach(callback, thisArg) {
        this.ensureNotDisposed();
        this.diagnostics.forEach((diagnostics, uriString) => {
            const uri = vscode_uri_1.URI.parse(uriString);
            callback.apply(thisArg, [uri, this.getDiagnosticsByUri(uri), this]);
        });
    }
    get(uri) {
        this.ensureNotDisposed();
        return this.getDiagnosticsByUri(uri);
    }
    has(uri) {
        this.ensureNotDisposed();
        return (this.diagnostics.get(uri.toString()) instanceof Array);
    }
    dispose() {
        if (!this.isDisposed) {
            if (this.onDisposeCallback) {
                this.onDisposeCallback();
            }
            this.clear();
            this.isDisposed = true;
        }
    }
    setOnDisposeCallback(onDisposeCallback) {
        this.onDisposeCallback = onDisposeCallback;
    }
    ensureNotDisposed() {
        if (this.isDisposed) {
            throw new Error('Diagnostic collection with name "' + this.name + '" is already disposed.');
        }
    }
    getAllResourcesUris() {
        const resourcesUris = [];
        this.diagnostics.forEach((diagnostics, uri) => resourcesUris.push(uri));
        return resourcesUris;
    }
    getDiagnosticsByUri(uri) {
        const diagnostics = this.diagnostics.get(uri.toString());
        return (diagnostics instanceof Array) ? Object.freeze(diagnostics) : undefined;
    }
    fireDiagnosticChangeEvent(arg) {
        this.onDidChangeDiagnosticsEmitter.fire({ uris: this.toUrisArray(arg) });
    }
    toUrisArray(arg) {
        if (arg instanceof Array) {
            if (arg.length === 0) {
                return [];
            }
            if (arg[0] instanceof vscode_uri_1.URI) {
                return arg;
            }
            else {
                const result = [];
                for (const uriString of arg) {
                    result.push(vscode_uri_1.URI.parse(uriString));
                }
                return result;
            }
        }
        else {
            if (arg instanceof vscode_uri_1.URI) {
                return [arg];
            }
            else {
                return [vscode_uri_1.URI.parse(arg)];
            }
        }
    }
    sendChangesToEditor(uris) {
        const markers = [];
        nextUri: for (const uri of uris) {
            const uriMarkers = [];
            const uriDiagnostics = this.diagnostics.get(uri.toString());
            if (uriDiagnostics) {
                if (uriDiagnostics.length > this.diagnosticsLimitPerResource) {
                    for (const severity of DiagnosticCollection.DIAGNOSTICS_PRIORITY) {
                        for (const diagnostic of uriDiagnostics) {
                            if (severity === diagnostic.severity) {
                                if (uriMarkers.push((0, type_converters_1.convertDiagnosticToMarkerData)(diagnostic)) + 1 === this.diagnosticsLimitPerResource) {
                                    const lastMarker = uriMarkers[uriMarkers.length - 1];
                                    uriMarkers.push({
                                        severity: types_impl_1.MarkerSeverity.Info,
                                        message: 'Limit of diagnostics is reached. ' + (uriDiagnostics.length - this.diagnosticsLimitPerResource) + ' items are hidden',
                                        startLineNumber: lastMarker.startLineNumber,
                                        startColumn: lastMarker.startColumn,
                                        endLineNumber: lastMarker.endLineNumber,
                                        endColumn: lastMarker.endColumn
                                    });
                                    markers.push([uri.toString(), uriMarkers]);
                                    continue nextUri;
                                }
                            }
                        }
                    }
                }
                else {
                    uriDiagnostics.forEach(diagnostic => uriMarkers.push((0, type_converters_1.convertDiagnosticToMarkerData)(diagnostic)));
                    markers.push([uri.toString(), uriMarkers]);
                }
            }
            else {
                markers.push([uri.toString(), []]);
            }
        }
        this.proxy.$changeDiagnostics(this.name, markers);
    }
}
exports.DiagnosticCollection = DiagnosticCollection;
DiagnosticCollection.DIAGNOSTICS_PRIORITY = [
    types_impl_1.DiagnosticSeverity.Error, types_impl_1.DiagnosticSeverity.Warning, types_impl_1.DiagnosticSeverity.Information, types_impl_1.DiagnosticSeverity.Hint
];
class Diagnostics {
    constructor(rpc) {
        this.diagnosticsChangedEmitter = new event_1.Emitter();
        this.onDidChangeDiagnostics = this.diagnosticsChangedEmitter.event;
        this.proxy = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.LANGUAGES_MAIN);
        this.diagnosticCollections = new Map();
    }
    getDiagnostics(resource) {
        if (resource) {
            return this.getAllDiagnosticsForResource(resource);
        }
        else {
            return this.getAllDiagnostics();
        }
    }
    createDiagnosticCollection(name) {
        if (!name) {
            do {
                name = Diagnostics.GENERATED_DIAGNOSTIC_COLLECTION_NAME_PREFIX + this.getNextId();
            } while (this.diagnosticCollections.has(name));
        }
        else if (this.diagnosticCollections.has(name)) {
            console.warn(`Diagnostic collection with name '${name}' already exist.`);
        }
        const diagnosticCollection = new DiagnosticCollection(name, Diagnostics.MAX_DIAGNOSTICS_PER_FILE, this.proxy, this.diagnosticsChangedEmitter);
        diagnosticCollection.setOnDisposeCallback(() => {
            this.diagnosticCollections.delete(name);
        });
        this.diagnosticCollections.set(name, diagnosticCollection);
        return diagnosticCollection;
    }
    getNextId() {
        return (0, uuid_1.v4)();
    }
    getAllDiagnosticsForResource(uri) {
        let result = [];
        this.diagnosticCollections.forEach(diagnosticCollection => {
            const diagnostics = diagnosticCollection.get(uri);
            if (diagnostics) {
                result = result.concat(...diagnostics);
            }
        });
        return result;
    }
    getAllDiagnostics() {
        const result = [];
        // Holds uri index in result array of tuples.
        const urisIndexes = new Map();
        let nextIndex = 0;
        this.diagnosticCollections.forEach(diagnosticsCollection => diagnosticsCollection.forEach((uri, diagnostics) => {
            let uriIndex = urisIndexes.get(uri.toString());
            if (uriIndex === undefined) {
                uriIndex = nextIndex++;
                urisIndexes.set(uri.toString(), uriIndex);
                result.push([uri, [...diagnostics]]);
            }
            else {
                result[uriIndex][1] = result[uriIndex][1].concat(...diagnostics);
            }
        }));
        return result;
    }
}
exports.Diagnostics = Diagnostics;
Diagnostics.MAX_DIAGNOSTICS_PER_FILE = 1000;
Diagnostics.GENERATED_DIAGNOSTIC_COLLECTION_NAME_PREFIX = '_generated_diagnostic_collection_name_#';


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/document-drop-edit.js":
/*!****************************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/document-drop-edit.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentDropEditAdapter = void 0;
const Converter = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../../packages/core/shared/vscode-uri/index.js");
const os = __webpack_require__(/*! os */ "os");
const path = __webpack_require__(/*! path */ "path");
class DocumentDropEditAdapter {
    constructor(provider, documents, fileSystem) {
        this.provider = provider;
        this.documents = documents;
        this.fileSystem = fileSystem;
    }
    async provideDocumentDropEdits(resource, position, dataTransfer, token) {
        return this.provider.provideDocumentDropEdits(this.documents.getDocument(resource), Converter.toPosition(position), Converter.DataTransfer.toDataTransfer(dataTransfer, itemId => this.resolveFileData(itemId)), token);
    }
    async resolveFileData(itemId) {
        const filePath = vscode_uri_1.URI.file(path.resolve(os.tmpdir(), 'theia_upload', itemId));
        return this.fileSystem.fileSystem.readFile(filePath);
    }
}
exports.DocumentDropEditAdapter = DocumentDropEditAdapter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/document-formatting.js":
/*!*****************************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/document-formatting.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentFormattingAdapter = void 0;
const Converter = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
class DocumentFormattingAdapter {
    constructor(provider, documents) {
        this.provider = provider;
        this.documents = documents;
    }
    provideDocumentFormattingEdits(resource, options, token) {
        const document = this.documents.getDocumentData(resource);
        if (!document) {
            return Promise.reject(new Error(`There are no document for ${resource}`));
        }
        const doc = document.document;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return Promise.resolve(this.provider.provideDocumentFormattingEdits(doc, options, token)).then(value => {
            if (Array.isArray(value)) {
                return value.map(Converter.fromTextEdit);
            }
            return undefined;
        });
    }
}
exports.DocumentFormattingAdapter = DocumentFormattingAdapter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/document-highlight.js":
/*!****************************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/document-highlight.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentHighlightAdapter = void 0;
const types = __webpack_require__(/*! ../types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const Converter = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
class DocumentHighlightAdapter {
    constructor(provider, documents) {
        this.provider = provider;
        this.documents = documents;
    }
    provideDocumentHighlights(resource, position, token) {
        const documentData = this.documents.getDocumentData(resource);
        if (!documentData) {
            return Promise.reject(new Error(`There is no document for ${resource}`));
        }
        const document = documentData.document;
        const zeroBasedPosition = Converter.toPosition(position);
        return Promise.resolve(this.provider.provideDocumentHighlights(document, zeroBasedPosition, token)).then(documentHighlights => {
            if (!documentHighlights) {
                return undefined;
            }
            if (this.isDocumentHighlightArray(documentHighlights)) {
                const highlights = [];
                for (const highlight of documentHighlights) {
                    highlights.push(Converter.fromDocumentHighlight(highlight));
                }
                return highlights;
            }
        });
    }
    isDocumentHighlightArray(array) {
        return Array.isArray(array) && array.length > 0 && array[0] instanceof types.DocumentHighlight;
    }
}
exports.DocumentHighlightAdapter = DocumentHighlightAdapter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/evaluatable-expression.js":
/*!********************************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/evaluatable-expression.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 STMicroelectronics and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EvaluatableExpressionAdapter = void 0;
const Converter = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
class EvaluatableExpressionAdapter {
    constructor(provider, documents) {
        this.provider = provider;
        this.documents = documents;
    }
    async provideEvaluatableExpression(resource, position, token) {
        const documentData = this.documents.getDocumentData(resource);
        if (!documentData) {
            return Promise.reject(new Error(`There is no document data for ${resource}`));
        }
        const document = documentData.document;
        const pos = Converter.toPosition(position);
        return Promise.resolve(this.provider.provideEvaluatableExpression(document, pos, token)).then(expression => {
            if (!expression) {
                return undefined;
            }
            return Converter.fromEvaluatableExpression(expression);
        });
    }
}
exports.EvaluatableExpressionAdapter = EvaluatableExpressionAdapter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/folding.js":
/*!*****************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/folding.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FoldingProviderAdapter = void 0;
const Converter = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
class FoldingProviderAdapter {
    constructor(provider, documents) {
        this.provider = provider;
        this.documents = documents;
    }
    provideFoldingRanges(resource, context, token) {
        const document = this.documents.getDocumentData(resource);
        if (!document) {
            return Promise.reject(new Error(`There are no document for ${resource}`));
        }
        const doc = document.document;
        return Promise.resolve(this.provider.provideFoldingRanges(doc, context, token)).then(ranges => {
            if (!Array.isArray(ranges)) {
                return undefined;
            }
            return ranges.map(Converter.fromFoldingRange);
        });
    }
}
exports.FoldingProviderAdapter = FoldingProviderAdapter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/hover.js":
/*!***************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/hover.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HoverAdapter = void 0;
const Converter = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const types_impl_1 = __webpack_require__(/*! ../types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
class HoverAdapter {
    constructor(provider, documents) {
        this.provider = provider;
        this.documents = documents;
    }
    provideHover(resource, position, token) {
        const document = this.documents.getDocumentData(resource);
        if (!document) {
            return Promise.reject(new Error(`There are no document for ${resource}`));
        }
        const doc = document.document;
        const pos = Converter.toPosition(position);
        return Promise.resolve(this.provider.provideHover(doc, pos, token)).then(value => {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (!value || !Array.isArray(value.contents) || value.contents.length === 0) {
                return undefined;
            }
            if (!value.range) {
                value.range = doc.getWordRangeAtPosition(pos);
            }
            if (!value.range) {
                value.range = new types_impl_1.Range(pos, pos);
            }
            return Converter.fromHover(value);
        });
    }
}
exports.HoverAdapter = HoverAdapter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/implementation.js":
/*!************************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/implementation.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImplementationAdapter = void 0;
const types = __webpack_require__(/*! ../types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const Converter = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const util_1 = __webpack_require__(/*! ./util */ "../../packages/plugin-ext/lib/plugin/languages/util.js");
class ImplementationAdapter {
    constructor(provider, documents) {
        this.provider = provider;
        this.documents = documents;
    }
    provideImplementation(resource, position, token) {
        const documentData = this.documents.getDocumentData(resource);
        if (!documentData) {
            return Promise.reject(new Error(`There is no document for ${resource}`));
        }
        const document = documentData.document;
        const zeroBasedPosition = Converter.toPosition(position);
        return Promise.resolve(this.provider.provideImplementation(document, zeroBasedPosition, token)).then(definition => {
            if (!definition) {
                return undefined;
            }
            if (definition instanceof types.Location) {
                return Converter.fromLocation(definition);
            }
            if ((0, util_1.isLocationArray)(definition)) {
                const locations = [];
                for (const location of definition) {
                    locations.push(Converter.fromLocation(location));
                }
                return locations;
            }
            if ((0, util_1.isDefinitionLinkArray)(definition)) {
                const definitionLinks = [];
                for (const definitionLink of definition) {
                    definitionLinks.push(Converter.fromDefinitionLink(definitionLink));
                }
                return definitionLinks;
            }
        });
    }
}
exports.ImplementationAdapter = ImplementationAdapter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/inlay-hints.js":
/*!*********************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/inlay-hints.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlayHintsAdapter = void 0;
const Converter = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const cache_1 = __webpack_require__(/*! ../../common/cache */ "../../packages/plugin-ext/lib/common/cache.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../packages/core/lib/common/disposable.js");
const util_1 = __webpack_require__(/*! ./util */ "../../packages/plugin-ext/lib/plugin/languages/util.js");
class InlayHintsAdapter {
    constructor(provider, documents, commands) {
        this.provider = provider;
        this.documents = documents;
        this.commands = commands;
        this.cache = new cache_1.Cache('InlayHints');
        this.disposables = new Map();
    }
    async provideInlayHints(resource, range, token) {
        const documentData = this.documents.getDocumentData(resource);
        if (!documentData) {
            return Promise.reject(new Error(`There are no documents for ${resource}`));
        }
        const doc = documentData.document;
        const ran = Converter.toRange(range);
        const hints = await this.provider.provideInlayHints(doc, ran, token);
        if (!Array.isArray(hints) || hints.length === 0) {
            return undefined;
        }
        if (token.isCancellationRequested) {
            return undefined;
        }
        const pid = this.cache.add(hints);
        this.disposables.set(pid, new disposable_1.DisposableCollection());
        const result = { hints: [], cacheId: pid };
        for (let i = 0; i < hints.length; i++) {
            if (this.isValidInlayHint(hints[i], ran)) {
                result.hints.push(this.convertInlayHint(hints[i], [pid, i]));
            }
        }
        return result;
    }
    async resolveInlayHint(id, token) {
        if (typeof this.provider.resolveInlayHint !== 'function') {
            return undefined;
        }
        const item = this.cache.get(...id);
        if (!item) {
            return undefined;
        }
        const hint = await this.provider.resolveInlayHint(item, token);
        if (!hint) {
            return undefined;
        }
        if (!this.isValidInlayHint(hint)) {
            return undefined;
        }
        return this.convertInlayHint(hint, id);
    }
    isValidInlayHint(hint, range) {
        if (hint.label.length === 0 || Array.isArray(hint.label) && hint.label.every(part => part.value.length === 0)) {
            return false;
        }
        if (range && !range.contains(hint.position)) {
            return false;
        }
        return true;
    }
    convertInlayHint(hint, id) {
        const disposables = this.disposables.get(id[0]);
        if (!disposables) {
            throw Error('DisposableCollection is missing...');
        }
        const result = {
            label: '',
            cacheId: id,
            tooltip: hint.tooltip,
            position: Converter.fromPosition(hint.position),
            textEdits: hint.textEdits && hint.textEdits.map(Converter.fromTextEdit),
            kind: hint.kind && Converter.InlayHintKind.from(hint.kind),
            paddingLeft: hint.paddingLeft,
            paddingRight: hint.paddingRight,
        };
        if (typeof hint.label === 'string') {
            result.label = hint.label;
        }
        else {
            result.label = hint.label.map(part => {
                const partResult = { label: part.value };
                if (part.tooltip) {
                    partResult.tooltip = typeof partResult === 'string' ? part.tooltip : Converter.fromMarkdown(part.tooltip);
                }
                if ((0, util_1.isLocationArray)(part.location)) {
                    partResult.location = Converter.fromLocation(part.location);
                }
                if (part.command) {
                    partResult.command = this.commands.converter.toSafeCommand(part.command, disposables);
                }
                return partResult;
            });
        }
        return result;
    }
    async releaseHints(id) {
        var _a;
        (_a = this.disposables.get(id)) === null || _a === void 0 ? void 0 : _a.dispose();
        this.disposables.delete(id);
        this.cache.delete(id);
    }
}
exports.InlayHintsAdapter = InlayHintsAdapter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/inline-completion.js":
/*!***************************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/inline-completion.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlineCompletionAdapter = exports.InlineCompletionAdapterBase = void 0;
const Converter = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const reference_map_1 = __webpack_require__(/*! ../../common/reference-map */ "../../packages/plugin-ext/lib/common/reference-map.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../packages/core/lib/common/disposable.js");
const types_impl_1 = __webpack_require__(/*! ../../plugin/types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const plugin_api_rpc_model_1 = __webpack_require__(/*! ../../common/plugin-api-rpc-model */ "../../packages/plugin-ext/lib/common/plugin-api-rpc-model.js");
class InlineCompletionAdapterBase {
    async provideInlineCompletions(_resource, _position, _context, _token) {
        return undefined;
    }
    disposeCompletions(pid) { return; }
    ;
}
exports.InlineCompletionAdapterBase = InlineCompletionAdapterBase;
class InlineCompletionAdapter extends InlineCompletionAdapterBase {
    constructor(documents, provider, commands) {
        super();
        this.documents = documents;
        this.provider = provider;
        this.commands = commands;
        this.references = new reference_map_1.ReferenceMap();
        this.languageTriggerKindToVSCodeTriggerKind = {
            [plugin_api_rpc_model_1.InlineCompletionTriggerKind.Automatic]: types_impl_1.InlineCompletionTriggerKind.Automatic,
            [plugin_api_rpc_model_1.InlineCompletionTriggerKind.Explicit]: types_impl_1.InlineCompletionTriggerKind.Invoke,
        };
    }
    async provideInlineCompletions(resource, position, context, token) {
        const doc = this.documents.getDocument(resource);
        const pos = Converter.toPosition(position);
        const result = await this.provider.provideInlineCompletionItems(doc, pos, {
            selectedCompletionInfo: context.selectedSuggestionInfo
                ? {
                    range: Converter.toRange(context.selectedSuggestionInfo.range),
                    text: context.selectedSuggestionInfo.text
                }
                : undefined,
            triggerKind: this.languageTriggerKindToVSCodeTriggerKind[context.triggerKind]
        }, token);
        if (!result || token.isCancellationRequested) {
            return undefined;
        }
        const normalizedResult = Array.isArray(result) ? result : result.items;
        let disposableCollection = undefined;
        const pid = this.references.createReferenceId({
            dispose() {
                disposableCollection === null || disposableCollection === void 0 ? void 0 : disposableCollection.dispose();
            },
            items: normalizedResult
        });
        return {
            pid,
            items: normalizedResult.map((item, idx) => {
                let command = undefined;
                if (item.command) {
                    if (!disposableCollection) {
                        disposableCollection = new disposable_1.DisposableCollection();
                    }
                    command = this.commands.converter.toSafeCommand(item.command, disposableCollection);
                }
                const insertText = item.insertText;
                return ({
                    insertText: typeof insertText === 'string' ? insertText : { snippet: insertText.value },
                    filterText: item.filterText,
                    range: item.range ? Converter.fromRange(item.range) : undefined,
                    command,
                    idx: idx
                });
            })
        };
    }
    disposeCompletions(pid) {
        const data = this.references.disposeReferenceId(pid);
        data === null || data === void 0 ? void 0 : data.dispose();
    }
}
exports.InlineCompletionAdapter = InlineCompletionAdapter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/inline-values.js":
/*!***********************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/inline-values.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 STMicroelectronics and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlineValuesAdapter = void 0;
const Converter = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
class InlineValuesAdapter {
    constructor(provider, documents) {
        this.provider = provider;
        this.documents = documents;
    }
    async provideInlineValues(resource, range, context, token) {
        const documentData = this.documents.getDocumentData(resource);
        if (!documentData) {
            return Promise.reject(new Error(`There is no document data for ${resource}`));
        }
        const document = documentData.document;
        const viewPort = Converter.toRange(range);
        const ctx = Converter.toInlineValueContext(context);
        return Promise.resolve(this.provider.provideInlineValues(document, viewPort, ctx, token)).then(inlineValue => {
            if (!inlineValue) {
                return undefined;
            }
            if (Array.isArray(inlineValue)) {
                return inlineValue.map(iv => Converter.fromInlineValue(iv));
            }
            return undefined;
        });
    }
}
exports.InlineValuesAdapter = InlineValuesAdapter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/lens.js":
/*!**************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/lens.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CodeLensAdapter = void 0;
const Converter = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const object_identifier_1 = __webpack_require__(/*! ../../common/object-identifier */ "../../packages/plugin-ext/lib/common/object-identifier.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../packages/core/lib/common/disposable.js");
/** Adapts the calls from main to extension thread for providing/resolving the code lenses. */
class CodeLensAdapter {
    constructor(provider, documents, commands) {
        this.provider = provider;
        this.documents = documents;
        this.commands = commands;
        this.cacheId = 0;
        this.cache = new Map();
        this.disposables = new Map();
    }
    provideCodeLenses(resource, token) {
        const document = this.documents.getDocumentData(resource);
        if (!document) {
            return Promise.reject(new Error(`There is no document for ${resource}`));
        }
        const doc = document.document;
        return Promise.resolve(this.provider.provideCodeLenses(doc, token)).then(lenses => {
            if (Array.isArray(lenses)) {
                return lenses.map(lens => {
                    const cacheId = this.cacheId++;
                    const toDispose = new disposable_1.DisposableCollection();
                    const lensSymbol = object_identifier_1.ObjectIdentifier.mixin({
                        range: Converter.fromRange(lens.range),
                        command: this.commands.converter.toSafeCommand(lens.command, toDispose)
                    }, cacheId);
                    this.cache.set(cacheId, lens);
                    this.disposables.set(cacheId, toDispose);
                    return lensSymbol;
                });
            }
            return undefined;
        });
    }
    async resolveCodeLens(resource, symbol, token) {
        const cacheId = object_identifier_1.ObjectIdentifier.of(symbol);
        const lens = this.cache.get(cacheId);
        if (!lens) {
            return undefined;
        }
        let newLens;
        if (typeof this.provider.resolveCodeLens === 'function' && !lens.isResolved) {
            newLens = await this.provider.resolveCodeLens(lens, token);
            if (token.isCancellationRequested) {
                return undefined;
            }
        }
        newLens = newLens || lens;
        const disposables = this.disposables.get(cacheId);
        if (!disposables) {
            // already been disposed of
            return undefined;
        }
        symbol.command = this.commands.converter.toSafeCommand(newLens.command ? newLens.command : CodeLensAdapter.BAD_CMD, disposables);
        return symbol;
    }
    releaseCodeLenses(ids) {
        ids.forEach(id => {
            this.cache.delete(id);
            const toDispose = this.disposables.get(id);
            if (toDispose) {
                toDispose.dispose();
                this.disposables.delete(id);
            }
        });
    }
}
exports.CodeLensAdapter = CodeLensAdapter;
CodeLensAdapter.BAD_CMD = { command: 'missing', title: '<<MISSING COMMAND>>' };


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/link-provider.js":
/*!***********************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/link-provider.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinkProviderAdapter = void 0;
const Converter = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const object_identifier_1 = __webpack_require__(/*! ../../common/object-identifier */ "../../packages/plugin-ext/lib/common/object-identifier.js");
class LinkProviderAdapter {
    constructor(provider, documents) {
        this.provider = provider;
        this.documents = documents;
        this.cacheId = 0;
        this.cache = new Map();
    }
    provideLinks(resource, token) {
        const document = this.documents.getDocumentData(resource);
        if (!document) {
            return Promise.reject(new Error(`There is no document for ${resource}`));
        }
        const doc = document.document;
        return Promise.resolve(this.provider.provideDocumentLinks(doc, token)).then(links => {
            if (!Array.isArray(links)) {
                return undefined;
            }
            const result = [];
            for (const link of links) {
                const data = Converter.DocumentLink.from(link);
                const id = this.cacheId++;
                object_identifier_1.ObjectIdentifier.mixin(data, id);
                this.cache.set(id, link);
                result.push(data);
            }
            return result;
        });
    }
    resolveLink(link, token) {
        if (typeof this.provider.resolveDocumentLink !== 'function') {
            return Promise.resolve(undefined);
        }
        const id = object_identifier_1.ObjectIdentifier.of(link);
        const item = this.cache.get(id);
        if (!item) {
            return Promise.resolve(undefined);
        }
        return Promise.resolve(this.provider.resolveDocumentLink(item, token)).then(value => {
            if (value) {
                return Converter.DocumentLink.from(value);
            }
            return undefined;
        });
    }
    releaseDocumentLinks(ids) {
        ids.forEach(id => {
            this.cache.delete(id);
        });
    }
}
exports.LinkProviderAdapter = LinkProviderAdapter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/linked-editing-range.js":
/*!******************************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/linked-editing-range.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinkedEditingRangeAdapter = void 0;
const arrays_1 = __webpack_require__(/*! ../../common/arrays */ "../../packages/plugin-ext/lib/common/arrays.js");
const type_converters_1 = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const languages_utils_1 = __webpack_require__(/*! ../languages-utils */ "../../packages/plugin-ext/lib/plugin/languages-utils.js");
class LinkedEditingRangeAdapter {
    constructor(documents, provider) {
        this.documents = documents;
        this.provider = provider;
    }
    async provideRanges(resource, position, token) {
        const doc = this.documents.getDocument(resource);
        const pos = (0, type_converters_1.toPosition)(position);
        const value = await this.provider.provideLinkedEditingRanges(doc, pos, token);
        if (value && Array.isArray(value.ranges)) {
            return {
                ranges: (0, arrays_1.coalesce)(value.ranges.map(r => (0, type_converters_1.fromRange)(r))),
                wordPattern: (0, languages_utils_1.serializeRegExp)(value.wordPattern)
            };
        }
        return undefined;
    }
}
exports.LinkedEditingRangeAdapter = LinkedEditingRangeAdapter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/on-type-formatting.js":
/*!****************************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/on-type-formatting.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OnTypeFormattingAdapter = void 0;
const Converter = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
class OnTypeFormattingAdapter {
    constructor(provider, documents) {
        this.provider = provider;
        this.documents = documents;
    }
    provideOnTypeFormattingEdits(resource, position, ch, options, token) {
        const document = this.documents.getDocumentData(resource);
        if (!document) {
            return Promise.reject(new Error(`There are no document for ${resource}`));
        }
        const doc = document.document;
        const pos = Converter.toPosition(position);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return Promise.resolve(this.provider.provideOnTypeFormattingEdits(doc, pos, ch, options, token)).then(value => {
            if (Array.isArray(value)) {
                return value.map(Converter.fromTextEdit);
            }
            return undefined;
        });
    }
}
exports.OnTypeFormattingAdapter = OnTypeFormattingAdapter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/outline.js":
/*!*****************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/outline.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OutlineAdapter = void 0;
const Converter = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const types = __webpack_require__(/*! ../types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
/** Adapts the calls from main to extension thread for providing the document symbols. */
class OutlineAdapter {
    constructor(documents, provider) {
        this.documents = documents;
        this.provider = provider;
    }
    provideDocumentSymbols(resource, token) {
        const document = this.documents.getDocumentData(resource);
        if (!document) {
            return Promise.reject(new Error(`There is no document for ${resource}`));
        }
        const doc = document.document;
        return Promise.resolve(this.provider.provideDocumentSymbols(doc, token)).then(value => {
            if (!value || value.length === 0) {
                return undefined;
            }
            if (value[0] instanceof types.DocumentSymbol) {
                return value.map(Converter.fromDocumentSymbol);
            }
            else {
                return OutlineAdapter.asDocumentSymbolTree(resource, value);
            }
        });
    }
    static asDocumentSymbolTree(resource, infos) {
        // first sort by start (and end) and then loop over all elements
        // and build a tree based on containment.
        infos = infos.slice(0).sort((a, b) => {
            let r = a.location.range.start.compareTo(b.location.range.start);
            if (r === 0) {
                r = b.location.range.end.compareTo(a.location.range.end);
            }
            return r;
        });
        const res = [];
        const parentStack = [];
        for (const info of infos) {
            const element = {
                name: info.name,
                detail: '',
                kind: Converter.SymbolKind.fromSymbolKind(info.kind),
                containerName: info.containerName,
                range: Converter.fromRange(info.location.range),
                selectionRange: Converter.fromRange(info.location.range),
                children: [],
                tags: info.tags && info.tags.length > 0 ? info.tags.map(Converter.fromSymbolTag) : [],
            };
            while (true) {
                if (parentStack.length === 0) {
                    parentStack.push(element);
                    res.push(element);
                    break;
                }
                const parent = parentStack[parentStack.length - 1];
                if (OutlineAdapter.containsRange(parent.range, element.range) && !OutlineAdapter.equalsRange(parent.range, element.range)) {
                    parent.children.push(element);
                    parentStack.push(element);
                    break;
                }
                parentStack.pop();
            }
        }
        return res;
    }
    /**
     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
     */
    static containsRange(range, otherRange) {
        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
            return false;
        }
        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
            return false;
        }
        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {
            return false;
        }
        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {
            return false;
        }
        return true;
    }
    /**
     * Test if range `a` equals `b`.
     */
    static equalsRange(a, b) {
        return (!!a &&
            !!b &&
            a.startLineNumber === b.startLineNumber &&
            a.startColumn === b.startColumn &&
            a.endLineNumber === b.endLineNumber &&
            a.endColumn === b.endColumn);
    }
}
exports.OutlineAdapter = OutlineAdapter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/range-formatting.js":
/*!**************************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/range-formatting.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RangeFormattingAdapter = void 0;
const Converter = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
class RangeFormattingAdapter {
    constructor(provider, documents) {
        this.provider = provider;
        this.documents = documents;
    }
    provideDocumentRangeFormattingEdits(resource, range, options, token) {
        const document = this.documents.getDocumentData(resource);
        if (!document) {
            return Promise.reject(new Error(`There are no document for ${resource}`));
        }
        const doc = document.document;
        const ran = Converter.toRange(range);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return Promise.resolve(this.provider.provideDocumentRangeFormattingEdits(doc, ran, options, token)).then(value => {
            if (Array.isArray(value)) {
                return value.map(Converter.fromTextEdit);
            }
            return undefined;
        });
    }
}
exports.RangeFormattingAdapter = RangeFormattingAdapter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/reference.js":
/*!*******************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/reference.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReferenceAdapter = void 0;
const Converter = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const util_1 = __webpack_require__(/*! ./util */ "../../packages/plugin-ext/lib/plugin/languages/util.js");
class ReferenceAdapter {
    constructor(provider, documents) {
        this.provider = provider;
        this.documents = documents;
    }
    provideReferences(resource, position, context, token) {
        const documentData = this.documents.getDocumentData(resource);
        if (!documentData) {
            return Promise.reject(new Error(`There is no document for ${resource}`));
        }
        const document = documentData.document;
        const zeroBasedPosition = Converter.toPosition(position);
        return Promise.resolve(this.provider.provideReferences(document, zeroBasedPosition, context, token)).then(reference => {
            if (!reference) {
                return undefined;
            }
            if ((0, util_1.isLocationArray)(reference)) {
                const locations = [];
                for (const location of reference) {
                    locations.push(Converter.fromLocation(location));
                }
                return locations;
            }
        });
    }
}
exports.ReferenceAdapter = ReferenceAdapter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/rename.js":
/*!****************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/rename.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RenameAdapter = void 0;
const Converter = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const types_impl_1 = __webpack_require__(/*! ../types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const types_1 = __webpack_require__(/*! ../../common/types */ "../../packages/plugin-ext/lib/common/types.js");
class RenameAdapter {
    constructor(provider, documents) {
        this.provider = provider;
        this.documents = documents;
    }
    static supportsResolving(provider) {
        return typeof provider.prepareRename === 'function';
    }
    provideRenameEdits(resource, position, newName, token) {
        const document = this.documents.getDocumentData(resource);
        if (!document) {
            return Promise.reject(new Error(`There is no document for ${resource}`));
        }
        const doc = document.document;
        const pos = Converter.toPosition(position);
        return Promise.resolve(this.provider.provideRenameEdits(doc, pos, newName, token)).then(value => {
            if (!value) {
                return undefined;
            }
            return Converter.fromWorkspaceEdit(value);
        }, error => {
            const rejectReason = RenameAdapter.asMessage(error);
            if (rejectReason) {
                return {
                    rejectReason,
                    edits: []
                };
            }
            else {
                return Promise.reject(error);
            }
        });
    }
    resolveRenameLocation(resource, position, token) {
        if (typeof this.provider.prepareRename !== 'function') {
            return Promise.resolve(undefined);
        }
        const document = this.documents.getDocumentData(resource);
        if (!document) {
            return Promise.reject(new Error(`There is no document for ${resource}`));
        }
        const doc = document.document;
        const pos = Converter.toPosition(position);
        return Promise.resolve(this.provider.prepareRename(doc, pos, token)).then(rangeOrLocation => {
            let range;
            let text;
            if (rangeOrLocation && types_impl_1.Range.isRange(rangeOrLocation)) {
                range = rangeOrLocation;
                text = doc.getText(rangeOrLocation);
            }
            else if (rangeOrLocation && (0, types_1.isObject)(rangeOrLocation)) {
                range = rangeOrLocation.range;
                text = rangeOrLocation.placeholder;
            }
            if (!range) {
                return undefined;
            }
            if (range.start.line > pos.line || range.end.line < pos.line) {
                console.warn('INVALID rename location: position line must be within range start/end lines');
                return undefined;
            }
            return {
                range: Converter.fromRange(range),
                text: text
            };
        }, error => {
            const rejectReason = RenameAdapter.asMessage(error);
            if (rejectReason) {
                return Promise.resolve({
                    rejectReason,
                    range: undefined,
                    text: undefined
                });
            }
            else {
                return Promise.reject(error);
            }
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static asMessage(err) {
        if (typeof err === 'string') {
            return err;
        }
        else if (err instanceof Error && typeof err.message === 'string') {
            return err.message;
        }
        else {
            return undefined;
        }
    }
}
exports.RenameAdapter = RenameAdapter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/selection-range.js":
/*!*************************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/selection-range.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectionRangeProviderAdapter = void 0;
const Converter = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
class SelectionRangeProviderAdapter {
    constructor(provider, documents) {
        this.provider = provider;
        this.documents = documents;
    }
    provideSelectionRanges(resource, position, token) {
        const documentData = this.documents.getDocumentData(resource);
        if (!documentData) {
            return Promise.reject(new Error(`There are no document for  ${resource}`));
        }
        const document = documentData.document;
        const positions = position.map(pos => Converter.toPosition(pos));
        return Promise.resolve(this.provider.provideSelectionRanges(document, positions, token)).then(allProviderRanges => {
            if (!Array.isArray(allProviderRanges) || allProviderRanges.length === 0) {
                return [];
            }
            if (allProviderRanges.length !== positions.length) {
                return [];
            }
            const allResults = [];
            for (let i = 0; i < positions.length; i++) {
                const oneResult = [];
                allResults.push(oneResult);
                let last = positions[i];
                let selectionRange = allProviderRanges[i];
                while (true) {
                    if (!selectionRange.range.contains(last)) {
                        return Promise.reject(new Error('INVALID selection range, must contain the previous range'));
                    }
                    oneResult.push(Converter.fromSelectionRange(selectionRange));
                    if (!selectionRange.parent) {
                        break;
                    }
                    last = selectionRange.range;
                    selectionRange = selectionRange.parent;
                }
            }
            return allResults;
        });
    }
}
exports.SelectionRangeProviderAdapter = SelectionRangeProviderAdapter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/semantic-highlighting.js":
/*!*******************************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/semantic-highlighting.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentRangeSemanticTokensAdapter = exports.DocumentSemanticTokensAdapter = void 0;
const types_impl_1 = __webpack_require__(/*! ../types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const type_converters_1 = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const semantic_tokens_dto_1 = __webpack_require__(/*! ../../common/semantic-tokens-dto */ "../../packages/plugin-ext/lib/common/semantic-tokens-dto.js");
class SemanticTokensPreviousResult {
    constructor(resultId, tokens) {
        this.resultId = resultId;
        this.tokens = tokens;
    }
}
class DocumentSemanticTokensAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
        this._nextResultId = 1;
        this._previousResults = new Map();
    }
    async provideDocumentSemanticTokens(resource, previousResultId, token) {
        const doc = this._documents.getDocument(resource);
        const previousResult = (previousResultId !== 0 ? this._previousResults.get(previousResultId) : null);
        let value;
        if (previousResult && typeof previousResult.resultId === 'string' && typeof this._provider.provideDocumentSemanticTokensEdits === 'function') {
            value = await this._provider.provideDocumentSemanticTokensEdits(doc, previousResult.resultId, token);
        }
        else {
            value = await this._provider.provideDocumentSemanticTokens(doc, token);
        }
        if (previousResult) {
            this._previousResults.delete(previousResultId);
        }
        if (!value) {
            return null;
        }
        value = DocumentSemanticTokensAdapter._fixProvidedSemanticTokens(value);
        return this._send(DocumentSemanticTokensAdapter._convertToEdits(previousResult, value), value);
    }
    async releaseDocumentSemanticColoring(semanticColoringResultId) {
        this._previousResults.delete(semanticColoringResultId);
    }
    static _fixProvidedSemanticTokens(v) {
        if (DocumentSemanticTokensAdapter._isSemanticTokens(v)) {
            if (DocumentSemanticTokensAdapter._isCorrectSemanticTokens(v)) {
                return v;
            }
            return new types_impl_1.SemanticTokens(new Uint32Array(v.data), v.resultId);
        }
        else if (DocumentSemanticTokensAdapter._isSemanticTokensEdits(v)) {
            if (DocumentSemanticTokensAdapter._isCorrectSemanticTokensEdits(v)) {
                return v;
            }
            return new types_impl_1.SemanticTokensEdits(v.edits.map(edit => new types_impl_1.SemanticTokensEdit(edit.start, edit.deleteCount, edit.data ?
                new Uint32Array(edit.data) : edit.data)), v.resultId);
        }
        return v;
    }
    static _isSemanticTokens(v) {
        return v && !!(v.data);
    }
    static _isCorrectSemanticTokens(v) {
        return (v.data instanceof Uint32Array);
    }
    static _isSemanticTokensEdits(v) {
        return v && Array.isArray(v.edits);
    }
    static _isCorrectSemanticTokensEdits(v) {
        for (const edit of v.edits) {
            if (!(edit.data instanceof Uint32Array)) {
                return false;
            }
        }
        return true;
    }
    static _convertToEdits(previousResult, newResult) {
        if (!DocumentSemanticTokensAdapter._isSemanticTokens(newResult)) {
            return newResult;
        }
        if (!previousResult || !previousResult.tokens) {
            return newResult;
        }
        const oldData = previousResult.tokens;
        const oldLength = oldData.length;
        const newData = newResult.data;
        const newLength = newData.length;
        let commonPrefixLength = 0;
        const maxCommonPrefixLength = Math.min(oldLength, newLength);
        while (commonPrefixLength < maxCommonPrefixLength && oldData[commonPrefixLength] === newData[commonPrefixLength]) {
            commonPrefixLength++;
        }
        if (commonPrefixLength === oldLength && commonPrefixLength === newLength) {
            // complete overlap!
            return new types_impl_1.SemanticTokensEdits([], newResult.resultId);
        }
        let commonSuffixLength = 0;
        const maxCommonSuffixLength = maxCommonPrefixLength - commonPrefixLength;
        while (commonSuffixLength < maxCommonSuffixLength && oldData[oldLength - commonSuffixLength - 1] === newData[newLength - commonSuffixLength - 1]) {
            commonSuffixLength++;
        }
        return new types_impl_1.SemanticTokensEdits([{
                start: commonPrefixLength,
                deleteCount: (oldLength - commonPrefixLength - commonSuffixLength),
                data: newData.subarray(commonPrefixLength, newLength - commonSuffixLength)
            }], newResult.resultId);
    }
    _send(value, original) {
        if (DocumentSemanticTokensAdapter._isSemanticTokens(value)) {
            const myId = this._nextResultId++;
            this._previousResults.set(myId, new SemanticTokensPreviousResult(value.resultId, value.data));
            return (0, semantic_tokens_dto_1.encodeSemanticTokensDto)({
                id: myId,
                type: 'full',
                data: value.data
            });
        }
        if (DocumentSemanticTokensAdapter._isSemanticTokensEdits(value)) {
            const myId = this._nextResultId++;
            if (DocumentSemanticTokensAdapter._isSemanticTokens(original)) {
                // store the original
                this._previousResults.set(myId, new SemanticTokensPreviousResult(original.resultId, original.data));
            }
            else {
                this._previousResults.set(myId, new SemanticTokensPreviousResult(value.resultId));
            }
            return (0, semantic_tokens_dto_1.encodeSemanticTokensDto)({
                id: myId,
                type: 'delta',
                deltas: (value.edits || []).map(edit => ({ start: edit.start, deleteCount: edit.deleteCount, data: edit.data }))
            });
        }
        return null;
    }
}
exports.DocumentSemanticTokensAdapter = DocumentSemanticTokensAdapter;
class DocumentRangeSemanticTokensAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideDocumentRangeSemanticTokens(resource, range, token) {
        const doc = this._documents.getDocument(resource);
        const value = await this._provider.provideDocumentRangeSemanticTokens(doc, (0, type_converters_1.toRange)(range), token);
        if (!value) {
            return null;
        }
        return this._send(value);
    }
    _send(value) {
        return (0, semantic_tokens_dto_1.encodeSemanticTokensDto)({
            id: 0,
            type: 'full',
            data: value.data
        });
    }
}
exports.DocumentRangeSemanticTokensAdapter = DocumentRangeSemanticTokensAdapter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/signature.js":
/*!*******************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/signature.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SignatureHelpAdapter = void 0;
const Converter = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
class SignatureHelpAdapter {
    constructor(delegate, documents) {
        this.delegate = delegate;
        this.documents = documents;
        this.idSequence = 1;
        this.cache = new Map();
    }
    async provideSignatureHelp(resource, position, token, context) {
        var _a;
        const documentData = this.documents.getDocumentData(resource);
        if (!documentData) {
            return Promise.reject(new Error(`There are no document for  ${resource}`));
        }
        const document = documentData.document;
        const zeroBasedPosition = Converter.toPosition(position);
        const pluginHelpContext = this.reviveContext(context);
        const value = await this.delegate.provideSignatureHelp(document, zeroBasedPosition, token, pluginHelpContext);
        if (!value) {
            return undefined;
        }
        value.activeParameter = (_a = value.signatures[value.activeSignature].activeParameter) !== null && _a !== void 0 ? _a : value.activeParameter;
        const id = this.idSequence++;
        this.cache.set(id, value);
        return Converter.SignatureHelp.from(id, value);
    }
    reviveContext(context) {
        var _a;
        let activeSignatureHelp = undefined;
        if (context.activeSignatureHelp) {
            const revivedSignatureHelp = Converter.SignatureHelp.to(context.activeSignatureHelp);
            const saved = typeof context.activeSignatureHelp.id === 'number' && this.cache.get(context.activeSignatureHelp.id);
            if (saved) {
                activeSignatureHelp = saved;
                activeSignatureHelp.activeSignature = revivedSignatureHelp.activeSignature;
                const { activeSignature } = revivedSignatureHelp;
                activeSignatureHelp.activeParameter = (_a = revivedSignatureHelp.signatures[activeSignature].activeParameter) !== null && _a !== void 0 ? _a : revivedSignatureHelp.activeParameter;
            }
            else {
                activeSignatureHelp = revivedSignatureHelp;
            }
        }
        return { ...context, activeSignatureHelp };
    }
    releaseSignatureHelp(id) {
        this.cache.delete(id);
    }
}
exports.SignatureHelpAdapter = SignatureHelpAdapter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/type-definition.js":
/*!*************************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/type-definition.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeDefinitionAdapter = void 0;
const types = __webpack_require__(/*! ../types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const Converter = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const util_1 = __webpack_require__(/*! ./util */ "../../packages/plugin-ext/lib/plugin/languages/util.js");
class TypeDefinitionAdapter {
    constructor(provider, documents) {
        this.provider = provider;
        this.documents = documents;
    }
    provideTypeDefinition(resource, position, token) {
        const documentData = this.documents.getDocumentData(resource);
        if (!documentData) {
            return Promise.reject(new Error(`There is no document for ${resource}`));
        }
        const document = documentData.document;
        const zeroBasedPosition = Converter.toPosition(position);
        return Promise.resolve(this.provider.provideTypeDefinition(document, zeroBasedPosition, token)).then(definition => {
            if (!definition) {
                return undefined;
            }
            if (definition instanceof types.Location) {
                return Converter.fromLocation(definition);
            }
            if ((0, util_1.isLocationArray)(definition)) {
                const locations = [];
                for (const location of definition) {
                    locations.push(Converter.fromLocation(location));
                }
                return locations;
            }
            if ((0, util_1.isDefinitionLinkArray)(definition)) {
                const definitionLinks = [];
                for (const definitionLink of definition) {
                    definitionLinks.push(Converter.fromDefinitionLink(definitionLink));
                }
                return definitionLinks;
            }
        });
    }
}
exports.TypeDefinitionAdapter = TypeDefinitionAdapter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/type-hierarchy.js":
/*!************************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/type-hierarchy.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeHierarchyAdapter = void 0;
const id_generator_1 = __webpack_require__(/*! ../../common/id-generator */ "../../packages/plugin-ext/lib/common/id-generator.js");
const type_converters_1 = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const types = __webpack_require__(/*! ../types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
class TypeHierarchyAdapter {
    constructor(provider, documents) {
        this.provider = provider;
        this.documents = documents;
        this.idGenerator = new id_generator_1.IdGenerator('');
        this.cache = new Map();
    }
    fromTypeHierarchyItem(item, sessionId) {
        const sessionCache = this.cache.get(sessionId);
        const itemId = sessionCache.size.toString(36);
        const definition = {
            _itemId: itemId,
            _sessionId: sessionId,
            kind: type_converters_1.SymbolKind.fromSymbolKind(item.kind),
            tags: item.tags,
            name: item.name,
            detail: item.detail,
            uri: item.uri,
            range: (0, type_converters_1.fromRange)(item.range),
            selectionRange: (0, type_converters_1.fromRange)(item.selectionRange),
        };
        sessionCache.set(itemId, item);
        return definition;
    }
    async prepareSession(uri, position, token) {
        const documentData = this.documents.getDocumentData(uri);
        if (!documentData) {
            return Promise.reject(new Error(`There is no document for ${uri}`));
        }
        const definition = await this.provider.prepareTypeHierarchy(documentData.document, new types.Position(position.lineNumber, position.column), token);
        if (!definition) {
            return undefined;
        }
        const sessionId = this.idGenerator.nextId();
        this.cache.set(sessionId, new Map());
        return Array.isArray(definition) ? definition.map(item => this.fromTypeHierarchyItem(item, sessionId)) : [this.fromTypeHierarchyItem(definition, sessionId)];
    }
    async provideSupertypes(sessionId, itemId, token) {
        const item = this.fetchItemFromCatch(sessionId, itemId);
        if (!item) {
            throw new Error('missing type hierarchy item');
        }
        const supertypes = await this.provider.provideTypeHierarchySupertypes(item, token);
        if (!supertypes) {
            return undefined;
        }
        return supertypes.map(supertype => this.fromTypeHierarchyItem(supertype, sessionId));
    }
    async provideSubtypes(sessionId, itemId, token) {
        const item = this.fetchItemFromCatch(sessionId, itemId);
        if (!item) {
            throw new Error('missing type hierarchy item');
        }
        const subTypes = await this.provider.provideTypeHierarchySubtypes(item, token);
        if (!subTypes) {
            return undefined;
        }
        return subTypes.map(subtype => this.fromTypeHierarchyItem(subtype, sessionId));
    }
    fetchItemFromCatch(sessionId, itemId) {
        var _a;
        return (_a = this.cache.get(sessionId)) === null || _a === void 0 ? void 0 : _a.get(itemId);
    }
    releaseSession(session) {
        if (session !== undefined) {
            return Promise.resolve(this.cache.delete(session));
        }
        else {
            this.cache.clear();
            return Promise.resolve(true);
        }
    }
}
exports.TypeHierarchyAdapter = TypeHierarchyAdapter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/util.js":
/*!**************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/util.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isDefinitionLinkArray = exports.isLocationArray = void 0;
const types = __webpack_require__(/*! ../types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
function isLocationArray(array) {
    return Array.isArray(array) && array.length > 0 && array[0] instanceof types.Location;
}
exports.isLocationArray = isLocationArray;
function isDefinitionLinkArray(array) {
    return Array.isArray(array) && array.length > 0 && array[0].hasOwnProperty('targetUri') && array[0].hasOwnProperty('targetRange');
}
exports.isDefinitionLinkArray = isDefinitionLinkArray;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/languages/workspace-symbol.js":
/*!**************************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/languages/workspace-symbol.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceSymbolAdapter = void 0;
const Converter = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
class WorkspaceSymbolAdapter {
    constructor(provider) {
        this.provider = provider;
    }
    provideWorkspaceSymbols(query, token) {
        return Promise.resolve(this.provider.provideWorkspaceSymbols(query, token)).then(workspaceSymbols => {
            if (!workspaceSymbols) {
                return [];
            }
            const newSymbols = [];
            for (const sym of workspaceSymbols) {
                const convertedSymbol = Converter.fromSymbolInformation(sym);
                if (convertedSymbol) {
                    newSymbols.push(convertedSymbol);
                }
            }
            return newSymbols;
        });
    }
    resolveWorkspaceSymbol(symbol, token) {
        if (this.provider.resolveWorkspaceSymbol && typeof this.provider.resolveWorkspaceSymbol === 'function') {
            const theiaSymbol = Converter.toSymbolInformation(symbol);
            if (!theiaSymbol) {
                return Promise.resolve(symbol);
            }
            else {
                return Promise.resolve(this.provider.resolveWorkspaceSymbol(theiaSymbol, token)).then(workspaceSymbol => {
                    if (!workspaceSymbol) {
                        return symbol;
                    }
                    const converted = Converter.fromSymbolInformation(workspaceSymbol);
                    if (converted) {
                        return converted;
                    }
                    return symbol;
                });
            }
        }
        return Promise.resolve(symbol);
    }
}
exports.WorkspaceSymbolAdapter = WorkspaceSymbolAdapter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/localization-ext.js":
/*!****************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/localization-ext.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LocalizationExtImpl = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const core_1 = __webpack_require__(/*! @theia/core */ "../../packages/core/lib/common/index.js");
const localization_1 = __webpack_require__(/*! @theia/core/lib/common/i18n/localization */ "../../packages/core/lib/common/i18n/localization.js");
const common_1 = __webpack_require__(/*! ../common */ "../../packages/plugin-ext/lib/common/index.js");
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
class LocalizationExtImpl {
    constructor(rpc) {
        this.isDefaultLanguage = true;
        this.bundleCache = new Map();
        this._proxy = rpc.getProxy(common_1.PLUGIN_RPC_CONTEXT.LOCALIZATION_MAIN);
    }
    translateMessage(pluginId, details) {
        var _a;
        const { message, args, comment } = details;
        if (this.isDefaultLanguage) {
            return localization_1.Localization.format(message, (args !== null && args !== void 0 ? args : {}));
        }
        let key = message;
        if (comment && comment.length > 0) {
            key += `/${Array.isArray(comment) ? comment.join() : comment}`;
        }
        const str = (_a = this.bundleCache.get(pluginId)) === null || _a === void 0 ? void 0 : _a.contents[key];
        return localization_1.Localization.format(str !== null && str !== void 0 ? str : message, (args !== null && args !== void 0 ? args : {}));
    }
    getBundle(pluginId) {
        var _a;
        return (_a = this.bundleCache.get(pluginId)) === null || _a === void 0 ? void 0 : _a.contents;
    }
    getBundleUri(pluginId) {
        var _a;
        const uri = (_a = this.bundleCache.get(pluginId)) === null || _a === void 0 ? void 0 : _a.uri;
        return uri ? types_impl_1.URI.parse(uri) : undefined;
    }
    async initializeLocalizedMessages(plugin, currentLanguage) {
        var _a;
        (_a = this.currentLanguage) !== null && _a !== void 0 ? _a : (this.currentLanguage = currentLanguage);
        this.isDefaultLanguage = this.currentLanguage === core_1.nls.defaultLocale;
        if (this.isDefaultLanguage) {
            return;
        }
        if (this.bundleCache.has(plugin.model.id)) {
            return;
        }
        let bundle;
        try {
            bundle = await this._proxy.$fetchBundle(plugin.model.id);
        }
        catch (e) {
            console.error(`Failed to load translations for ${plugin.model.id}: ${e.message}`);
            return;
        }
        this.bundleCache.set(plugin.model.id, bundle);
    }
}
exports.LocalizationExtImpl = LocalizationExtImpl;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/markdown-string.js":
/*!***************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/markdown-string.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _MarkdownString_delegate;
var MarkdownString_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MarkdownString = void 0;
const markdown_rendering_1 = __webpack_require__(/*! @theia/core/lib/common/markdown-rendering */ "../../packages/core/lib/common/markdown-rendering/index.js");
const types_1 = __webpack_require__(/*! ../common/types */ "../../packages/plugin-ext/lib/common/types.js");
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
// Copied from https://github.com/microsoft/vscode/blob/7d9b1c37f8e5ae3772782ba3b09d827eb3fdd833/src/vs/workbench/api/common/extHostTypes.ts
let MarkdownString = MarkdownString_1 = class MarkdownString {
    constructor(value, supportThemeIcons = false) {
        _MarkdownString_delegate.set(this, void 0);
        __classPrivateFieldSet(this, _MarkdownString_delegate, new markdown_rendering_1.MarkdownStringImpl(value, { supportThemeIcons }), "f");
    }
    /**
     * @returns whether the thing is a markdown string implementation with helper methods.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static isMarkdownString(thing) {
        if (thing instanceof MarkdownString_1) {
            return true;
        }
        return thing && thing.appendCodeblock && thing.appendMarkdown && thing.appendText && (thing.value !== undefined);
    }
    get value() {
        return __classPrivateFieldGet(this, _MarkdownString_delegate, "f").value;
    }
    set value(value) {
        __classPrivateFieldGet(this, _MarkdownString_delegate, "f").value = value;
    }
    get isTrusted() {
        return __classPrivateFieldGet(this, _MarkdownString_delegate, "f").isTrusted;
    }
    set isTrusted(value) {
        __classPrivateFieldGet(this, _MarkdownString_delegate, "f").isTrusted = value;
    }
    get supportThemeIcons() {
        return __classPrivateFieldGet(this, _MarkdownString_delegate, "f").supportThemeIcons;
    }
    set supportThemeIcons(value) {
        __classPrivateFieldGet(this, _MarkdownString_delegate, "f").supportThemeIcons = value;
    }
    get supportHtml() {
        return __classPrivateFieldGet(this, _MarkdownString_delegate, "f").supportHtml;
    }
    set supportHtml(value) {
        __classPrivateFieldGet(this, _MarkdownString_delegate, "f").supportHtml = value;
    }
    get baseUri() {
        return types_impl_1.URI.revive(__classPrivateFieldGet(this, _MarkdownString_delegate, "f").baseUri);
    }
    set baseUri(value) {
        __classPrivateFieldGet(this, _MarkdownString_delegate, "f").baseUri = value;
    }
    appendText(value) {
        __classPrivateFieldGet(this, _MarkdownString_delegate, "f").appendText(value);
        return this;
    }
    appendMarkdown(value) {
        __classPrivateFieldGet(this, _MarkdownString_delegate, "f").appendMarkdown(value);
        return this;
    }
    appendCodeblock(value, language) {
        __classPrivateFieldGet(this, _MarkdownString_delegate, "f").appendCodeblock(language !== null && language !== void 0 ? language : '', value);
        return this;
    }
    toJSON() {
        const plainObject = { value: this.value };
        if (this.isTrusted !== undefined) {
            plainObject.isTrusted = this.isTrusted;
        }
        if (this.supportThemeIcons !== undefined) {
            plainObject.supportThemeIcons = this.supportThemeIcons;
        }
        if (this.supportHtml !== undefined) {
            plainObject.supportHtml = this.supportHtml;
        }
        if (this.baseUri !== undefined) {
            plainObject.baseUri = this.baseUri.toJSON();
        }
        return plainObject;
    }
};
_MarkdownString_delegate = new WeakMap();
MarkdownString = MarkdownString_1 = __decorate([
    types_1.es5ClassCompat,
    __metadata("design:paramtypes", [String, Boolean])
], MarkdownString);
exports.MarkdownString = MarkdownString;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/message-registry.js":
/*!****************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/message-registry.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageRegistryExt = void 0;
// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
class MessageRegistryExt {
    constructor(rpc) {
        this.proxy = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.MESSAGE_REGISTRY_MAIN);
    }
    async showMessage(type, message, optionsOrFirstItem, ...rest) {
        const options = {};
        const actions = [];
        const items = [];
        const pushItem = (item) => {
            items.push(item);
            if (typeof item === 'string') {
                actions.push({ title: item });
            }
            else {
                actions.push({ title: item.title, isCloseAffordance: item.isCloseAffordance });
                if (item.isCloseAffordance) {
                    options.onCloseActionHandle = actions.length - 1;
                }
            }
        };
        if (optionsOrFirstItem) {
            if (typeof optionsOrFirstItem === 'string' || 'title' in optionsOrFirstItem) {
                pushItem(optionsOrFirstItem);
            }
            else {
                if ('modal' in optionsOrFirstItem) {
                    options.modal = optionsOrFirstItem.modal;
                    if ('detail' in optionsOrFirstItem) {
                        options.detail = optionsOrFirstItem.detail;
                    }
                }
            }
        }
        for (const item of rest) {
            pushItem(item);
        }
        const actionHandle = await this.proxy.$showMessage(type, message, options, actions);
        return actionHandle !== undefined ? items[actionHandle] : undefined;
    }
}
exports.MessageRegistryExt = MessageRegistryExt;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/node/debug/plugin-node-debug-adapter-creator.js":
/*!********************************************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/node/debug/plugin-node-debug-adapter-creator.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 Arm and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NodeDebugAdapterCreator = void 0;
const plugin_debug_adapter_creator_1 = __webpack_require__(/*! ../../debug/plugin-debug-adapter-creator */ "../../packages/plugin-ext/lib/plugin/debug/plugin-debug-adapter-creator.js");
const path = __webpack_require__(/*! path */ "path");
const os_1 = __webpack_require__(/*! @theia/core/lib/common/os */ "../../packages/core/lib/common/os.js");
const net = __webpack_require__(/*! net */ "net");
const child_process_1 = __webpack_require__(/*! child_process */ "child_process");
const types_impl_1 = __webpack_require__(/*! ../../types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const stream_debug_adapter_1 = __webpack_require__(/*! @theia/debug/lib/node/stream-debug-adapter */ "../../packages/debug/lib/node/stream-debug-adapter.js");
const isElectron = __webpack_require__(/*! is-electron */ "../../node_modules/is-electron/index.js");
class NodeDebugAdapterCreator extends plugin_debug_adapter_creator_1.PluginDebugAdapterCreator {
    async resolveDebugAdapterExecutable(pluginPath, debuggerContribution) {
        const info = this.toPlatformInfo(debuggerContribution);
        let program = (info && info.program || debuggerContribution.program);
        if (!program) {
            return undefined;
        }
        program = path.join(pluginPath, program);
        const programArgs = info && info.args || debuggerContribution.args || [];
        let runtime = info && info.runtime || debuggerContribution.runtime;
        if (runtime && runtime.indexOf('./') === 0) {
            runtime = path.join(pluginPath, runtime);
        }
        const runtimeArgs = info && info.runtimeArgs || debuggerContribution.runtimeArgs || [];
        const command = runtime ? runtime : program;
        const args = runtime ? [...runtimeArgs, program, ...programArgs] : programArgs;
        return {
            command,
            args
        };
    }
    async createDebugAdapter(session, debugConfiguration, executable, descriptorFactory) {
        if (descriptorFactory) {
            // 'createDebugAdapterDescriptor' is called at the start of a debug session to provide details about the debug adapter to use.
            // These details must be returned as objects of type [DebugAdapterDescriptor](#DebugAdapterDescriptor).
            // Currently two types of debug adapters are supported:
            // - a debug adapter executable is specified as a command path and arguments (see [DebugAdapterExecutable](#DebugAdapterExecutable)),
            // - a debug adapter server reachable via a communication port (see [DebugAdapterServer](#DebugAdapterServer)).
            // If the method is not implemented the default behavior is this:
            //   createDebugAdapter(session: DebugSession, executable: DebugAdapterExecutable) {
            //      if (typeof session.configuration.debugServer === 'number') {
            //         return new DebugAdapterServer(session.configuration.debugServer);
            //      }
            //      return executable;
            //   }
            //  @param session The [debug session](#DebugSession) for which the debug adapter will be used.
            //  @param executable The debug adapter's executable information as specified in the package.json (or undefined if no such information exists).
            const descriptor = await descriptorFactory.createDebugAdapterDescriptor(session, executable);
            if (descriptor) {
                if (types_impl_1.DebugAdapterServer.is(descriptor)) {
                    return this.connectSocketDebugAdapter(descriptor);
                }
                else if (types_impl_1.DebugAdapterExecutable.is(descriptor)) {
                    return this.startDebugAdapter(descriptor);
                }
                else if (types_impl_1.DebugAdapterNamedPipeServer.is(descriptor)) {
                    return this.connectPipeDebugAdapter(descriptor);
                }
                else if (types_impl_1.DebugAdapterInlineImplementation.is(descriptor)) {
                    return this.connectInlineDebugAdapter(descriptor);
                }
            }
        }
        if ('debugServer' in debugConfiguration) {
            return this.connectSocketDebugAdapter({ port: debugConfiguration.debugServer });
        }
        else {
            if (!executable) {
                throw new Error('It is not possible to provide debug adapter executable.');
            }
            return this.startDebugAdapter(executable);
        }
    }
    toPlatformInfo(executable) {
        if (os_1.isWindows && !process.env.hasOwnProperty('PROCESSOR_ARCHITEW6432')) {
            return executable.winx86 || executable.win || executable.windows;
        }
        if (os_1.isWindows) {
            return executable.win || executable.windows;
        }
        if (os_1.isOSX) {
            return executable.osx;
        }
        return executable.linux;
    }
    startDebugAdapter(executable) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const options = { stdio: ['pipe', 'pipe', 2] };
        if (executable.options) {
            options.cwd = executable.options.cwd;
            // The additional environment of the executed program or shell. If omitted
            // the parent process' environment is used. If provided it is merged with
            // the parent process' environment.
            options.env = Object.assign({}, process.env);
            Object.assign(options.env, executable.options.env);
        }
        let childProcess;
        const { command, args } = executable;
        if (command === 'node') {
            if (Array.isArray(args) && args.length > 0) {
                const forkOptions = {
                    env: options.env,
                    // When running in Electron, fork will automatically add ELECTRON_RUN_AS_NODE=1 to the env,
                    // but this will cause issues when debugging Electron apps, so we'll remove it.
                    execArgv: isElectron()
                        ? ['-e', 'delete process.env.ELECTRON_RUN_AS_NODE;require(process.argv[1])']
                        : [],
                    silent: true
                };
                if (options.cwd) {
                    forkOptions.cwd = options.cwd;
                }
                options.stdio.push('ipc');
                forkOptions.stdio = options.stdio;
                childProcess = (0, child_process_1.fork)(args[0], args.slice(1), forkOptions);
            }
            else {
                throw new Error(`It is not possible to launch debug adapter with the command: ${JSON.stringify(executable)}`);
            }
        }
        else {
            childProcess = (0, child_process_1.spawn)(command, args, options);
        }
        return new stream_debug_adapter_1.ProcessDebugAdapter(childProcess);
    }
    /**
     * Connects to a remote debug server.
     */
    connectSocketDebugAdapter(server) {
        const socket = net.createConnection(server.port, server.host);
        return new stream_debug_adapter_1.SocketDebugAdapter(socket);
    }
    connectPipeDebugAdapter(adapter) {
        const socket = net.createConnection(adapter.path);
        return new stream_debug_adapter_1.SocketDebugAdapter(socket);
    }
}
exports.NodeDebugAdapterCreator = NodeDebugAdapterCreator;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/node/env-node-ext.js":
/*!*****************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/node/env-node-ext.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnvNodeExtImpl = void 0;
const mac = __webpack_require__(/*! macaddress */ "../../node_modules/macaddress/index.js");
const env_1 = __webpack_require__(/*! ../env */ "../../packages/plugin-ext/lib/plugin/env.js");
const crypto_1 = __webpack_require__(/*! crypto */ "crypto");
const uuid_1 = __webpack_require__(/*! uuid */ "../../node_modules/uuid/dist/esm-node/index.js");
const fs = __webpack_require__(/*! fs */ "fs");
/**
 * Provides machineId using mac address. It's only possible on node side
 * Extending the common class
 */
class EnvNodeExtImpl extends env_1.EnvExtImpl {
    constructor(rpc) {
        super(rpc);
        mac.one((err, macAddress) => {
            if (err) {
                this.macMachineId = (0, uuid_1.v4)();
            }
            else {
                this.macMachineId = (0, crypto_1.createHash)('sha256').update(macAddress, 'utf8').digest('hex');
            }
        });
        this._isNewAppInstall = this.computeIsNewAppInstall();
    }
    /**
     * override machineID
     */
    get machineId() {
        return this.macMachineId;
    }
    /**
     * Provides application root.
     */
    get appRoot() {
        return __dirname;
    }
    get isNewAppInstall() {
        return this._isNewAppInstall;
    }
    computeIsNewAppInstall() {
        const creation = fs.statSync(__filename).birthtimeMs;
        const current = Date.now();
        const dayMs = 24 * 3600 * 1000;
        return (current - creation) < dayMs;
    }
}
exports.EnvNodeExtImpl = EnvNodeExtImpl;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/notebook/notebook-document.js":
/*!**************************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/notebook/notebook-document.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookDocument = exports.Cell = void 0;
const notebookCommon = __webpack_require__(/*! @theia/notebook/lib/common */ "../../packages/notebook/lib/common/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../packages/core/lib/common/index.js");
const typeConverters = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const types_impl_1 = __webpack_require__(/*! ../types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
class RawContentChangeEvent {
    constructor(start, deletedCount, deletedItems, items) {
        this.start = start;
        this.deletedCount = deletedCount;
        this.deletedItems = deletedItems;
        this.items = items;
    }
    asApiEvent() {
        return {
            range: new types_impl_1.NotebookRange(this.start, this.start + this.deletedCount),
            addedCells: this.items.map(cell => cell.apiCell),
            removedCells: this.deletedItems,
        };
    }
}
class Cell {
    constructor(notebookDocument, editorsAndDocuments, cellData) {
        var _a, _b, _c;
        this.notebookDocument = notebookDocument;
        this.editorsAndDocuments = editorsAndDocuments;
        this.cellData = cellData;
        this.handle = cellData.handle;
        this.uri = core_1.URI.fromComponents(cellData.uri);
        this.cellKind = cellData.cellKind;
        this.outputs = cellData.outputs.map(typeConverters.NotebookCellOutputConverter.to);
        this.internalMetadata = (_a = cellData.internalMetadata) !== null && _a !== void 0 ? _a : {};
        this.metadata = Object.freeze((_b = cellData.metadata) !== null && _b !== void 0 ? _b : {});
        this.previousResult = Object.freeze(typeConverters.NotebookCellExecutionSummary.to((_c = cellData.internalMetadata) !== null && _c !== void 0 ? _c : {}));
    }
    static asModelAddData(notebook, cell) {
        return {
            EOL: cell.eol,
            lines: cell.source,
            languageId: cell.language,
            uri: cell.uri,
            isDirty: false,
            versionId: 1,
            notebook,
            modeId: ''
        };
    }
    get language() {
        return this.apiCell.document.languageId;
    }
    get apiCell() {
        if (!this.cell) {
            const that = this;
            const data = this.editorsAndDocuments.getDocument(this.uri.toString());
            if (!data) {
                throw new Error(`MISSING extHostDocument for notebook cell: ${this.uri}`);
            }
            const apiCell = {
                get index() { return that.notebookDocument.getCellIndex(that); },
                notebook: that.notebookDocument.apiNotebook,
                kind: typeConverters.NotebookCellKind.to(this.cellData.cellKind),
                document: data.document,
                get outputs() { return that.outputs.slice(0); },
                get metadata() { return that.metadata; },
                get executionSummary() { return that.previousResult; }
            };
            this.cell = Object.freeze(apiCell);
        }
        return this.cell;
    }
    setOutputs(newOutputs) {
        this.outputs = newOutputs.map(typeConverters.NotebookCellOutputConverter.to);
    }
    // setOutputItems(outputId: string, append: boolean, newOutputItems: NotebookOutputItemDto[]): void {
    //     const newItems = newOutputItems.map(typeConverters.NotebookCellOutputItem.to);
    //     const output = this.outputs.find(op => op.id === outputId);
    //     if (output) {
    //         if (!append) {
    //             output.items.length = 0;
    //         }
    //         output.items.push(...newItems);
    //         // if (output.items.length > 1 && output.items.every(item => notebookCommon.isTextStreamMime(item.mime))) {
    //         //     // Look for the mimes in the items, and keep track of their order.
    //         //     // Merge the streams into one output item, per mime type.
    //         //     const mimeOutputs = new Map<string, Uint8Array[]>();
    //         //     const mimeTypes: string[] = [];
    //         //     output.items.forEach(item => {
    //         //         let items: Uint8Array[];
    //         //         if (mimeOutputs.has(item.mime)) {
    //         //             items = mimeOutputs.get(item.mime)!;
    //         //         } else {
    //         //             items = [];
    //         //             mimeOutputs.set(item.mime, items);
    //         //             mimeTypes.push(item.mime);
    //         //         }
    //         //         items.push(item.data);
    //         //     });
    //         //     output.items.length = 0;
    //         //     mimeTypes.forEach(mime => {
    //         //         const compressed = notebookCommon.compressOutputItemStreams(mimeOutputs.get(mime)!);
    //         //         output.items.push({
    //         //             mime,
    //         //             data: compressed.buffer
    //         //         });
    //         //     });
    //         // }
    //     }
    // }
    setMetadata(newMetadata) {
        this.metadata = Object.freeze(newMetadata);
    }
    setInternalMetadata(newInternalMetadata) {
        this.internalMetadata = newInternalMetadata;
        this.previousResult = Object.freeze(typeConverters.NotebookCellExecutionSummary.to(newInternalMetadata));
    }
}
exports.Cell = Cell;
class NotebookDocument {
    constructor(proxy, editorsAndDocuments, textDocuments, uri, notebookData) {
        var _a;
        this.proxy = proxy;
        this.editorsAndDocuments = editorsAndDocuments;
        this.textDocuments = textDocuments;
        this.uri = uri;
        this.versionId = 0;
        this.isDirty = false;
        this.disposed = false;
        this.notebookType = notebookData.viewType;
        this.metadata = (_a = notebookData.metadata) !== null && _a !== void 0 ? _a : {};
        this.versionId = notebookData.versionId;
        this.cells = notebookData.cells.map(cell => new Cell(this, editorsAndDocuments, cell));
    }
    get apiNotebook() {
        if (!this.notebook) {
            const that = this;
            const apiObject = {
                get uri() { return that.uri; },
                get version() { return that.versionId; },
                get notebookType() { return that.notebookType; },
                get isDirty() { return that.isDirty; },
                get isUntitled() { return that.uri.scheme === 'untitled'; },
                get isClosed() { return that.disposed; },
                get metadata() { return that.metadata; },
                get cellCount() { return that.cells.length; },
                cellAt(index) {
                    index = that.validateIndex(index);
                    return that.cells[index].apiCell;
                },
                getCells(range) {
                    const cells = range ? that.getCells(range) : that.cells;
                    return cells.map(cell => cell.apiCell);
                },
                save() {
                    return that.save();
                }
            };
            this.notebook = Object.freeze(apiObject);
        }
        return this.notebook;
    }
    validateIndex(index) {
        index = index | 0;
        if (index < 0) {
            return 0;
        }
        else if (index >= this.cells.length) {
            return this.cells.length - 1;
        }
        else {
            return index;
        }
    }
    validateRange(range) {
        let start = range.start | 0;
        let end = range.end | 0;
        if (start < 0) {
            start = 0;
        }
        if (end > this.cells.length) {
            end = this.cells.length;
        }
        return range.with({ start, end });
    }
    getCells(range) {
        range = this.validateRange(range);
        const result = [];
        for (let i = range.start; i < range.end; i++) {
            result.push(this.cells[i]);
        }
        return result;
    }
    async save() {
        if (this.disposed) {
            return Promise.reject(new Error('Notebook has been closed'));
        }
        return this.proxy.$trySaveNotebook(this.uri);
    }
    acceptDirty(isDirty) {
        this.isDirty = isDirty;
    }
    acceptModelChanged(event, isDirty, newMetadata) {
        this.versionId = event.versionId;
        this.isDirty = isDirty;
        // this.acceptDocumentPropertiesChanged({ metadata: newMetadata });
        const result = {
            notebook: this.apiNotebook,
            metadata: newMetadata,
            cellChanges: [],
            contentChanges: [],
        };
        const relaxedCellChanges = [];
        // -- apply change and populate content changes
        for (const rawEvent of event.rawEvents) {
            if (rawEvent.kind === notebookCommon.NotebookCellsChangeType.ModelChange) {
                this.spliceNotebookCells(rawEvent.changes, false, result.contentChanges);
            }
            else if (rawEvent.kind === notebookCommon.NotebookCellsChangeType.Move) {
                this.moveCells(rawEvent.index, rawEvent.length, rawEvent.newIdx, result.contentChanges);
            }
            else if (rawEvent.kind === notebookCommon.NotebookCellsChangeType.Output) {
                this.setCellOutputs(rawEvent.index, rawEvent.outputs);
                relaxedCellChanges.push({ cell: this.cells[rawEvent.index].apiCell, outputs: this.cells[rawEvent.index].apiCell.outputs });
                // } else if (rawEvent.kind === notebookCommon.NotebookCellsChangeType.OutputItem) {
                //     this._setCellOutputItems(rawEvent.index, rawEvent.outputId, rawEvent.append, rawEvent.outputItems);
                //     relaxedCellChanges.push({ cell: this.cells[rawEvent.index].apiCell, outputs: this.cells[rawEvent.index].apiCell.outputs });
            }
            else if (rawEvent.kind === notebookCommon.NotebookCellsChangeType.ChangeCellLanguage) {
                this.changeCellLanguage(rawEvent.index, rawEvent.language);
                relaxedCellChanges.push({ cell: this.cells[rawEvent.index].apiCell, document: this.cells[rawEvent.index].apiCell.document });
            }
            else if (rawEvent.kind === notebookCommon.NotebookCellsChangeType.ChangeCellContent) {
                relaxedCellChanges.push({ cell: this.cells[rawEvent.index].apiCell, document: this.cells[rawEvent.index].apiCell.document });
                // } else if (rawEvent.kind === notebookCommon.NotebookCellsChangeType.ChangeCellMime) {
                //     this._changeCellMime(rawEvent.index, rawEvent.mime);
            }
            else if (rawEvent.kind === notebookCommon.NotebookCellsChangeType.ChangeCellMetadata) {
                this.changeCellMetadata(rawEvent.index, rawEvent.metadata);
                relaxedCellChanges.push({ cell: this.cells[rawEvent.index].apiCell, metadata: this.cells[rawEvent.index].apiCell.metadata });
            }
            else if (rawEvent.kind === notebookCommon.NotebookCellsChangeType.ChangeCellInternalMetadata) {
                this.changeCellInternalMetadata(rawEvent.index, rawEvent.internalMetadata);
                relaxedCellChanges.push({ cell: this.cells[rawEvent.index].apiCell, executionSummary: this.cells[rawEvent.index].apiCell.executionSummary });
            }
        }
        // -- compact cellChanges
        const map = new Map();
        for (let i = 0; i < relaxedCellChanges.length; i++) {
            const relaxedCellChange = relaxedCellChanges[i];
            const existing = map.get(relaxedCellChange.cell);
            if (existing === undefined) {
                const newLen = result.cellChanges.push({
                    document: undefined,
                    executionSummary: undefined,
                    metadata: undefined,
                    outputs: undefined,
                    ...relaxedCellChange,
                });
                map.set(relaxedCellChange.cell, newLen - 1);
            }
            else {
                result.cellChanges[existing] = {
                    ...result.cellChanges[existing],
                    ...relaxedCellChange
                };
            }
        }
        // Freeze event properties so handlers cannot accidentally modify them
        Object.freeze(result);
        Object.freeze(result.cellChanges);
        Object.freeze(result.contentChanges);
        return result;
    }
    spliceNotebookCells(splices, initialization, bucket) {
        if (this.disposed) {
            return;
        }
        const contentChangeEvents = [];
        const addedCellDocuments = [];
        const removedCellDocuments = [];
        splices.reverse().forEach(splice => {
            const cellDtos = splice[2];
            const newCells = cellDtos.map((cell) => {
                const extCell = new Cell(this, this.editorsAndDocuments, cell);
                if (!initialization) {
                    addedCellDocuments.push(Cell.asModelAddData(this.apiNotebook, cell));
                }
                return extCell;
            });
            const changeEvent = new RawContentChangeEvent(splice[0], splice[1], [], newCells);
            const deletedItems = this.cells.splice(splice[0], splice[1], ...newCells);
            for (const cell of deletedItems) {
                removedCellDocuments.push(cell.uri.toComponents());
                changeEvent.deletedItems.push(cell.apiCell);
            }
            contentChangeEvents.push(changeEvent);
        });
        if (bucket) {
            for (const changeEvent of contentChangeEvents) {
                bucket.push(changeEvent.asApiEvent());
            }
        }
    }
    moveCells(index, length, newIdx, bucket) {
        const cells = this.cells.splice(index, length);
        this.cells.splice(newIdx, 0, ...cells);
        const changes = [
            new RawContentChangeEvent(index, length, cells.map(c => c.apiCell), []),
            new RawContentChangeEvent(newIdx, 0, [], cells)
        ];
        for (const change of changes) {
            bucket.push(change.asApiEvent());
        }
    }
    setCellOutputs(index, outputs) {
        const cell = this.cells[index];
        cell.setOutputs(outputs);
    }
    // private _setCellOutputItems(index: number, outputId: string, append: boolean, outputItems: NotebookOutputItemDto[]): void {
    //     const cell = this.cells[index];
    //     cell.setOutputItems(outputId, append, outputItems);
    // }
    changeCellLanguage(index, newLanguageId) {
        const cell = this.cells[index];
        if (cell.apiCell.document.languageId !== newLanguageId) {
            this.textDocuments.$acceptModelModeChanged(cell.uri.toComponents(), cell.language, newLanguageId);
        }
    }
    changeCellMetadata(index, newMetadata) {
        const cell = this.cells[index];
        cell.setMetadata(newMetadata);
    }
    changeCellInternalMetadata(index, newInternalMetadata) {
        const cell = this.cells[index];
        cell.setInternalMetadata(newInternalMetadata);
    }
    getCellFromApiCell(apiCell) {
        return this.cells.find(cell => cell.apiCell === apiCell);
    }
    getCell(cellHandle) {
        return this.cells.find(cell => cell.handle === cellHandle);
    }
    getCellFromIndex(index) {
        return this.cells[index];
    }
    getCellIndex(cell) {
        return this.cells.indexOf(cell);
    }
    dispose() {
        this.disposed = true;
    }
}
exports.NotebookDocument = NotebookDocument;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/notebook/notebook-documents.js":
/*!***************************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/notebook/notebook-documents.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookDocumentsExtImpl = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "../../packages/core/lib/common/index.js");
const types_impl_1 = __webpack_require__(/*! ../types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
class NotebookDocumentsExtImpl {
    constructor(notebooksAndEditors) {
        this.notebooksAndEditors = notebooksAndEditors;
        this.didSaveNotebookDocumentEmitter = new core_1.Emitter();
        this.onDidSaveNotebookDocument = this.didSaveNotebookDocumentEmitter.event;
        this.didChangeNotebookDocumentEmitter = new core_1.Emitter();
        this.onDidChangeNotebookDocument = this.didChangeNotebookDocumentEmitter.event;
    }
    $acceptModelChanged(uri, event, isDirty, newMetadata) {
        const document = this.notebooksAndEditors.getNotebookDocument(types_impl_1.URI.from(uri));
        const e = document.acceptModelChanged(event, isDirty, newMetadata);
        this.didChangeNotebookDocumentEmitter.fire(e);
    }
    $acceptDirtyStateChanged(uri, isDirty) {
        const document = this.notebooksAndEditors.getNotebookDocument(types_impl_1.URI.from(uri));
        document.acceptDirty(isDirty);
    }
    $acceptModelSaved(uri) {
        const document = this.notebooksAndEditors.getNotebookDocument(types_impl_1.URI.from(uri));
        this.didSaveNotebookDocumentEmitter.fire(document.apiNotebook);
    }
}
exports.NotebookDocumentsExtImpl = NotebookDocumentsExtImpl;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/notebook/notebook-editor.js":
/*!************************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/notebook/notebook-editor.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookEditor = void 0;
class NotebookEditor {
    constructor(id, 
    // private readonly _proxy: MainThreadNotebookEditorsShape,
    notebookData, visibleRanges, selections, viewColumn) {
        this.id = id;
        this.notebookData = notebookData;
        this.selections = [];
        this.visibleRanges = [];
        this.internalVisible = false;
        this.selections = selections;
        this.visibleRanges = visibleRanges;
        this.viewColumn = viewColumn;
    }
    get apiEditor() {
        if (!this.editor) {
            const that = this;
            this.editor = {
                get notebook() {
                    return that.notebookData.apiNotebook;
                },
                get selection() {
                    return that.selections[0];
                },
                set selection(selection) {
                    this.selections = [selection];
                },
                get selections() {
                    return that.selections;
                },
                set selections(value) {
                    // if (!Array.isArray(value) || !value.every(extHostTypes.NotebookRange.isNotebookRange)) {
                    //     throw illegalArgument('selections');
                    // }
                    that.selections = value;
                    that.trySetSelections(value);
                },
                get visibleRanges() {
                    return that.visibleRanges;
                },
                revealRange(range, revealType) {
                    // that._proxy.$tryRevealRange(
                    //     that.id,
                    //     extHostConverter.NotebookRange.from(range),
                    //     revealType ?? extHostTypes.NotebookEditorRevealType.Default
                    // );
                },
                get viewColumn() {
                    return that.viewColumn;
                },
            };
            NotebookEditor.apiEditorsToExtHost.set(this.editor, this);
        }
        return this.editor;
    }
    get visible() {
        return this.internalVisible;
    }
    acceptVisibility(value) {
        this.internalVisible = value;
    }
    acceptVisibleRanges(value) {
        this.visibleRanges = value;
    }
    acceptSelections(selections) {
        this.selections = selections;
    }
    trySetSelections(value) {
        // NB Unimplemented: implement "selections"
        // this._proxy.$trySetSelections(this.id, value.map(extHostConverter.NotebookRange.from));
    }
    acceptViewColumn(value) {
        this.viewColumn = value;
    }
}
exports.NotebookEditor = NotebookEditor;
NotebookEditor.apiEditorsToExtHost = new WeakMap();


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/notebook/notebook-editors.js":
/*!*************************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/notebook/notebook-editors.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookEditorsExtImpl = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "../../packages/core/lib/common/index.js");
const typeConverters = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
class NotebookEditorsExtImpl {
    constructor(notebooksAndEditors) {
        this.notebooksAndEditors = notebooksAndEditors;
        this.DidChangeNotebookEditorSelectionEmitter = new core_1.Emitter();
        this.DidChangeNotebookEditorVisibleRangesEmitter = new core_1.Emitter();
        this.onDidChangeNotebookEditorSelection = this.DidChangeNotebookEditorSelectionEmitter.event;
        this.onDidChangeNotebookEditorVisibleRanges = this.DidChangeNotebookEditorVisibleRangesEmitter.event;
    }
    $acceptEditorPropertiesChanged(id, data) {
        const editor = this.notebooksAndEditors.getEditorById(id);
        // ONE: make all state updates
        if (data.visibleRanges) {
            editor.acceptVisibleRanges(data.visibleRanges.ranges.map(typeConverters.NotebookRange.to));
        }
        if (data.selections) {
            editor.acceptSelections(data.selections.selections.map(typeConverters.NotebookRange.to));
        }
        // TWO: send all events after states have been updated
        if (data.visibleRanges) {
            this.DidChangeNotebookEditorVisibleRangesEmitter.fire({
                notebookEditor: editor.apiEditor,
                visibleRanges: editor.apiEditor.visibleRanges
            });
        }
        if (data.selections) {
            this.DidChangeNotebookEditorSelectionEmitter.fire(Object.freeze({
                notebookEditor: editor.apiEditor,
                selections: editor.apiEditor.selections
            }));
        }
    }
    $acceptEditorViewColumns(data) {
        // eslint-disable-next-line guard-for-in
        for (const id in data) {
            const editor = this.notebooksAndEditors.getEditorById(id);
            editor.acceptViewColumn(typeConverters.ViewColumn.to(data[id]));
        }
    }
}
exports.NotebookEditorsExtImpl = NotebookEditorsExtImpl;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/notebook/notebook-kernels.js":
/*!*************************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/notebook/notebook-kernels.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createKernelId = exports.NotebookKernelsExtImpl = void 0;
const common_1 = __webpack_require__(/*! ../../common */ "../../packages/plugin-ext/lib/common/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../packages/core/lib/common/index.js");
const type_converters_1 = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../../packages/core/lib/common/promise-util.js");
const common_2 = __webpack_require__(/*! @theia/notebook/lib/common */ "../../packages/notebook/lib/common/index.js");
const types_impl_1 = __webpack_require__(/*! ../types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
class NotebookKernelsExtImpl {
    constructor(rpc, notebooks, commands) {
        this.notebooks = notebooks;
        this.commands = commands;
        this.activeExecutions = new Map();
        this.kernelData = new Map();
        this.kernelDetectionTasks = new Map();
        this.currentKernelDetectionTaskHandle = 0;
        this.kernelSourceActionProviders = new Map();
        this.currentSourceActionProviderHandle = 0;
        this.onDidChangeCellExecutionStateEmitter = new core_1.Emitter();
        this.onDidChangeNotebookCellExecutionState = this.onDidChangeCellExecutionStateEmitter.event;
        this.currentHandle = 0;
        this.proxy = rpc.getProxy(common_1.PLUGIN_RPC_CONTEXT.NOTEBOOK_KERNELS_MAIN);
    }
    createNotebookController(extensionId, id, viewType, label, handler, rendererScripts) {
        for (const kernelData of this.kernelData.values()) {
            if (kernelData.controller.id === id && extensionId === kernelData.extensionId) {
                throw new Error(`notebook controller with id '${id}' ALREADY exist`);
            }
        }
        const handle = this.currentHandle++;
        const that = this;
        console.debug(`NotebookController[${handle}], CREATED by ${extensionId}, ${id}`);
        const defaultExecuteHandler = () => console.warn(`NO execute handler from notebook controller '${data.id}' of extension: '${extensionId}'`);
        let isDisposed = false;
        const commandDisposables = new core_1.DisposableCollection();
        const onDidChangeSelection = new core_1.Emitter();
        const onDidReceiveMessage = new core_1.Emitter();
        const data = {
            id: createKernelId(extensionId, id),
            notebookType: viewType,
            extensionId: extensionId,
            label: label || extensionId,
        };
        //
        let executeHandler = handler !== null && handler !== void 0 ? handler : defaultExecuteHandler;
        let interruptHandler;
        this.proxy.$addKernel(handle, data).catch(err => {
            // this can happen when a kernel with that ID is already registered
            console.log(err);
            isDisposed = true;
        });
        // update: all setters write directly into the dto object
        // and trigger an update. the actual update will only happen
        // once per event loop execution
        let tokenPool = 0;
        const update = () => {
            if (isDisposed) {
                return;
            }
            const myToken = ++tokenPool;
            Promise.resolve().then(() => {
                if (myToken === tokenPool) {
                    this.proxy.$updateKernel(handle, data);
                }
            });
        };
        // notebook documents that are associated to this controller
        const associatedNotebooks = new Map();
        const controller = {
            get id() { return id; },
            get notebookType() { return data.notebookType; },
            onDidChangeSelectedNotebooks: onDidChangeSelection.event,
            onDidReceiveMessage: onDidReceiveMessage.event,
            get label() {
                return data.label;
            },
            set label(value) {
                data.label = value !== null && value !== void 0 ? value : extensionId;
                update();
            },
            get detail() {
                var _a;
                return (_a = data.detail) !== null && _a !== void 0 ? _a : '';
            },
            set detail(value) {
                data.detail = value;
                update();
            },
            get description() {
                var _a;
                return (_a = data.description) !== null && _a !== void 0 ? _a : '';
            },
            set description(value) {
                data.description = value;
                update();
            },
            get supportedLanguages() {
                return data.supportedLanguages;
            },
            set supportedLanguages(value) {
                data.supportedLanguages = value;
                update();
            },
            get supportsExecutionOrder() {
                var _a;
                return (_a = data.supportsExecutionOrder) !== null && _a !== void 0 ? _a : false;
            },
            set supportsExecutionOrder(value) {
                data.supportsExecutionOrder = value;
                update();
            },
            get rendererScripts() {
                var _a;
                return (_a = data.rendererScripts) !== null && _a !== void 0 ? _a : [];
            },
            set rendererScripts(value) {
                data.rendererScripts = value;
                update();
            },
            get executeHandler() {
                return executeHandler;
            },
            set executeHandler(value) {
                executeHandler = value !== null && value !== void 0 ? value : defaultExecuteHandler;
            },
            get interruptHandler() {
                return interruptHandler;
            },
            set interruptHandler(value) {
                interruptHandler = value;
                data.supportsInterrupt = Boolean(value);
                update();
            },
            createNotebookCellExecution(cell) {
                if (isDisposed) {
                    throw new Error('notebook controller is DISPOSED');
                }
                if (!associatedNotebooks.has(cell.notebook.uri.toString())) {
                    console.debug(`NotebookController[${handle}] NOT associated to notebook, associated to THESE notebooks:`, Array.from(associatedNotebooks.keys()).map(u => u.toString()));
                    throw new Error(`notebook controller is NOT associated to notebook: ${cell.notebook.uri.toString()}`);
                }
                return that.createNotebookCellExecution(cell, createKernelId(extensionId, this.id));
            },
            dispose: () => {
                if (!isDisposed) {
                    console.debug(`NotebookController[${handle}], DISPOSED`);
                    isDisposed = true;
                    this.kernelData.delete(handle);
                    commandDisposables.dispose();
                    onDidChangeSelection.dispose();
                    onDidReceiveMessage.dispose();
                    this.proxy.$removeKernel(handle);
                }
            },
            updateNotebookAffinity(notebook, priority) {
                that.proxy.$updateNotebookPriority(handle, notebook.uri, priority);
            },
            async postMessage(message, editor) {
                return Promise.resolve(true); // TODO needs implementation
            },
            asWebviewUri(localResource) {
                throw new Error('Method not implemented.');
            }
        };
        this.kernelData.set(handle, {
            extensionId: extensionId,
            controller,
            onDidReceiveMessage,
            onDidChangeSelection,
            associatedNotebooks
        });
        return controller;
    }
    createNotebookCellExecution(cell, controllerId) {
        if (cell.index < 0) {
            throw new Error('CANNOT execute cell that has been REMOVED from notebook');
        }
        const notebook = this.notebooks.getNotebookDocument(types_impl_1.URI.from(cell.notebook.uri));
        const cellObj = notebook.getCellFromApiCell(cell);
        if (!cellObj) {
            throw new Error('invalid cell');
        }
        if (this.activeExecutions.has(cellObj.uri.toString())) {
            throw new Error(`duplicate execution for ${cellObj.uri}`);
        }
        const execution = new NotebookCellExecutionTask(controllerId, cellObj, this.proxy);
        this.activeExecutions.set(cellObj.uri.toString(), execution);
        const listener = execution.onDidChangeState(() => {
            if (execution.state === NotebookCellExecutionTaskState.Resolved) {
                execution.dispose();
                listener.dispose();
                this.activeExecutions.delete(cellObj.uri.toString());
            }
        });
        return execution.asApiObject();
    }
    createNotebookControllerDetectionTask(viewType) {
        const handle = this.currentKernelDetectionTaskHandle++;
        const that = this;
        this.proxy.$addKernelDetectionTask(handle, viewType);
        const detectionTask = {
            dispose: () => {
                this.kernelDetectionTasks.delete(handle);
                that.proxy.$removeKernelDetectionTask(handle);
            }
        };
        this.kernelDetectionTasks.set(handle, detectionTask);
        return detectionTask;
    }
    registerKernelSourceActionProvider(viewType, provider) {
        const handle = this.currentSourceActionProviderHandle++;
        const eventHandle = typeof provider.onDidChangeNotebookKernelSourceActions === 'function' ? handle : undefined;
        const that = this;
        this.kernelSourceActionProviders.set(handle, provider);
        this.proxy.$addKernelSourceActionProvider(handle, handle, viewType);
        let subscription;
        if (eventHandle !== undefined) {
            subscription = provider.onDidChangeNotebookKernelSourceActions(_ => this.proxy.$emitNotebookKernelSourceActionsChangeEvent(eventHandle));
        }
        return {
            dispose: () => {
                this.kernelSourceActionProviders.delete(handle);
                that.proxy.$removeKernelSourceActionProvider(handle, handle);
                subscription === null || subscription === void 0 ? void 0 : subscription.dispose();
            }
        };
    }
    $acceptNotebookAssociation(handle, uri, value) {
        const obj = this.kernelData.get(handle);
        if (obj) {
            // update data structure
            const notebook = this.notebooks.getNotebookDocument(types_impl_1.URI.from(uri));
            if (value) {
                obj.associatedNotebooks.set(notebook.uri.toString(), true);
            }
            else {
                obj.associatedNotebooks.delete(notebook.uri.toString());
            }
            console.debug(`NotebookController[${handle}] ASSOCIATE notebook`, notebook.uri.toString(), value);
            // send event
            obj.onDidChangeSelection.fire({
                selected: value,
                notebook: notebook.apiNotebook
            });
        }
    }
    async $executeCells(handle, uri, handles) {
        const obj = this.kernelData.get(handle);
        if (!obj) {
            // extension can dispose kernels in the meantime
            return Promise.resolve();
        }
        const document = this.notebooks.getNotebookDocument(types_impl_1.URI.from(uri));
        const cells = [];
        for (const cellHandle of handles) {
            const cell = document.getCell(cellHandle);
            if (cell) {
                cells.push(cell.apiCell);
            }
        }
        try {
            console.debug(`NotebookController[${handle}] EXECUTE cells`, document.uri.toString(), cells.length);
            await obj.controller.executeHandler.call(obj.controller, cells, document.apiNotebook, obj.controller);
        }
        catch (err) {
            console.error(`NotebookController[${handle}] execute cells FAILED`, err);
            console.error(err);
        }
    }
    async $cancelCells(handle, uri, handles) {
        var _a;
        const obj = this.kernelData.get(handle);
        if (!obj) {
            // extension can dispose kernels in the meantime
            return Promise.resolve();
        }
        // cancel or interrupt depends on the controller. When an interrupt handler is used we
        // don't trigger the cancelation token of executions.N
        const document = this.notebooks.getNotebookDocument(types_impl_1.URI.from(uri));
        if (obj.controller.interruptHandler) {
            await obj.controller.interruptHandler.call(obj.controller, document.apiNotebook);
        }
        else {
            for (const cellHandle of handles) {
                const cell = document.getCell(cellHandle);
                if (cell) {
                    (_a = this.activeExecutions.get(cell.uri.toString())) === null || _a === void 0 ? void 0 : _a.cancel();
                }
            }
        }
    }
    $acceptKernelMessageFromRenderer(handle, editorId, message) {
        const obj = this.kernelData.get(handle);
        if (!obj) {
            // extension can dispose kernels in the meantime
            return;
        }
        const editor = this.notebooks.getEditorById(editorId);
        obj.onDidReceiveMessage.fire(Object.freeze({ editor: editor.apiEditor, message }));
    }
    $cellExecutionChanged(uri, cellHandle, state) {
        // Proposed Api though seems needed by jupyter for telemetry
    }
    async $provideKernelSourceActions(handle, token) {
        const provider = this.kernelSourceActionProviders.get(handle);
        if (provider) {
            const disposables = new core_1.DisposableCollection();
            const ret = await provider.provideNotebookKernelSourceActions(token);
            return (ret !== null && ret !== void 0 ? ret : []).map(item => type_converters_1.NotebookKernelSourceAction.from(item, this.commands.converter, disposables));
        }
        return [];
    }
}
exports.NotebookKernelsExtImpl = NotebookKernelsExtImpl;
var NotebookCellExecutionTaskState;
(function (NotebookCellExecutionTaskState) {
    NotebookCellExecutionTaskState[NotebookCellExecutionTaskState["Init"] = 0] = "Init";
    NotebookCellExecutionTaskState[NotebookCellExecutionTaskState["Started"] = 1] = "Started";
    NotebookCellExecutionTaskState[NotebookCellExecutionTaskState["Resolved"] = 2] = "Resolved";
})(NotebookCellExecutionTaskState || (NotebookCellExecutionTaskState = {}));
class NotebookCellExecutionTask {
    constructor(controllerId, cell, proxy) {
        this.cell = cell;
        this.proxy = proxy;
        this._handle = NotebookCellExecutionTask.HANDLE++;
        this._onDidChangeState = new core_1.Emitter();
        this.onDidChangeState = this._onDidChangeState.event;
        this._state = NotebookCellExecutionTaskState.Init;
        this.tokenSource = new core_1.CancellationTokenSource();
        this.collector = new TimeoutBasedCollector(10, updates => this.update(updates));
        this.executionOrder = cell.internalMetadata.executionOrder;
        this.proxy.$createExecution(this._handle, controllerId, this.cell.notebookDocument.uri, this.cell.handle);
    }
    get state() { return this._state; }
    cancel() {
        this.tokenSource.cancel();
    }
    async updateSoon(update) {
        await this.collector.addItem(update);
    }
    async update(update) {
        const updates = Array.isArray(update) ? update : [update];
        return this.proxy.$updateExecution(this._handle, updates);
    }
    verifyStateForOutput() {
        if (this._state === NotebookCellExecutionTaskState.Init) {
            throw new Error('Must call start before modifying cell output');
        }
        if (this._state === NotebookCellExecutionTaskState.Resolved) {
            throw new Error('Cannot modify cell output after calling resolve');
        }
    }
    cellIndexToHandle(cellOrCellIndex) {
        let cell = this.cell;
        if (cellOrCellIndex) {
            cell = this.cell.notebookDocument.getCellFromApiCell(cellOrCellIndex);
        }
        if (!cell) {
            throw new Error('INVALID cell');
        }
        return cell.handle;
    }
    validateAndConvertOutputs(items) {
        return items.map(output => {
            const newOutput = type_converters_1.NotebookCellOutputConverter.ensureUniqueMimeTypes(output.items, true);
            if (newOutput === output.items) {
                return type_converters_1.NotebookCellOutputConverter.from(output);
            }
            return type_converters_1.NotebookCellOutputConverter.from({
                items: newOutput,
                outputId: output.outputId,
                metadata: output.metadata
            });
        });
    }
    async updateOutputs(outputs, cell, append) {
        const handle = this.cellIndexToHandle(cell);
        const outputDtos = this.validateAndConvertOutputs(Array.isArray(outputs) ? outputs : [outputs]);
        return this.updateSoon({
            editType: common_2.CellExecutionUpdateType.Output,
            cellHandle: handle,
            append,
            outputs: outputDtos
        });
    }
    async updateOutputItems(items, output, append) {
        items = type_converters_1.NotebookCellOutputConverter.ensureUniqueMimeTypes(Array.isArray(items) ? items : [items], true);
        return this.updateSoon({
            editType: common_2.CellExecutionUpdateType.OutputItems,
            items: items.map(type_converters_1.NotebookCellOutputItem.from),
            append
        });
    }
    asApiObject() {
        const that = this;
        const result = {
            get token() { return that.tokenSource.token; },
            get cell() { return that.cell.apiCell; },
            get executionOrder() { return that.executionOrder; },
            set executionOrder(v) {
                that.executionOrder = v;
                that.update([{
                        editType: common_2.CellExecutionUpdateType.ExecutionState,
                        executionOrder: that.executionOrder
                    }]);
            },
            start(startTime) {
                if (that._state === NotebookCellExecutionTaskState.Resolved || that._state === NotebookCellExecutionTaskState.Started) {
                    throw new Error('Cannot call start again');
                }
                that._state = NotebookCellExecutionTaskState.Started;
                that._onDidChangeState.fire();
                that.update({
                    editType: common_2.CellExecutionUpdateType.ExecutionState,
                    runStartTime: startTime
                });
            },
            end(success, endTime) {
                if (that._state === NotebookCellExecutionTaskState.Resolved) {
                    throw new Error('Cannot call resolve twice');
                }
                that._state = NotebookCellExecutionTaskState.Resolved;
                that._onDidChangeState.fire();
                // The last update needs to be ordered correctly and applied immediately,
                // so we use updateSoon and immediately flush.
                that.collector.flush();
                that.proxy.$completeExecution(that._handle, {
                    runEndTime: endTime,
                    lastRunSuccess: success
                });
            },
            clearOutput(cell) {
                that.verifyStateForOutput();
                return that.updateOutputs([], cell, false);
            },
            appendOutput(outputs, cell) {
                that.verifyStateForOutput();
                return that.updateOutputs(outputs, cell, true);
            },
            replaceOutput(outputs, cell) {
                that.verifyStateForOutput();
                return that.updateOutputs(outputs, cell, false);
            },
            appendOutputItems(items, output) {
                that.verifyStateForOutput();
                return that.updateOutputItems(items, output, true);
            },
            replaceOutputItems(items, output) {
                that.verifyStateForOutput();
                return that.updateOutputItems(items, output, false);
            }
        };
        return Object.freeze(result);
    }
    dispose() {
    }
}
NotebookCellExecutionTask.HANDLE = 0;
class TimeoutBasedCollector {
    constructor(delay, callback) {
        this.delay = delay;
        this.callback = callback;
        this.batch = [];
        this.startedTimer = Date.now();
    }
    addItem(item) {
        this.batch.push(item);
        if (!this.currentDeferred) {
            this.currentDeferred = new promise_util_1.Deferred();
            this.startedTimer = Date.now();
            (0, promise_util_1.timeout)(this.delay).then(() => this.flush());
        }
        // This can be called by the extension repeatedly for a long time before the timeout is able to run.
        // Force a flush after the delay.
        if (Date.now() - this.startedTimer > this.delay) {
            return this.flush();
        }
        return this.currentDeferred.promise;
    }
    flush() {
        if (this.batch.length === 0 || !this.currentDeferred) {
            return Promise.resolve();
        }
        const deferred = this.currentDeferred;
        this.currentDeferred = undefined;
        const batch = this.batch;
        this.batch = [];
        return this.callback(batch)
            .finally(() => deferred.resolve());
    }
}
function createKernelId(extensionIdentifier, id) {
    return `${extensionIdentifier}/${id}`;
}
exports.createKernelId = createKernelId;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/notebook/notebook-renderers.js":
/*!***************************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/notebook/notebook-renderers.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookRenderersExtImpl = void 0;
const common_1 = __webpack_require__(/*! ../../common */ "../../packages/plugin-ext/lib/common/index.js");
const notebook_editor_1 = __webpack_require__(/*! ./notebook-editor */ "../../packages/plugin-ext/lib/plugin/notebook/notebook-editor.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../packages/core/lib/common/index.js");
class NotebookRenderersExtImpl {
    constructor(rpc, notebooksExt) {
        this.notebooksExt = notebooksExt;
        this.rendererMessageEmitters = new Map();
        this.proxy = rpc.getProxy(common_1.PLUGIN_RPC_CONTEXT.NOTEBOOK_RENDERERS_MAIN);
    }
    $postRendererMessage(editorId, rendererId, message) {
        var _a;
        const editor = this.notebooksExt.getEditorById(editorId);
        (_a = this.rendererMessageEmitters.get(rendererId)) === null || _a === void 0 ? void 0 : _a.fire({ editor: editor.apiEditor, message });
    }
    createRendererMessaging(rendererId) {
        const messaging = {
            onDidReceiveMessage: (listener, thisArg, disposables) => this.getOrCreateEmitterFor(rendererId).event(listener, thisArg, disposables),
            postMessage: (message, editorOrAlias) => {
                const extHostEditor = editorOrAlias && notebook_editor_1.NotebookEditor.apiEditorsToExtHost.get(editorOrAlias);
                return this.proxy.$postMessage(extHostEditor === null || extHostEditor === void 0 ? void 0 : extHostEditor.id, rendererId, message);
            },
        };
        return messaging;
    }
    getOrCreateEmitterFor(rendererId) {
        let emitter = this.rendererMessageEmitters.get(rendererId);
        if (emitter) {
            return emitter;
        }
        emitter = new core_1.Emitter({
            onLastListenerRemove: () => {
                emitter === null || emitter === void 0 ? void 0 : emitter.dispose();
                this.rendererMessageEmitters.delete(rendererId);
            }
        });
        this.rendererMessageEmitters.set(rendererId, emitter);
        return emitter;
    }
}
exports.NotebookRenderersExtImpl = NotebookRenderersExtImpl;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/notebook/notebooks.js":
/*!******************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/notebook/notebooks.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebooksExtImpl = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "../../packages/core/lib/common/index.js");
const types_impl_1 = __webpack_require__(/*! ../types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const common_1 = __webpack_require__(/*! ../../common */ "../../packages/plugin-ext/lib/common/index.js");
const cache_1 = __webpack_require__(/*! ../../common/cache */ "../../packages/plugin-ext/lib/common/cache.js");
const typeConverters = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const buffer_1 = __webpack_require__(/*! @theia/core/lib/common/buffer */ "../../packages/core/lib/common/buffer.js");
const notebook_document_1 = __webpack_require__(/*! ./notebook-document */ "../../packages/plugin-ext/lib/plugin/notebook/notebook-document.js");
const notebook_editor_1 = __webpack_require__(/*! ./notebook-editor */ "../../packages/plugin-ext/lib/plugin/notebook/notebook-editor.js");
class NotebooksExtImpl {
    constructor(rpc, commands, textDocumentsAndEditors, textDocuments) {
        this.textDocumentsAndEditors = textDocumentsAndEditors;
        this.textDocuments = textDocuments;
        this.notebookStatusBarItemProviders = new Map();
        this.onDidChangeActiveNotebookEditorEmitter = new core_1.Emitter();
        this.onDidChangeActiveNotebookEditor = this.onDidChangeActiveNotebookEditorEmitter.event;
        this.onDidOpenNotebookDocumentEmitter = new core_1.Emitter();
        this.onDidOpenNotebookDocument = this.onDidOpenNotebookDocumentEmitter.event;
        this.onDidCloseNotebookDocumentEmitter = new core_1.Emitter();
        this.onDidCloseNotebookDocument = this.onDidCloseNotebookDocumentEmitter.event;
        this.onDidChangeVisibleNotebookEditorsEmitter = new core_1.Emitter();
        this.onDidChangeVisibleNotebookEditors = this.onDidChangeVisibleNotebookEditorsEmitter.event;
        this.visibleNotebookEditors = [];
        this.documents = new Map();
        this.editors = new Map();
        this.statusBarRegistry = new cache_1.Cache('NotebookCellStatusBarCache');
        // --- serialize/deserialize
        this.currentSerializerHandle = 0;
        this.notebookSerializer = new Map();
        this.notebookProxy = rpc.getProxy(common_1.PLUGIN_RPC_CONTEXT.NOTEBOOKS_MAIN);
        this.notebookDocumentsProxy = rpc.getProxy(common_1.PLUGIN_RPC_CONTEXT.NOTEBOOK_DOCUMENTS_MAIN);
        this.notebookEditors = rpc.getProxy(common_1.PLUGIN_RPC_CONTEXT.NOTEBOOK_EDITORS_MAIN);
        commands.registerArgumentProcessor({
            processArgument: (arg) => {
                var _a;
                if (arg && arg.uri && this.documents.has(arg.uri.toString())) {
                    return (_a = this.documents.get(arg.uri.toString())) === null || _a === void 0 ? void 0 : _a.apiNotebook;
                }
                return arg;
            }
        });
    }
    get activeApiNotebookEditor() {
        var _a;
        return (_a = this.activeNotebookEditor) === null || _a === void 0 ? void 0 : _a.apiEditor;
    }
    get visibleApiNotebookEditors() {
        return this.visibleNotebookEditors.map(editor => editor.apiEditor);
    }
    async $provideNotebookCellStatusBarItems(handle, uri, index, token) {
        const provider = this.notebookStatusBarItemProviders.get(handle);
        const revivedUri = core_1.URI.fromComponents(uri);
        const document = this.documents.get(revivedUri.toString());
        if (!document || !provider) {
            return;
        }
        const cell = document.getCellFromIndex(index);
        if (!cell) {
            return;
        }
        const result = await provider.provideCellStatusBarItems(cell.apiCell, token);
        if (!result) {
            return undefined;
        }
        const disposables = new core_1.DisposableCollection();
        const cacheId = this.statusBarRegistry.add([disposables]);
        const resultArr = Array.isArray(result) ? result : [result];
        const items = resultArr.map(item => typeConverters.NotebookStatusBarItem.from(item, this.commandsConverter, disposables));
        return {
            cacheId,
            items
        };
    }
    $releaseNotebookCellStatusBarItems(cacheId) {
        this.statusBarRegistry.delete(cacheId);
    }
    registerNotebookSerializer(plugin, viewType, serializer, options) {
        if (!viewType || !viewType.trim()) {
            throw new Error('viewType cannot be empty or just whitespace');
        }
        const handle = this.currentSerializerHandle++;
        this.notebookSerializer.set(handle, serializer);
        this.notebookProxy.$registerNotebookSerializer(handle, { id: plugin.model.id, location: plugin.pluginUri }, viewType, typeConverters.NotebookDocumentContentOptions.from(options));
        return core_1.Disposable.create(() => {
            this.notebookProxy.$unregisterNotebookSerializer(handle);
        });
    }
    async $dataToNotebook(handle, bytes, token) {
        const serializer = this.notebookSerializer.get(handle);
        if (!serializer) {
            throw new Error('No serializer found');
        }
        const data = await serializer.deserializeNotebook(bytes.buffer, token);
        return typeConverters.NotebookData.from(data);
    }
    async $notebookToData(handle, data, token) {
        const serializer = this.notebookSerializer.get(handle);
        if (!serializer) {
            throw new Error('No serializer found');
        }
        const bytes = await serializer.serializeNotebook(typeConverters.NotebookData.to(data), token);
        return buffer_1.BinaryBuffer.wrap(bytes);
    }
    registerNotebookCellStatusBarItemProvider(notebookType, provider) {
        const handle = this.currentSerializerHandle++;
        const eventHandle = typeof provider.onDidChangeCellStatusBarItems === 'function' ? this.currentSerializerHandle++ : undefined;
        this.notebookStatusBarItemProviders.set(handle, provider);
        this.notebookProxy.$registerNotebookCellStatusBarItemProvider(handle, eventHandle, notebookType);
        let subscription;
        if (eventHandle !== undefined) {
            subscription = provider.onDidChangeCellStatusBarItems(_ => this.notebookProxy.$emitCellStatusBarEvent(eventHandle));
        }
        return core_1.Disposable.create(() => {
            this.notebookStatusBarItemProviders.delete(handle);
            this.notebookProxy.$unregisterNotebookCellStatusBarItemProvider(handle, eventHandle);
            subscription === null || subscription === void 0 ? void 0 : subscription.dispose();
        });
    }
    getEditorById(editorId) {
        const editor = this.editors.get(editorId);
        if (!editor) {
            throw new Error(`unknown text editor: ${editorId}. known editors: ${[...this.editors.keys()]} `);
        }
        return editor;
    }
    getAllApiDocuments() {
        return [...this.documents.values()].map(doc => doc.apiNotebook);
    }
    async $acceptDocumentsAndEditorsDelta(delta) {
        var _a, _b, _c;
        if (delta.removedDocuments) {
            for (const uri of delta.removedDocuments) {
                const revivedUri = core_1.URI.fromComponents(uri);
                const document = this.documents.get(revivedUri.toString());
                if (document) {
                    document.dispose();
                    this.documents.delete(revivedUri.toString());
                    this.onDidCloseNotebookDocumentEmitter.fire(document.apiNotebook);
                }
                for (const editor of this.editors.values()) {
                    if (editor.notebookData.uri.toString() === revivedUri.toString()) {
                        this.editors.delete(editor.id);
                    }
                }
            }
        }
        if (delta.addedDocuments) {
            for (const modelData of delta.addedDocuments) {
                const uri = types_impl_1.URI.from(modelData.uri);
                if (this.documents.has(uri.toString())) {
                    throw new Error(`adding EXISTING notebook ${uri} `);
                }
                const document = new notebook_document_1.NotebookDocument(this.notebookDocumentsProxy, this.textDocumentsAndEditors, this.textDocuments, uri, modelData);
                (_a = this.documents.get(uri.toString())) === null || _a === void 0 ? void 0 : _a.dispose();
                this.documents.set(uri.toString(), document);
                this.onDidOpenNotebookDocumentEmitter.fire(document.apiNotebook);
            }
        }
        if (delta.addedEditors) {
            for (const editorModelData of delta.addedEditors) {
                if (this.editors.has(editorModelData.id)) {
                    return;
                }
                const revivedUri = core_1.URI.fromComponents(editorModelData.documentUri);
                const document = this.documents.get(revivedUri.toString());
                if (document) {
                    this.createExtHostEditor(document, editorModelData.id, editorModelData);
                }
            }
        }
        const removedEditors = [];
        if (delta.removedEditors) {
            for (const editorId of delta.removedEditors) {
                const editor = this.editors.get(editorId);
                if (editor) {
                    this.editors.delete(editorId);
                    if (((_b = this.activeNotebookEditor) === null || _b === void 0 ? void 0 : _b.id) === editor.id) {
                        this.activeNotebookEditor = undefined;
                    }
                    removedEditors.push(editor);
                }
            }
        }
        if (delta.visibleEditors) {
            this.visibleNotebookEditors = delta.visibleEditors.map(id => this.editors.get(id)).filter(editor => !!editor);
            const visibleEditorsSet = new Set();
            this.visibleNotebookEditors.forEach(editor => visibleEditorsSet.add(editor.id));
            for (const editor of this.editors.values()) {
                const newValue = visibleEditorsSet.has(editor.id);
                editor.acceptVisibility(newValue);
            }
            this.visibleNotebookEditors = [...this.editors.values()].map(e => e).filter(e => e.visible);
            this.onDidChangeVisibleNotebookEditorsEmitter.fire(this.visibleApiNotebookEditors);
        }
        if (delta.newActiveEditor === null) {
            // clear active notebook as current active editor is non-notebook editor
            this.activeNotebookEditor = undefined;
        }
        else if (delta.newActiveEditor) {
            const activeEditor = this.editors.get(delta.newActiveEditor);
            if (!activeEditor) {
                console.error(`FAILED to find active notebook editor ${delta.newActiveEditor}`);
            }
            this.activeNotebookEditor = this.editors.get(delta.newActiveEditor);
        }
        if (delta.newActiveEditor !== undefined) {
            this.onDidChangeActiveNotebookEditorEmitter.fire((_c = this.activeNotebookEditor) === null || _c === void 0 ? void 0 : _c.apiEditor);
        }
    }
    getNotebookDocument(uri, relaxed) {
        const result = this.documents.get(uri.toString());
        if (!result && !relaxed) {
            throw new Error(`NO notebook document for '${uri}'`);
        }
        return result;
    }
    createExtHostEditor(document, editorId, data) {
        if (this.editors.has(editorId)) {
            throw new Error(`editor with id ALREADY EXISTS: ${editorId}`);
        }
        const editor = new notebook_editor_1.NotebookEditor(editorId, document, data.visibleRanges.map(typeConverters.NotebookRange.to), data.selections.map(typeConverters.NotebookRange.to), typeof data.viewColumn === 'number' ? typeConverters.ViewColumn.to(data.viewColumn) : undefined);
        this.editors.set(editorId, editor);
    }
    async createNotebookDocument(options) {
        const canonicalUri = await this.notebookDocumentsProxy.$tryCreateNotebook({
            viewType: options.viewType,
            content: options.content && typeConverters.NotebookData.from(options.content)
        });
        return types_impl_1.URI.from(canonicalUri);
    }
    async openNotebookDocument(uri) {
        const cached = this.documents.get(uri.toString());
        if (cached) {
            return cached.apiNotebook;
        }
        const canonicalUri = await this.notebookDocumentsProxy.$tryOpenNotebook(uri);
        const document = this.documents.get(core_1.URI.fromComponents(canonicalUri).toString());
        return document === null || document === void 0 ? void 0 : document.apiNotebook;
    }
    async showNotebookDocument(notebookOrUri, options) {
        var _a;
        if (core_1.URI.isUri(notebookOrUri)) {
            notebookOrUri = await this.openNotebookDocument(notebookOrUri);
        }
        const notebook = notebookOrUri;
        let resolvedOptions;
        if (typeof options === 'object') {
            resolvedOptions = {
                position: typeConverters.ViewColumn.from(options.viewColumn),
                preserveFocus: options.preserveFocus,
                selections: options.selections && options.selections.map(typeConverters.NotebookRange.from),
                pinned: typeof options.preview === 'boolean' ? !options.preview : undefined
            };
        }
        else {
            resolvedOptions = {
                preserveFocus: false
            };
        }
        const editorId = await this.notebookEditors.$tryShowNotebookDocument(notebook.uri, notebook.notebookType, resolvedOptions);
        const editor = editorId && ((_a = this.editors.get(editorId)) === null || _a === void 0 ? void 0 : _a.apiEditor);
        if (editor) {
            return editor;
        }
        if (editorId) {
            throw new Error(`Could NOT open editor for "${notebook.uri.toString()}" because another editor opened in the meantime.`);
        }
        else {
            throw new Error(`Could NOT open editor for "${notebook.uri.toString()}".`);
        }
    }
}
exports.NotebooksExtImpl = NotebooksExtImpl;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/notification.js":
/*!************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/notification.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotificationExtImpl = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const cancellation_1 = __webpack_require__(/*! @theia/core/lib/common/cancellation */ "../../packages/core/lib/common/cancellation.js");
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../../packages/core/lib/common/promise-util.js");
class NotificationExtImpl {
    constructor(rpc) {
        this.mapProgressIdToCancellationSource = new Map();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.NOTIFICATION_MAIN);
    }
    async withProgress(options, task) {
        const source = new cancellation_1.CancellationTokenSource();
        const id = new promise_util_1.Deferred();
        const progress = task({ report: async (item) => this.proxy.$updateProgress(await id.promise, item) }, source.token);
        const title = options.title ? options.title : '';
        const location = this.mapLocation(options.location);
        const cancellable = options.cancellable;
        id.resolve(await this.proxy.$startProgress({ title, location, cancellable }));
        if (cancellable) {
            const progressId = await id.promise;
            this.mapProgressIdToCancellationSource.set(progressId, source);
        }
        const stop = async () => this.proxy.$stopProgress(await id.promise);
        const promise = Promise.all([
            progress,
            new Promise(resolve => setTimeout(resolve, 250)) // try to show even if it's done immediately
        ]);
        promise.then(stop, stop);
        return progress;
    }
    $acceptProgressCanceled(id) {
        const source = this.mapProgressIdToCancellationSource.get(id);
        if (source) {
            source.cancel();
            this.mapProgressIdToCancellationSource.delete(id);
        }
    }
    mapLocation(location) {
        if (typeof location === 'object') {
            return location.viewId;
        }
        switch (location) {
            case types_impl_1.ProgressLocation.Notification: return 'notification';
            case types_impl_1.ProgressLocation.SourceControl: return 'scm';
            case types_impl_1.ProgressLocation.Window: return 'window';
            default: return undefined;
        }
    }
}
exports.NotificationExtImpl = NotificationExtImpl;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/output-channel-registry.js":
/*!***********************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/output-channel-registry.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OutputChannelRegistryExtImpl = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const types_1 = __webpack_require__(/*! ../common/types */ "../../packages/plugin-ext/lib/common/types.js");
const log_output_channel_1 = __webpack_require__(/*! ./output-channel/log-output-channel */ "../../packages/plugin-ext/lib/plugin/output-channel/log-output-channel.js");
const output_channel_item_1 = __webpack_require__(/*! ./output-channel/output-channel-item */ "../../packages/plugin-ext/lib/plugin/output-channel/output-channel-item.js");
class OutputChannelRegistryExtImpl {
    constructor(rpc) {
        this.proxy = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.OUTPUT_CHANNEL_REGISTRY_MAIN);
    }
    createOutputChannel(name, pluginInfo, options) {
        name = name.trim();
        if (!name) {
            throw new Error('illegal argument \'name\'. must not be falsy');
        }
        const isLogOutput = options && (0, types_1.isObject)(options);
        return isLogOutput
            ? this.doCreateLogOutputChannel(name, pluginInfo)
            : this.doCreateOutputChannel(name, pluginInfo);
    }
    doCreateOutputChannel(name, pluginInfo) {
        return new output_channel_item_1.OutputChannelImpl(name, this.proxy, pluginInfo);
    }
    doCreateLogOutputChannel(name, pluginInfo) {
        return new log_output_channel_1.LogOutputChannelImpl(name, this.proxy, pluginInfo);
    }
}
exports.OutputChannelRegistryExtImpl = OutputChannelRegistryExtImpl;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/output-channel/log-output-channel.js":
/*!*********************************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/output-channel/log-output-channel.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 STMicroelectronics and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogOutputChannelImpl = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "../../packages/core/shared/vscode-languageserver-protocol/index.js");
const output_channel_item_1 = __webpack_require__(/*! ./output-channel-item */ "../../packages/plugin-ext/lib/plugin/output-channel/output-channel-item.js");
const types_impl_1 = __webpack_require__(/*! ../types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../packages/core/lib/common/index.js");
class LogOutputChannelImpl extends output_channel_item_1.OutputChannelImpl {
    constructor(name, proxy, pluginInfo) {
        super(name, proxy, pluginInfo);
        this.onDidChangeLogLevelEmitter = new vscode_languageserver_protocol_1.Emitter();
        this.onDidChangeLogLevel = this.onDidChangeLogLevelEmitter.event;
        this.setLogLevel(types_impl_1.LogLevel.Info);
    }
    setLogLevel(level) {
        if (this.logLevel !== level) {
            this.logLevel = level;
            this.onDidChangeLogLevelEmitter.fire(this.logLevel);
        }
    }
    getLogLevel() {
        return this.logLevel;
    }
    append(value) {
        super.validate();
        this.info(value);
    }
    appendLine(value) {
        super.validate();
        this.append(value + '\n');
    }
    dispose() {
        super.dispose();
        this.onDidChangeLogLevelEmitter.dispose();
    }
    log(level, message) {
        super.validate();
        if (this.checkLogLevel(level)) {
            const now = new Date();
            const eol = message.endsWith('\n') ? '' : '\n';
            const logMessage = `${now.toISOString()} [${types_impl_1.LogLevel[level]}] ${message}${eol}`;
            this.proxy.$append(this.name, logMessage, this.pluginInfo);
        }
    }
    checkLogLevel(level) {
        return this.logLevel <= level;
    }
    trace(message, ...args) {
        this.log(types_impl_1.LogLevel.Trace, this.format(message, args));
    }
    debug(message, ...args) {
        this.log(types_impl_1.LogLevel.Debug, this.format(message, args));
    }
    info(message, ...args) {
        this.log(types_impl_1.LogLevel.Info, this.format(message, args));
    }
    warn(message, ...args) {
        this.log(types_impl_1.LogLevel.Warning, this.format(message, args));
    }
    error(errorMsg, ...args) {
        if (errorMsg instanceof Error) {
            this.log(types_impl_1.LogLevel.Error, this.format(errorMsg.stack || errorMsg.message, args));
        }
        else {
            this.log(types_impl_1.LogLevel.Error, this.format(errorMsg, args));
        }
    }
    format(message, args) {
        if (args.length > 0) {
            return `${message} ${args.map((arg) => (0, core_1.isObject)(arg) || (0, core_1.isArray)(arg) ? JSON.stringify(arg) : arg).join(' ')}`;
        }
        return message;
    }
}
exports.LogOutputChannelImpl = LogOutputChannelImpl;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/output-channel/output-channel-item.js":
/*!**********************************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/output-channel/output-channel-item.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OutputChannelImpl = void 0;
class OutputChannelImpl {
    constructor(name, proxy, pluginInfo) {
        this.name = name;
        this.proxy = proxy;
        this.pluginInfo = pluginInfo;
    }
    dispose() {
        if (!this.disposed) {
            this.proxy.$dispose(this.name).then(() => {
                this.disposed = true;
            });
        }
    }
    append(value) {
        this.validate();
        this.proxy.$append(this.name, value, this.pluginInfo);
    }
    appendLine(value) {
        this.validate();
        this.append(value + '\n');
    }
    replace(value) {
        this.validate();
        this.clear();
        this.append(value);
    }
    clear() {
        this.validate();
        this.proxy.$clear(this.name);
    }
    show(preserveFocusOrColumn, preserveFocus) {
        this.validate();
        if (typeof preserveFocusOrColumn === 'boolean') {
            preserveFocus = preserveFocusOrColumn;
        }
        this.proxy.$reveal(this.name, !!preserveFocus);
    }
    hide() {
        this.validate();
        this.proxy.$close(this.name);
    }
    validate() {
        if (this.disposed) {
            throw new Error('Channel has been closed');
        }
    }
}
exports.OutputChannelImpl = OutputChannelImpl;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/path.js":
/*!****************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/path.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.join = exports.normalize = void 0;
const separator = '/';
function normalize(path) {
    if (!path || path.length === 0) {
        return '.';
    }
    const isAbsolute = path.charCodeAt(0) === 47;
    const trailingSlash = path.charCodeAt(path.length - 1) === 47;
    const parts = path.split(separator);
    const result = [];
    for (let i = 0; i < parts.length; i++) {
        const p = parts[i];
        if (p === '') {
            continue;
        }
        if (p === '..') {
            result.pop();
            continue;
        }
        result.push(p);
    }
    if (result.length === 0) {
        return '.';
    }
    path = result.join(separator);
    if (isAbsolute) {
        path = '/' + path;
    }
    if (trailingSlash) {
        path += '/';
    }
    return path;
}
exports.normalize = normalize;
function join(...paths) {
    if (paths.length === 0) {
        return '.';
    }
    const path = paths.join(separator);
    return normalize(path);
}
exports.join = join;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/plugin-context.js":
/*!**************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/plugin-context.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018-2022 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Plugin_pluginManager, _PluginExt_pluginManager;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginExt = exports.Plugin = exports.createAPIFactory = void 0;
const command_registry_1 = __webpack_require__(/*! ./command-registry */ "../../packages/plugin-ext/lib/plugin/command-registry.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../packages/core/lib/common/event.js");
const cancellation_1 = __webpack_require__(/*! @theia/core/lib/common/cancellation */ "../../packages/core/lib/common/cancellation.js");
const quick_open_1 = __webpack_require__(/*! ./quick-open */ "../../packages/plugin-ext/lib/plugin/quick-open.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const status_bar_message_registry_1 = __webpack_require__(/*! ./status-bar-message-registry */ "../../packages/plugin-ext/lib/plugin/status-bar-message-registry.js");
const window_state_1 = __webpack_require__(/*! ./window-state */ "../../packages/plugin-ext/lib/plugin/window-state.js");
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const authentication_ext_1 = __webpack_require__(/*! ./authentication-ext */ "../../packages/plugin-ext/lib/plugin/authentication-ext.js");
const plugin_api_rpc_model_1 = __webpack_require__(/*! ../common/plugin-api-rpc-model */ "../../packages/plugin-ext/lib/common/plugin-api-rpc-model.js");
const text_editors_1 = __webpack_require__(/*! ./text-editors */ "../../packages/plugin-ext/lib/plugin/text-editors.js");
const documents_1 = __webpack_require__(/*! ./documents */ "../../packages/plugin-ext/lib/plugin/documents.js");
const editor_options_1 = __webpack_require__(/*! ../common/editor-options */ "../../packages/plugin-ext/lib/common/editor-options.js");
const output_channel_registry_1 = __webpack_require__(/*! ./output-channel-registry */ "../../packages/plugin-ext/lib/plugin/output-channel-registry.js");
const terminal_ext_1 = __webpack_require__(/*! ./terminal-ext */ "../../packages/plugin-ext/lib/plugin/terminal-ext.js");
const languages_1 = __webpack_require__(/*! ./languages */ "../../packages/plugin-ext/lib/plugin/languages.js");
const type_converters_1 = __webpack_require__(/*! ./type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const dialogs_1 = __webpack_require__(/*! ./dialogs */ "../../packages/plugin-ext/lib/plugin/dialogs.js");
const notification_1 = __webpack_require__(/*! ./notification */ "../../packages/plugin-ext/lib/plugin/notification.js");
const language_selector_1 = __webpack_require__(/*! @theia/editor/lib/common/language-selector */ "../../packages/editor/lib/common/language-selector.js");
const markdown_string_1 = __webpack_require__(/*! ./markdown-string */ "../../packages/plugin-ext/lib/plugin/markdown-string.js");
const tree_views_1 = __webpack_require__(/*! ./tree/tree-views */ "../../packages/plugin-ext/lib/plugin/tree/tree-views.js");
const connection_1 = __webpack_require__(/*! ../common/connection */ "../../packages/plugin-ext/lib/common/connection.js");
const tasks_1 = __webpack_require__(/*! ./tasks/tasks */ "../../packages/plugin-ext/lib/plugin/tasks/tasks.js");
const file_system_ext_impl_1 = __webpack_require__(/*! ./file-system-ext-impl */ "../../packages/plugin-ext/lib/plugin/file-system-ext-impl.js");
const scm_1 = __webpack_require__(/*! ./scm */ "../../packages/plugin-ext/lib/plugin/scm.js");
const decorations_1 = __webpack_require__(/*! ./decorations */ "../../packages/plugin-ext/lib/plugin/decorations.js");
const file_system_event_service_ext_impl_1 = __webpack_require__(/*! ./file-system-event-service-ext-impl */ "../../packages/plugin-ext/lib/plugin/file-system-event-service-ext-impl.js");
const label_service_1 = __webpack_require__(/*! ../plugin/label-service */ "../../packages/plugin-ext/lib/plugin/label-service.js");
const tests_api_1 = __webpack_require__(/*! ./stubs/tests-api */ "../../packages/plugin-ext/lib/plugin/stubs/tests-api.js");
const timeline_1 = __webpack_require__(/*! ./timeline */ "../../packages/plugin-ext/lib/plugin/timeline.js");
const theming_1 = __webpack_require__(/*! ./theming */ "../../packages/plugin-ext/lib/plugin/theming.js");
const comments_1 = __webpack_require__(/*! ./comments */ "../../packages/plugin-ext/lib/plugin/comments.js");
const custom_editors_1 = __webpack_require__(/*! ./custom-editors */ "../../packages/plugin-ext/lib/plugin/custom-editors.js");
const webview_views_1 = __webpack_require__(/*! ./webview-views */ "../../packages/plugin-ext/lib/plugin/webview-views.js");
const common_1 = __webpack_require__(/*! ../common */ "../../packages/plugin-ext/lib/common/index.js");
const endpoint_1 = __webpack_require__(/*! @theia/core/lib/browser/endpoint */ "../../packages/core/lib/browser/endpoint.js");
const files_1 = __webpack_require__(/*! @theia/filesystem/lib/common/files */ "../../packages/filesystem/lib/common/files.js");
const tabs_1 = __webpack_require__(/*! ./tabs */ "../../packages/plugin-ext/lib/plugin/tabs.js");
const notebooks_1 = __webpack_require__(/*! ./notebook/notebooks */ "../../packages/plugin-ext/lib/plugin/notebook/notebooks.js");
const telemetry_ext_1 = __webpack_require__(/*! ./telemetry-ext */ "../../packages/plugin-ext/lib/plugin/telemetry-ext.js");
const notebook_document_1 = __webpack_require__(/*! ./notebook/notebook-document */ "../../packages/plugin-ext/lib/plugin/notebook/notebook-document.js");
const notebook_renderers_1 = __webpack_require__(/*! ./notebook/notebook-renderers */ "../../packages/plugin-ext/lib/plugin/notebook/notebook-renderers.js");
const notebook_kernels_1 = __webpack_require__(/*! ./notebook/notebook-kernels */ "../../packages/plugin-ext/lib/plugin/notebook/notebook-kernels.js");
const notebook_documents_1 = __webpack_require__(/*! ./notebook/notebook-documents */ "../../packages/plugin-ext/lib/plugin/notebook/notebook-documents.js");
const notebook_editors_1 = __webpack_require__(/*! ./notebook/notebook-editors */ "../../packages/plugin-ext/lib/plugin/notebook/notebook-editors.js");
function createAPIFactory(rpc, pluginManager, envExt, debugExt, preferenceRegistryExt, editorsAndDocumentsExt, workspaceExt, messageRegistryExt, clipboard, webviewExt, localizationExt) {
    const authenticationExt = rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.AUTHENTICATION_EXT, new authentication_ext_1.AuthenticationExtImpl(rpc));
    const commandRegistry = rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.COMMAND_REGISTRY_EXT, new command_registry_1.CommandRegistryImpl(rpc));
    const quickOpenExt = rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.QUICK_OPEN_EXT, new quick_open_1.QuickOpenExtImpl(rpc));
    const dialogsExt = new dialogs_1.DialogsExtImpl(rpc);
    const windowStateExt = rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.WINDOW_STATE_EXT, new window_state_1.WindowStateExtImpl(rpc));
    const notificationExt = rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.NOTIFICATION_EXT, new notification_1.NotificationExtImpl(rpc));
    const editors = rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.TEXT_EDITORS_EXT, new text_editors_1.TextEditorsExtImpl(rpc, editorsAndDocumentsExt));
    const documents = rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.DOCUMENTS_EXT, new documents_1.DocumentsExtImpl(rpc, editorsAndDocumentsExt));
    const notebooksExt = rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.NOTEBOOKS_EXT, new notebooks_1.NotebooksExtImpl(rpc, commandRegistry, editorsAndDocumentsExt, documents));
    const notebookEditors = rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.NOTEBOOK_EDITORS_EXT, new notebook_editors_1.NotebookEditorsExtImpl(notebooksExt));
    const notebookRenderers = rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.NOTEBOOK_RENDERERS_EXT, new notebook_renderers_1.NotebookRenderersExtImpl(rpc, notebooksExt));
    const notebookKernels = rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.NOTEBOOK_KERNELS_EXT, new notebook_kernels_1.NotebookKernelsExtImpl(rpc, notebooksExt, commandRegistry));
    const notebookDocuments = rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.NOTEBOOK_DOCUMENTS_EXT, new notebook_documents_1.NotebookDocumentsExtImpl(notebooksExt));
    const statusBarMessageRegistryExt = new status_bar_message_registry_1.StatusBarMessageRegistryExt(rpc);
    const terminalExt = rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.TERMINAL_EXT, new terminal_ext_1.TerminalServiceExtImpl(rpc));
    const outputChannelRegistryExt = rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.OUTPUT_CHANNEL_REGISTRY_EXT, new output_channel_registry_1.OutputChannelRegistryExtImpl(rpc));
    const treeViewsExt = rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.TREE_VIEWS_EXT, new tree_views_1.TreeViewsExtImpl(rpc, commandRegistry));
    const tasksExt = rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.TASKS_EXT, new tasks_1.TasksExtImpl(rpc, terminalExt));
    const connectionExt = rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.CONNECTION_EXT, new connection_1.ConnectionImpl(rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.CONNECTION_MAIN)));
    const fileSystemExt = rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.FILE_SYSTEM_EXT, new file_system_ext_impl_1.FileSystemExtImpl(rpc));
    const languagesExt = rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.LANGUAGES_EXT, new languages_1.LanguagesExtImpl(rpc, documents, commandRegistry, fileSystemExt));
    const extHostFileSystemEvent = rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.ExtHostFileSystemEventService, new file_system_event_service_ext_impl_1.ExtHostFileSystemEventService(rpc, editorsAndDocumentsExt));
    const scmExt = rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.SCM_EXT, new scm_1.ScmExtImpl(rpc, commandRegistry));
    const decorationsExt = rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.DECORATIONS_EXT, new decorations_1.DecorationsExtImpl(rpc));
    const labelServiceExt = rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.LABEL_SERVICE_EXT, new label_service_1.LabelServiceExtImpl(rpc));
    const timelineExt = rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.TIMELINE_EXT, new timeline_1.TimelineExtImpl(rpc, commandRegistry));
    const themingExt = rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.THEMING_EXT, new theming_1.ThemingExtImpl(rpc));
    const commentsExt = rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.COMMENTS_EXT, new comments_1.CommentsExtImpl(rpc, commandRegistry, documents));
    const tabsExt = rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.TABS_EXT, new tabs_1.TabsExtImpl(rpc));
    const customEditorExt = rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.CUSTOM_EDITORS_EXT, new custom_editors_1.CustomEditorsExtImpl(rpc, documents, webviewExt, workspaceExt));
    const webviewViewsExt = rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.WEBVIEW_VIEWS_EXT, new webview_views_1.WebviewViewsExtImpl(rpc, webviewExt));
    const telemetryExt = rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.TELEMETRY_EXT, new telemetry_ext_1.TelemetryExtImpl());
    rpc.set(plugin_api_rpc_1.MAIN_RPC_CONTEXT.DEBUG_EXT, debugExt);
    return function (plugin) {
        const authentication = {
            registerAuthenticationProvider(id, label, provider, options) {
                return authenticationExt.registerAuthenticationProvider(id, label, provider, options);
            },
            getSession(providerId, scopes, options) {
                return authenticationExt.getSession(plugin, providerId, scopes, options);
            },
            get onDidChangeSessions() {
                return authenticationExt.onDidChangeSessions;
            }
        };
        function commandIsDeclaredInPackage(id, model) {
            var _a;
            const rawCommands = (_a = model.contributes) === null || _a === void 0 ? void 0 : _a.commands;
            if (!rawCommands) {
                return false;
            }
            return Array.isArray(rawCommands) ? rawCommands.some(candidate => candidate.command === id) : rawCommands.command === id;
        }
        const commands = {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            registerCommand(command, handler, thisArg) {
                // use of the ID when registering commands
                if (typeof command === 'string') {
                    if (handler && commandIsDeclaredInPackage(command, plugin.rawModel)) {
                        return commandRegistry.registerHandler(command, handler, thisArg);
                    }
                    return commandRegistry.registerCommand({ id: command }, handler, thisArg);
                }
                return commandRegistry.registerCommand(command, handler, thisArg);
            },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            executeCommand(commandId, ...args) {
                return commandRegistry.executeCommand(commandId, ...args);
            },
            registerTextEditorCommand(command, handler, thisArg) {
                const internalHandler = (...args) => {
                    const activeTextEditor = editors.getActiveEditor();
                    if (!activeTextEditor) {
                        console.warn('Cannot execute ' + command + ' because there is no active text editor.');
                        return undefined;
                    }
                    return activeTextEditor.edit((edit) => {
                        args.unshift(activeTextEditor, edit);
                        handler.apply(thisArg, args);
                    }).then(result => {
                        if (!result) {
                            console.warn('Edits from command ' + command + ' were not applied.');
                        }
                    }, err => {
                        console.warn('An error occurred while running command ' + command, err);
                    });
                };
                return commandIsDeclaredInPackage(command, plugin.rawModel)
                    ? commandRegistry.registerHandler(command, internalHandler)
                    : commandRegistry.registerCommand({ id: command }, internalHandler);
            },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            registerHandler(commandId, handler, thisArg) {
                return commandRegistry.registerHandler(commandId, handler, thisArg);
            },
            getKeyBinding(commandId) {
                return commandRegistry.getKeyBinding(commandId);
            },
            getCommands(filterInternal = false) {
                return commandRegistry.getCommands(filterInternal);
            },
            registerDiffInformationCommand(command, callback, thisArg) {
                // Dummy implementation.
                return new types_impl_1.Disposable(() => { });
            }
        };
        const { onDidChangeActiveTerminal, onDidChangeTerminalState, onDidCloseTerminal, onDidOpenTerminal } = terminalExt;
        const showInformationMessage = messageRegistryExt.showMessage.bind(messageRegistryExt, plugin_api_rpc_1.MainMessageType.Info);
        const showWarningMessage = messageRegistryExt.showMessage.bind(messageRegistryExt, plugin_api_rpc_1.MainMessageType.Warning);
        const showErrorMessage = messageRegistryExt.showMessage.bind(messageRegistryExt, plugin_api_rpc_1.MainMessageType.Error);
        const window = {
            get activeTerminal() {
                return terminalExt.activeTerminal;
            },
            get activeTextEditor() {
                return editors.getActiveEditor();
            },
            get visibleTextEditors() {
                return editors.getVisibleTextEditors();
            },
            get terminals() {
                return terminalExt.terminals;
            },
            onDidChangeActiveTerminal,
            onDidChangeActiveTextEditor(listener, thisArg, disposables) {
                return editors.onDidChangeActiveTextEditor(listener, thisArg, disposables);
            },
            onDidChangeVisibleTextEditors(listener, thisArg, disposables) {
                return editors.onDidChangeVisibleTextEditors(listener, thisArg, disposables);
            },
            onDidChangeTextEditorSelection(listener, thisArg, disposables) {
                return editors.onDidChangeTextEditorSelection(listener, thisArg, disposables);
            },
            onDidChangeTextEditorOptions(listener, thisArg, disposables) {
                return editors.onDidChangeTextEditorOptions(listener, thisArg, disposables);
            },
            onDidChangeTextEditorViewColumn(listener, thisArg, disposables) {
                return editors.onDidChangeTextEditorViewColumn(listener, thisArg, disposables);
            },
            onDidChangeTextEditorVisibleRanges(listener, thisArg, disposables) {
                return editors.onDidChangeTextEditorVisibleRanges(listener, thisArg, disposables);
            },
            async showTextDocument(documentArg, columnOrOptions, preserveFocus) {
                let documentOptions;
                const uri = documentArg instanceof types_impl_1.URI ? documentArg : documentArg.uri;
                if (typeof columnOrOptions === 'number') {
                    documentOptions = {
                        viewColumn: columnOrOptions
                    };
                }
                else if (columnOrOptions && (columnOrOptions.preserveFocus || columnOrOptions.preview || columnOrOptions.selection || columnOrOptions.viewColumn)) {
                    documentOptions = {
                        ...columnOrOptions
                    };
                }
                if (preserveFocus) {
                    if (documentOptions) {
                        documentOptions.preserveFocus = preserveFocus;
                    }
                    else {
                        documentOptions = { preserveFocus };
                    }
                }
                await documents.showDocument(uri, documentOptions);
                const textEditor = editors.getVisibleTextEditors().find(editor => editor.document.uri.toString() === uri.toString());
                if (textEditor) {
                    return Promise.resolve(textEditor);
                }
                else {
                    throw new Error(`Failed to show text document ${documentArg.toString()}`);
                }
            },
            get visibleNotebookEditors() {
                return notebooksExt.visibleApiNotebookEditors;
            },
            onDidChangeVisibleNotebookEditors(listener, thisArg, disposables) {
                return notebooksExt.onDidChangeVisibleNotebookEditors(listener, thisArg, disposables);
            },
            get activeNotebookEditor() {
                return notebooksExt.activeApiNotebookEditor;
            }, onDidChangeActiveNotebookEditor(listener, thisArg, disposables) {
                return notebooksExt.onDidChangeActiveNotebookEditor(listener, thisArg, disposables);
            },
            onDidChangeNotebookEditorSelection(listener, thisArg, disposables) {
                return notebookEditors.onDidChangeNotebookEditorSelection(listener, thisArg, disposables);
            },
            onDidChangeNotebookEditorVisibleRanges(listener, thisArg, disposables) {
                return notebookEditors.onDidChangeNotebookEditorVisibleRanges(listener, thisArg, disposables);
            },
            showNotebookDocument(document, options) {
                return notebooksExt.showNotebookDocument(document, options);
            },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            showQuickPick(items, options, token) {
                return quickOpenExt.showQuickPick(items, options, token);
            },
            createQuickPick() {
                return quickOpenExt.createQuickPick(plugin);
            },
            showWorkspaceFolderPick(options) {
                return workspaceExt.pickWorkspaceFolder(options);
            },
            showInformationMessage,
            showWarningMessage,
            showErrorMessage,
            showOpenDialog(options) {
                return dialogsExt.showOpenDialog(options);
            },
            showSaveDialog(options) {
                return dialogsExt.showSaveDialog(options);
            },
            showUploadDialog(options) {
                return dialogsExt.showUploadDialog(options);
            },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            setStatusBarMessage(text, arg) {
                return statusBarMessageRegistryExt.setStatusBarMessage(text, arg);
            },
            showInputBox(options, token) {
                return quickOpenExt.showInput(options, token);
            },
            createStatusBarItem(alignmentOrId, priorityOrAlignment, priorityArg) {
                let id;
                let alignment;
                let priority;
                if (typeof alignmentOrId === 'string') {
                    id = alignmentOrId;
                    alignment = priorityOrAlignment;
                    priority = priorityArg;
                }
                else {
                    alignment = alignmentOrId;
                    priority = priorityOrAlignment;
                }
                return statusBarMessageRegistryExt.createStatusBarItem(alignment, priority, id);
            },
            createOutputChannel(name, options) {
                return !options
                    ? outputChannelRegistryExt.createOutputChannel(name, (0, type_converters_1.pluginToPluginInfo)(plugin))
                    : outputChannelRegistryExt.createOutputChannel(name, (0, type_converters_1.pluginToPluginInfo)(plugin), options);
            },
            createWebviewPanel(viewType, title, showOptions, options = {}) {
                return webviewExt.createWebview(viewType, title, showOptions, options, plugin);
            },
            registerWebviewPanelSerializer(viewType, serializer) {
                return webviewExt.registerWebviewPanelSerializer(viewType, serializer, plugin);
            },
            registerCustomEditorProvider(viewType, provider, options = {}) {
                return customEditorExt.registerCustomEditorProvider(viewType, provider, options, plugin);
            },
            registerWebviewViewProvider(viewType, provider, options) {
                return webviewViewsExt.registerWebviewViewProvider(viewType, provider, plugin, options === null || options === void 0 ? void 0 : options.webviewOptions);
            },
            get state() {
                return windowStateExt.getWindowState();
            },
            onDidChangeWindowState(listener, thisArg, disposables) {
                return windowStateExt.onDidChangeWindowState(listener, thisArg, disposables);
            },
            createTerminal(nameOrOptions, shellPath, shellArgs) {
                return terminalExt.createTerminal(nameOrOptions, shellPath, shellArgs);
            },
            onDidChangeTerminalState,
            onDidCloseTerminal,
            onDidOpenTerminal,
            createTextEditorDecorationType(options) {
                return editors.createTextEditorDecorationType(options);
            },
            registerTreeDataProvider(viewId, treeDataProvider) {
                return treeViewsExt.registerTreeDataProvider(plugin, viewId, treeDataProvider);
            },
            createTreeView(viewId, options) {
                return treeViewsExt.createTreeView(plugin, viewId, options);
            },
            withScmProgress(task) {
                const options = { location: types_impl_1.ProgressLocation.SourceControl };
                return notificationExt.withProgress(options, () => task({ report() { } }));
            },
            withProgress(options, task) {
                return notificationExt.withProgress(options, task);
            },
            registerFileDecorationProvider(provider) {
                return decorationsExt.registerFileDecorationProvider(provider, (0, type_converters_1.pluginToPluginInfo)(plugin));
            },
            registerUriHandler(handler) {
                // TODO ?
                return new types_impl_1.Disposable(() => { });
            },
            createInputBox() {
                return quickOpenExt.createInputBox(plugin);
            },
            registerTerminalLinkProvider(provider) {
                return terminalExt.registerTerminalLinkProvider(provider);
            },
            registerTerminalProfileProvider(id, provider) {
                return terminalExt.registerTerminalProfileProvider(id, provider);
            },
            get activeColorTheme() {
                return themingExt.activeColorTheme;
            },
            onDidChangeActiveColorTheme(listener, thisArg, disposables) {
                return themingExt.onDidChangeActiveColorTheme(listener, thisArg, disposables);
            },
            get tabGroups() {
                return tabsExt.tabGroups;
            },
            /** @stubbed ExternalUriOpener */
            registerExternalUriOpener(id, opener, metadata) {
                return types_impl_1.Disposable.NULL;
            },
            /** @stubbed ProfileContentHandler */
            registerProfileContentHandler(id, profileContentHandler) {
                return types_impl_1.Disposable.NULL;
            },
            /** @stubbed TerminalQuickFixProvider */
            registerTerminalQuickFixProvider(id, provider) {
                return terminalExt.registerTerminalQuickFixProvider(id, provider);
            },
            /** @stubbed ShareProvider */
            registerShareProvider: () => types_impl_1.Disposable.NULL,
        };
        const workspace = {
            get fs() {
                return fileSystemExt.fileSystem;
            },
            get rootPath() {
                return workspaceExt.rootPath;
            },
            get workspaceFolders() {
                return workspaceExt.workspaceFolders;
            },
            get workspaceFile() {
                return workspaceExt.workspaceFile;
            },
            get name() {
                return workspaceExt.name;
            },
            onDidChangeWorkspaceFolders(listener, thisArg, disposables) {
                return workspaceExt.onDidChangeWorkspaceFolders(listener, thisArg, disposables);
            },
            get notebookDocuments() {
                return notebooksExt.getAllApiDocuments();
            },
            get textDocuments() {
                return documents.getAllDocumentData().map(data => data.document);
            },
            onDidChangeTextDocument(listener, thisArg, disposables) {
                return documents.onDidChangeDocument(listener, thisArg, disposables);
            },
            onDidCloseTextDocument(listener, thisArg, disposables) {
                return documents.onDidRemoveDocument(listener, thisArg, disposables);
            },
            onDidOpenNotebookDocument(listener, thisArg, disposables) {
                return notebooksExt.onDidOpenNotebookDocument(listener, thisArg, disposables);
            },
            onDidCloseNotebookDocument(listener, thisArg, disposables) {
                return notebooksExt.onDidCloseNotebookDocument(listener, thisArg, disposables);
            },
            onWillSaveNotebookDocument(listener, thisArg, disposables) {
                return types_impl_1.Disposable.NULL;
            },
            onDidSaveNotebookDocument(listener, thisArg, disposables) {
                return notebookDocuments.onDidSaveNotebookDocument(listener, thisArg, disposables);
            },
            onDidChangeNotebookDocument(listener, thisArg, disposables) {
                return notebookDocuments.onDidChangeNotebookDocument(listener, thisArg, disposables);
            },
            onDidOpenTextDocument(listener, thisArg, disposables) {
                return documents.onDidAddDocument(listener, thisArg, disposables);
            },
            onWillSaveTextDocument(listener, thisArg, disposables) {
                return documents.onWillSaveTextDocument(listener, thisArg, disposables);
            },
            onDidSaveTextDocument(listener, thisArg, disposables) {
                return documents.onDidSaveTextDocument(listener, thisArg, disposables);
            },
            onDidCreateFiles: (listener, thisArg, disposables) => extHostFileSystemEvent.onDidCreateFile(listener, thisArg, disposables),
            onDidDeleteFiles: (listener, thisArg, disposables) => extHostFileSystemEvent.onDidDeleteFile(listener, thisArg, disposables),
            onDidRenameFiles: (listener, thisArg, disposables) => extHostFileSystemEvent.onDidRenameFile(listener, thisArg, disposables),
            onWillCreateFiles: (listener, thisArg, disposables) => extHostFileSystemEvent.getOnWillCreateFileEvent(plugin)(listener, thisArg, disposables),
            onWillDeleteFiles: (listener, thisArg, disposables) => extHostFileSystemEvent.getOnWillDeleteFileEvent(plugin)(listener, thisArg, disposables),
            onWillRenameFiles: (listener, thisArg, disposables) => extHostFileSystemEvent.getOnWillRenameFileEvent(plugin)(listener, thisArg, disposables),
            getConfiguration(section, resource) {
                return preferenceRegistryExt.getConfiguration(section, resource);
            },
            onDidChangeConfiguration(listener, thisArgs, disposables) {
                return preferenceRegistryExt.onDidChangeConfiguration(listener, thisArgs, disposables);
            },
            async openTextDocument(uriOrFileNameOrOptions) {
                const options = uriOrFileNameOrOptions;
                let uri;
                if (typeof uriOrFileNameOrOptions === 'string') {
                    uri = types_impl_1.URI.file(uriOrFileNameOrOptions);
                }
                else if (uriOrFileNameOrOptions instanceof types_impl_1.URI) {
                    uri = uriOrFileNameOrOptions;
                }
                else if (!options || typeof options === 'object') {
                    uri = await documents.createDocumentData(options);
                }
                else {
                    return Promise.reject(new Error('illegal argument - uriOrFileNameOrOptions'));
                }
                const data = await documents.openDocument(uri);
                return data && data.document;
            },
            async openNotebookDocument(uriOrType, content) {
                let uri;
                if (types_impl_1.URI.isUri(uriOrType)) {
                    uri = uriOrType;
                    await notebooksExt.openNotebookDocument(uriOrType);
                }
                else if (typeof uriOrType === 'string') {
                    uri = types_impl_1.URI.revive(await notebooksExt.createNotebookDocument({ viewType: uriOrType, content }));
                }
                else {
                    throw new Error('Invalid arguments');
                }
                return notebooksExt.getNotebookDocument(uri).apiNotebook;
            },
            createFileSystemWatcher: (pattern, ignoreCreate, ignoreChange, ignoreDelete) => extHostFileSystemEvent.createFileSystemWatcher((0, type_converters_1.fromGlobPattern)(pattern), ignoreCreate, ignoreChange, ignoreDelete),
            findFiles(include, exclude, maxResults, token) {
                return workspaceExt.findFiles(include, exclude, maxResults, token);
            },
            findTextInFiles(query, optionsOrCallback, callbackOrToken, token) {
                return workspaceExt.findTextInFiles(query, optionsOrCallback, callbackOrToken, token);
            },
            saveAll(includeUntitled) {
                return editors.saveAll(includeUntitled);
            },
            applyEdit(edit, metadata) {
                return editors.applyWorkspaceEdit(edit, metadata);
            },
            registerTextDocumentContentProvider(scheme, provider) {
                return workspaceExt.registerTextDocumentContentProvider(scheme, provider);
            },
            registerFileSystemProvider(scheme, provider, options) {
                return fileSystemExt.registerFileSystemProvider(scheme, provider, options);
            },
            getWorkspaceFolder(uri) {
                return workspaceExt.getWorkspaceFolder(uri);
            },
            asRelativePath(pathOrUri, includeWorkspace) {
                return workspaceExt.getRelativePath(pathOrUri, includeWorkspace);
            },
            updateWorkspaceFolders: (index, deleteCount, ...workspaceFoldersToAdd) => workspaceExt.updateWorkspaceFolders(index, deleteCount || 0, ...workspaceFoldersToAdd),
            registerTaskProvider(type, provider) {
                return tasks.registerTaskProvider(type, provider);
            },
            registerResourceLabelFormatter(formatter) {
                return labelServiceExt.$registerResourceLabelFormatter(formatter);
            },
            registerTimelineProvider(scheme, provider) {
                return timelineExt.registerTimelineProvider(plugin, scheme, provider);
            },
            registerNotebookSerializer(notebookType, serializer, options) {
                return notebooksExt.registerNotebookSerializer(plugin, notebookType, serializer, options);
            },
            get isTrusted() {
                return workspaceExt.trusted;
            },
            async requestWorkspaceTrust(options) {
                return workspaceExt.requestWorkspaceTrust(options);
            },
            get onDidGrantWorkspaceTrust() {
                return workspaceExt.onDidGrantWorkspaceTrust;
            },
            registerEditSessionIdentityProvider(scheme, provider) {
                return workspaceExt.$registerEditSessionIdentityProvider(scheme, provider);
            },
            /**
             * @stubbed
             * This is a stub implementation, that should minimally satisfy vscode built-in extensions
             * that currently use this proposed API.
             */
            onWillCreateEditSessionIdentity: () => types_impl_1.Disposable.NULL,
            registerCanonicalUriProvider(scheme, provider) {
                return workspaceExt.registerCanonicalUriProvider(scheme, provider);
            },
            getCanonicalUri(uri, options, token) {
                return workspaceExt.getCanonicalUri(uri, options, token);
            }
        };
        const onDidChangeLogLevel = new event_1.Emitter();
        const env = Object.freeze({
            get appName() { return envExt.appName; },
            get appRoot() { return envExt.appRoot; },
            get appHost() { return envExt.appHost; },
            get language() { return envExt.language; },
            get isNewAppInstall() { return envExt.isNewAppInstall; },
            get isTelemetryEnabled() { return telemetryExt.isTelemetryEnabled; },
            get onDidChangeTelemetryEnabled() {
                return telemetryExt.onDidChangeTelemetryEnabled;
            },
            createTelemetryLogger(sender, options) {
                return telemetryExt.createTelemetryLogger(sender, options);
            },
            get remoteName() { return envExt.remoteName; },
            get machineId() { return envExt.machineId; },
            get sessionId() { return envExt.sessionId; },
            get uriScheme() { return envExt.uriScheme; },
            get shell() { return envExt.shell; },
            get uiKind() { return envExt.uiKind; },
            clipboard,
            getEnvVariable(envVarName) {
                return envExt.getEnvVariable(envVarName);
            },
            getQueryParameter(queryParamName) {
                return envExt.getQueryParameter(queryParamName);
            },
            getQueryParameters() {
                return envExt.getQueryParameters();
            },
            getClientOperatingSystem() {
                return envExt.getClientOperatingSystem();
            },
            openExternal(uri) {
                return windowStateExt.openUri(uri);
            },
            asExternalUri(target) {
                return windowStateExt.asExternalUri(target);
            },
            get logLevel() { return types_impl_1.LogLevel.Info; },
            get onDidChangeLogLevel() { return onDidChangeLogLevel.event; }
        });
        const extensions = Object.freeze({
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            getExtension(extensionId, includeFromDifferentExtensionHosts = false) {
                includeFromDifferentExtensionHosts = false;
                const plg = pluginManager.getPluginById(extensionId.toLowerCase());
                if (plg) {
                    return new PluginExt(pluginManager, plg);
                }
                return undefined;
            },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            get all() {
                return pluginManager.getAllPlugins().map(plg => new PluginExt(pluginManager, plg));
            },
            get allAcrossExtensionHosts() {
                // we only support one extension host ATM so equivalent to calling "all()"
                return this.all;
            },
            get onDidChange() {
                return pluginManager.onDidChange;
            }
        });
        const languages = {
            getLanguages() {
                return languagesExt.getLanguages();
            },
            setTextDocumentLanguage(document, languageId) {
                return languagesExt.changeLanguage(document.uri, languageId);
            },
            match(selector, document) {
                return (0, language_selector_1.score)((0, type_converters_1.fromDocumentSelector)(selector), document.uri.scheme, document.uri.path, document.languageId, true);
            },
            get onDidChangeDiagnostics() {
                return languagesExt.onDidChangeDiagnostics;
            },
            getDiagnostics(resource) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                return languagesExt.getDiagnostics(resource);
            },
            createDiagnosticCollection(name) {
                return languagesExt.createDiagnosticCollection(name);
            },
            setLanguageConfiguration(language, configuration) {
                return languagesExt.setLanguageConfiguration(language, configuration);
            },
            registerCompletionItemProvider(selector, provider, ...triggerCharacters) {
                return languagesExt.registerCompletionItemProvider(selector, provider, triggerCharacters, (0, type_converters_1.pluginToPluginInfo)(plugin));
            },
            registerInlineCompletionItemProvider(selector, provider) {
                return languagesExt.registerInlineCompletionsProvider(selector, provider);
            },
            registerDefinitionProvider(selector, provider) {
                return languagesExt.registerDefinitionProvider(selector, provider, (0, type_converters_1.pluginToPluginInfo)(plugin));
            },
            registerDeclarationProvider(selector, provider) {
                return languagesExt.registerDeclarationProvider(selector, provider, (0, type_converters_1.pluginToPluginInfo)(plugin));
            },
            registerSignatureHelpProvider(selector, provider, first, ...remaining) {
                let metadata;
                if (typeof first === 'object') {
                    metadata = first;
                }
                else {
                    const triggerCharacters = [];
                    metadata = { triggerCharacters, retriggerCharacters: [] };
                    if (first) {
                        triggerCharacters.push(first, ...remaining);
                    }
                }
                return languagesExt.registerSignatureHelpProvider(selector, provider, metadata, (0, type_converters_1.pluginToPluginInfo)(plugin));
            },
            registerTypeDefinitionProvider(selector, provider) {
                return languagesExt.registerTypeDefinitionProvider(selector, provider, (0, type_converters_1.pluginToPluginInfo)(plugin));
            },
            registerImplementationProvider(selector, provider) {
                return languagesExt.registerImplementationProvider(selector, provider, (0, type_converters_1.pluginToPluginInfo)(plugin));
            },
            registerHoverProvider(selector, provider) {
                return languagesExt.registerHoverProvider(selector, provider, (0, type_converters_1.pluginToPluginInfo)(plugin));
            },
            registerEvaluatableExpressionProvider(selector, provider) {
                return languagesExt.registerEvaluatableExpressionProvider(selector, provider, (0, type_converters_1.pluginToPluginInfo)(plugin));
            },
            registerInlineValuesProvider(selector, provider) {
                return languagesExt.registerInlineValuesProvider(selector, provider, (0, type_converters_1.pluginToPluginInfo)(plugin));
            },
            registerDocumentHighlightProvider(selector, provider) {
                return languagesExt.registerDocumentHighlightProvider(selector, provider, (0, type_converters_1.pluginToPluginInfo)(plugin));
            },
            registerWorkspaceSymbolProvider(provider) {
                return languagesExt.registerWorkspaceSymbolProvider(provider, (0, type_converters_1.pluginToPluginInfo)(plugin));
            },
            registerDocumentFormattingEditProvider(selector, provider) {
                return languagesExt.registerDocumentFormattingEditProvider(selector, provider, (0, type_converters_1.pluginToPluginInfo)(plugin));
            },
            registerDocumentRangeFormattingEditProvider(selector, provider) {
                return languagesExt.registerDocumentRangeFormattingEditProvider(selector, provider, (0, type_converters_1.pluginToPluginInfo)(plugin));
            },
            registerOnTypeFormattingEditProvider(selector, provider, firstTriggerCharacter, ...moreTriggerCharacters) {
                return languagesExt.registerOnTypeFormattingEditProvider(selector, provider, [firstTriggerCharacter].concat(moreTriggerCharacters), (0, type_converters_1.pluginToPluginInfo)(plugin));
            },
            registerDocumentDropEditProvider(selector, provider, metadata) {
                return languagesExt.registerDocumentDropEditProvider(selector, provider, metadata);
            },
            registerDocumentLinkProvider(selector, provider) {
                return languagesExt.registerDocumentLinkProvider(selector, provider, (0, type_converters_1.pluginToPluginInfo)(plugin));
            },
            registerCodeActionsProvider(selector, provider, metadata) {
                return languagesExt.registerCodeActionsProvider(selector, provider, plugin.model, (0, type_converters_1.pluginToPluginInfo)(plugin), metadata);
            },
            registerCodeLensProvider(selector, provider) {
                return languagesExt.registerCodeLensProvider(selector, provider, (0, type_converters_1.pluginToPluginInfo)(plugin));
            },
            registerReferenceProvider(selector, provider) {
                return languagesExt.registerReferenceProvider(selector, provider, (0, type_converters_1.pluginToPluginInfo)(plugin));
            },
            registerDocumentSymbolProvider(selector, provider, metadata) {
                return languagesExt.registerDocumentSymbolProvider(selector, provider, (0, type_converters_1.pluginToPluginInfo)(plugin), metadata);
            },
            registerColorProvider(selector, provider) {
                return languagesExt.registerColorProvider(selector, provider, (0, type_converters_1.pluginToPluginInfo)(plugin));
            },
            registerInlayHintsProvider(selector, provider) {
                return languagesExt.registerInlayHintsProvider(selector, provider, (0, type_converters_1.pluginToPluginInfo)(plugin));
            },
            registerFoldingRangeProvider(selector, provider) {
                return languagesExt.registerFoldingRangeProvider(selector, provider, (0, type_converters_1.pluginToPluginInfo)(plugin));
            },
            registerSelectionRangeProvider(selector, provider) {
                return languagesExt.registerSelectionRangeProvider(selector, provider, (0, type_converters_1.pluginToPluginInfo)(plugin));
            },
            registerRenameProvider(selector, provider) {
                return languagesExt.registerRenameProvider(selector, provider, (0, type_converters_1.pluginToPluginInfo)(plugin));
            },
            registerDocumentSemanticTokensProvider(selector, provider, legend) {
                return languagesExt.registerDocumentSemanticTokensProvider(selector, provider, legend, (0, type_converters_1.pluginToPluginInfo)(plugin));
            },
            registerDocumentRangeSemanticTokensProvider(selector, provider, legend) {
                return languagesExt.registerDocumentRangeSemanticTokensProvider(selector, provider, legend, (0, type_converters_1.pluginToPluginInfo)(plugin));
            },
            registerCallHierarchyProvider(selector, provider) {
                return languagesExt.registerCallHierarchyProvider(selector, provider);
            },
            registerTypeHierarchyProvider(selector, provider) {
                return languagesExt.registerTypeHierarchyProvider(selector, provider);
            },
            registerLinkedEditingRangeProvider(selector, provider) {
                return languagesExt.registerLinkedEditingRangeProvider(selector, provider);
            },
            createLanguageStatusItem(id, selector) {
                return languagesExt.createLanguageStatusItem(plugin, id, selector);
            },
            registerDocumentPasteEditProvider(selector, provider, metadata) {
                return languagesExt.registerDocumentPasteEditProvider(plugin, selector, provider, metadata);
            }
        };
        // Tests API (@stubbed)
        // The following implementation is temporarily `@stubbed` and marked as such under `theia.d.ts`
        const tests = {
            createTestController(provider, controllerLabel, refreshHandler) {
                return {
                    id: provider,
                    label: controllerLabel,
                    items: tests_api_1.testItemCollection,
                    refreshHandler,
                    createRunProfile: tests_api_1.createRunProfile,
                    createTestRun: tests_api_1.createTestRun,
                    createTestItem: tests_api_1.createTestItem,
                    dispose: () => undefined,
                };
            },
        };
        /* End of Tests API */
        const plugins = {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            get all() {
                return pluginManager.getAllPlugins().map(plg => new PluginExt(pluginManager, plg));
            },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            getPlugin(pluginId) {
                const plg = pluginManager.getPluginById(pluginId.toLowerCase());
                if (plg) {
                    return new PluginExt(pluginManager, plg);
                }
                return undefined;
            },
            get onDidChange() {
                return pluginManager.onDidChange;
            }
        };
        const debuggersContributions = plugin.rawModel.contributes && plugin.rawModel.contributes.debuggers || [];
        debugExt.assistedInject(connectionExt, commandRegistry);
        debugExt.registerDebuggersContributions(plugin.pluginFolder, plugin.model.entryPoint.frontend ? 'frontend' : 'backend', debuggersContributions);
        const debug = {
            get activeDebugSession() {
                return debugExt.activeDebugSession;
            },
            get activeDebugConsole() {
                return debugExt.activeDebugConsole;
            },
            get breakpoints() {
                return debugExt.breakpoints;
            },
            get onDidChangeActiveDebugSession() {
                return debugExt.onDidChangeActiveDebugSession;
            },
            get onDidStartDebugSession() {
                return debugExt.onDidStartDebugSession;
            },
            get onDidReceiveDebugSessionCustomEvent() {
                return debugExt.onDidReceiveDebugSessionCustomEvent;
            },
            get onDidTerminateDebugSession() {
                return debugExt.onDidTerminateDebugSession;
            },
            get onDidChangeBreakpoints() {
                return debugExt.onDidChangeBreakpoints;
            },
            registerDebugAdapterDescriptorFactory(debugType, factory) {
                return debugExt.registerDebugAdapterDescriptorFactory(debugType, factory);
            },
            registerDebugConfigurationProvider(debugType, provider, triggerKind) {
                return debugExt.registerDebugConfigurationProvider(debugType, provider, triggerKind || plugin_api_rpc_1.DebugConfigurationProviderTriggerKind.Initial);
            },
            registerDebugAdapterTrackerFactory(debugType, factory) {
                return debugExt.registerDebugAdapterTrackerFactory(debugType, factory);
            },
            startDebugging(folder, nameOrConfiguration, parentSessionOrOptions) {
                if (!parentSessionOrOptions || (typeof parentSessionOrOptions === 'object' && 'configuration' in parentSessionOrOptions)) {
                    return debugExt.startDebugging(folder, nameOrConfiguration, { parentSession: parentSessionOrOptions });
                }
                return debugExt.startDebugging(folder, nameOrConfiguration, parentSessionOrOptions || {});
            },
            stopDebugging(session) {
                return debugExt.stopDebugging(session);
            },
            addBreakpoints(breakpoints) {
                debugExt.addBreakpoints(breakpoints);
            },
            removeBreakpoints(breakpoints) {
                debugExt.removeBreakpoints(breakpoints);
            },
            asDebugSourceUri(source, session) {
                return debugExt.asDebugSourceUri(source, session);
            }
        };
        const tasks = {
            registerTaskProvider(type, provider) {
                return tasksExt.registerTaskProvider(type, provider);
            },
            fetchTasks(filter) {
                return tasksExt.fetchTasks(filter);
            },
            executeTask(task) {
                return tasksExt.executeTask(task);
            },
            get taskExecutions() {
                return tasksExt.taskExecutions;
            },
            onDidStartTask(listener, thisArg, disposables) {
                return tasksExt.onDidStartTask(listener, thisArg, disposables);
            },
            onDidEndTask(listener, thisArg, disposables) {
                return tasksExt.onDidEndTask(listener, thisArg, disposables);
            },
            onDidStartTaskProcess(listener, thisArg, disposables) {
                return tasksExt.onDidStartTaskProcess(listener, thisArg, disposables);
            },
            onDidEndTaskProcess(listener, thisArg, disposables) {
                return tasksExt.onDidEndTaskProcess(listener, thisArg, disposables);
            }
        };
        const scm = {
            get inputBox() {
                const inputBox = scmExt.getLastInputBox(plugin);
                if (inputBox) {
                    return inputBox;
                }
                else {
                    throw new Error('Input box not found!');
                }
            },
            createSourceControl(id, label, rootUri) {
                return scmExt.createSourceControl(plugin, id, label, rootUri);
            }
        };
        const comments = {
            createCommentController(id, label) {
                return commentsExt.createCommentController(plugin, id, label);
            }
        };
        const l10n = {
            // eslint-disable-next-line max-len
            t(...params) {
                if (typeof params[0] === 'string') {
                    const key = params.shift();
                    // We have either rest args which are Array<string | number | boolean> or an array with a single Record<string, any>.
                    // This ensures we get a Record<string | number, any> which will be formatted correctly.
                    const argsFormatted = !params || typeof params[0] !== 'object' ? params : params[0];
                    return localizationExt.translateMessage(plugin.model.id, { message: key, args: argsFormatted });
                }
                return localizationExt.translateMessage(plugin.model.id, params[0]);
            },
            get bundle() {
                return localizationExt.getBundle(plugin.model.id);
            },
            get uri() {
                return localizationExt.getBundleUri(plugin.model.id);
            }
        };
        // notebooks API (@stubbed)
        // The following implementation is temporarily `@stubbed` and marked as such under `theia.d.ts`
        const notebooks = {
            createNotebookController(id, notebookType, label, handler, rendererScripts) {
                return notebookKernels.createNotebookController(plugin.model.id, id, notebookType, label, handler, rendererScripts);
            },
            createRendererMessaging(rendererId) {
                return notebookRenderers.createRendererMessaging(rendererId);
            },
            registerNotebookCellStatusBarItemProvider(notebookType, provider) {
                return notebooksExt.registerNotebookCellStatusBarItemProvider(notebookType, provider);
            },
            onDidChangeNotebookCellExecutionState: notebookKernels.onDidChangeNotebookCellExecutionState,
            createNotebookControllerDetectionTask(notebookType) {
                return notebookKernels.createNotebookControllerDetectionTask(notebookType);
            },
            registerKernelSourceActionProvider(notebookType, provider) {
                return notebookKernels.registerKernelSourceActionProvider(notebookType, provider);
            }
        };
        return {
            version: (__webpack_require__(/*! ../../package.json */ "../../packages/plugin-ext/package.json").version),
            authentication,
            commands,
            comments,
            window,
            workspace,
            env,
            extensions,
            languages,
            plugins,
            debug,
            tasks,
            scm,
            notebooks,
            l10n,
            tests,
            // Types
            StatusBarAlignment: types_impl_1.StatusBarAlignment,
            Disposable: types_impl_1.Disposable,
            EventEmitter: event_1.Emitter,
            CancellationTokenSource: cancellation_1.CancellationTokenSource,
            MarkdownString: markdown_string_1.MarkdownString,
            Position: types_impl_1.Position,
            Range: types_impl_1.Range,
            Selection: types_impl_1.Selection,
            ViewColumn: types_impl_1.ViewColumn,
            TextEditorSelectionChangeKind: types_impl_1.TextEditorSelectionChangeKind,
            Uri: types_impl_1.URI,
            EndOfLine: types_impl_1.EndOfLine,
            TextEditorRevealType: types_impl_1.TextEditorRevealType,
            TextEditorCursorStyle: editor_options_1.TextEditorCursorStyle,
            TextEditorLineNumbersStyle: types_impl_1.TextEditorLineNumbersStyle,
            ThemeColor: types_impl_1.ThemeColor,
            ThemeIcon: types_impl_1.ThemeIcon,
            SnippetString: types_impl_1.SnippetString,
            DecorationRangeBehavior: types_impl_1.DecorationRangeBehavior,
            OverviewRulerLane: types_impl_1.OverviewRulerLane,
            ConfigurationTarget: types_impl_1.ConfigurationTarget,
            RelativePattern: types_impl_1.RelativePattern,
            IndentAction: types_impl_1.IndentAction,
            CompletionItem: types_impl_1.CompletionItem,
            CompletionItemKind: types_impl_1.CompletionItemKind,
            CompletionList: types_impl_1.CompletionList,
            DebugConsoleMode: types_impl_1.DebugConsoleMode,
            DiagnosticSeverity: types_impl_1.DiagnosticSeverity,
            DiagnosticRelatedInformation: types_impl_1.DiagnosticRelatedInformation,
            LanguageStatusSeverity: types_impl_1.LanguageStatusSeverity,
            Location: types_impl_1.Location,
            LogLevel: types_impl_1.LogLevel,
            DiagnosticTag: types_impl_1.DiagnosticTag,
            CompletionItemTag: types_impl_1.CompletionItemTag,
            Diagnostic: types_impl_1.Diagnostic,
            CompletionTriggerKind: types_impl_1.CompletionTriggerKind,
            TextEdit: types_impl_1.TextEdit,
            SnippetTextEdit: types_impl_1.SnippetTextEdit,
            ProgressLocation: types_impl_1.ProgressLocation,
            ProgressOptions: types_impl_1.ProgressOptions,
            Progress: types_impl_1.Progress,
            ParameterInformation: types_impl_1.ParameterInformation,
            QuickPickItemKind: types_impl_1.QuickPickItemKind,
            SignatureInformation: types_impl_1.SignatureInformation,
            SignatureHelp: types_impl_1.SignatureHelp,
            SignatureHelpTriggerKind: types_impl_1.SignatureHelpTriggerKind,
            Hover: types_impl_1.Hover,
            EvaluatableExpression: types_impl_1.EvaluatableExpression,
            InlineValueEvaluatableExpression: types_impl_1.InlineValueEvaluatableExpression,
            InlineValueText: types_impl_1.InlineValueText,
            InlineValueVariableLookup: types_impl_1.InlineValueVariableLookup,
            InlineValueContext: types_impl_1.InlineValueContext,
            DocumentHighlightKind: types_impl_1.DocumentHighlightKind,
            DocumentHighlight: types_impl_1.DocumentHighlight,
            DocumentLink: types_impl_1.DocumentLink,
            DocumentDropEdit: types_impl_1.DocumentDropEdit,
            CodeLens: types_impl_1.CodeLens,
            CodeActionKind: types_impl_1.CodeActionKind,
            CodeActionTrigger: types_impl_1.CodeActionTrigger,
            CodeActionTriggerKind: types_impl_1.CodeActionTriggerKind,
            TextDocumentSaveReason: types_impl_1.TextDocumentSaveReason,
            CodeAction: types_impl_1.CodeAction,
            DataTransferItem: types_impl_1.DataTransferItem,
            DataTransfer: types_impl_1.DataTransfer,
            TreeItem: types_impl_1.TreeItem,
            TreeItemCollapsibleState: types_impl_1.TreeItemCollapsibleState,
            TreeItemCheckboxState: types_impl_1.TreeItemCheckboxState,
            SymbolKind: plugin_api_rpc_model_1.SymbolKind,
            SymbolTag: types_impl_1.SymbolTag,
            DocumentSymbol: types_impl_1.DocumentSymbol,
            WorkspaceEdit: types_impl_1.WorkspaceEdit,
            SymbolInformation: types_impl_1.SymbolInformation,
            FileType: types_impl_1.FileType,
            FilePermission: files_1.FilePermission,
            FileChangeType: types_impl_1.FileChangeType,
            ShellQuoting: types_impl_1.ShellQuoting,
            ShellExecution: types_impl_1.ShellExecution,
            ProcessExecution: types_impl_1.ProcessExecution,
            CustomExecution: types_impl_1.CustomExecution,
            TaskScope: types_impl_1.TaskScope,
            TaskRevealKind: types_impl_1.TaskRevealKind,
            TaskPanelKind: types_impl_1.TaskPanelKind,
            TaskGroup: types_impl_1.TaskGroup,
            Task: types_impl_1.Task,
            Task2: types_impl_1.Task2,
            DebugAdapterExecutable: types_impl_1.DebugAdapterExecutable,
            DebugAdapterServer: types_impl_1.DebugAdapterServer,
            DebugAdapterNamedPipeServer: types_impl_1.DebugAdapterNamedPipeServer,
            DebugAdapterInlineImplementation: types_impl_1.DebugAdapterInlineImplementation,
            DebugConfigurationProviderTriggerKind: plugin_api_rpc_1.DebugConfigurationProviderTriggerKind,
            Breakpoint: types_impl_1.Breakpoint,
            SourceBreakpoint: types_impl_1.SourceBreakpoint,
            FunctionBreakpoint: types_impl_1.FunctionBreakpoint,
            Color: types_impl_1.Color,
            ColorInformation: types_impl_1.ColorInformation,
            ColorPresentation: types_impl_1.ColorPresentation,
            FoldingRange: types_impl_1.FoldingRange,
            SelectionRange: types_impl_1.SelectionRange,
            FoldingRangeKind: types_impl_1.FoldingRangeKind,
            OperatingSystem: types_impl_1.OperatingSystem,
            WebviewPanelTargetArea: types_impl_1.WebviewPanelTargetArea,
            UIKind: types_impl_1.UIKind,
            FileSystemError: types_impl_1.FileSystemError,
            CommentThreadState: types_impl_1.CommentThreadState,
            CommentThreadCollapsibleState: types_impl_1.CommentThreadCollapsibleState,
            QuickInputButtons: types_impl_1.QuickInputButtons,
            CommentMode: types_impl_1.CommentMode,
            CallHierarchyItem: types_impl_1.CallHierarchyItem,
            CallHierarchyIncomingCall: types_impl_1.CallHierarchyIncomingCall,
            CallHierarchyOutgoingCall: types_impl_1.CallHierarchyOutgoingCall,
            TypeHierarchyItem: types_impl_1.TypeHierarchyItem,
            TimelineItem: types_impl_1.TimelineItem,
            EnvironmentVariableMutatorType: types_impl_1.EnvironmentVariableMutatorType,
            SemanticTokensLegend: types_impl_1.SemanticTokensLegend,
            SemanticTokensBuilder: types_impl_1.SemanticTokensBuilder,
            SemanticTokens: types_impl_1.SemanticTokens,
            SemanticTokensEdits: types_impl_1.SemanticTokensEdits,
            SemanticTokensEdit: types_impl_1.SemanticTokensEdit,
            TextDocumentChangeReason: types_impl_1.TextDocumentChangeReason,
            ColorThemeKind: types_impl_1.ColorThemeKind,
            SourceControlInputBoxValidationType: types_impl_1.SourceControlInputBoxValidationType,
            FileDecoration: types_impl_1.FileDecoration,
            TerminalLink: types_impl_1.TerminalLink,
            TerminalProfile: types_impl_1.TerminalProfile,
            CancellationError: cancellation_1.CancellationError,
            ExtensionMode: types_impl_1.ExtensionMode,
            LinkedEditingRanges: types_impl_1.LinkedEditingRanges,
            InputBoxValidationSeverity: types_impl_1.InputBoxValidationSeverity,
            InlayHint: types_impl_1.InlayHint,
            InlayHintKind: types_impl_1.InlayHintKind,
            InlayHintLabelPart: types_impl_1.InlayHintLabelPart,
            TelemetryTrustedValue: types_impl_1.TelemetryTrustedValue,
            NotebookCellData: types_impl_1.NotebookCellData,
            NotebookCellExecutionState: types_impl_1.NotebookCellExecutionState,
            NotebookCellKind: types_impl_1.NotebookCellKind,
            NotebookCellOutput: types_impl_1.NotebookCellOutput,
            NotebookCellOutputItem: types_impl_1.NotebookCellOutputItem,
            NotebookCellStatusBarAlignment: types_impl_1.NotebookCellStatusBarAlignment,
            NotebookCellStatusBarItem: types_impl_1.NotebookCellStatusBarItem,
            NotebookControllerAffinity: types_impl_1.NotebookControllerAffinity,
            NotebookData: types_impl_1.NotebookData,
            NotebookEditorRevealType: types_impl_1.NotebookEditorRevealType,
            NotebookDocument: notebook_document_1.NotebookDocument,
            NotebookRange: types_impl_1.NotebookRange,
            NotebookEdit: types_impl_1.NotebookEdit,
            NotebookKernelSourceAction: types_impl_1.NotebookKernelSourceAction,
            NotebookRendererScript: types_impl_1.NotebookRendererScript,
            TestRunProfileKind: types_impl_1.TestRunProfileKind,
            TestTag: types_impl_1.TestTag,
            TestRunRequest: types_impl_1.TestRunRequest,
            TestMessage: types_impl_1.TestMessage,
            ExtensionKind: types_impl_1.ExtensionKind,
            InlineCompletionItem: types_impl_1.InlineCompletionItem,
            InlineCompletionList: types_impl_1.InlineCompletionList,
            InlineCompletionTriggerKind: types_impl_1.InlineCompletionTriggerKind,
            TabInputText: types_impl_1.TextTabInput,
            TabInputTextDiff: types_impl_1.TextDiffTabInput,
            TabInputTextMerge: types_impl_1.TextMergeTabInput,
            TabInputCustom: types_impl_1.CustomEditorTabInput,
            TabInputNotebook: types_impl_1.NotebookEditorTabInput,
            TabInputNotebookDiff: types_impl_1.NotebookDiffEditorTabInput,
            TabInputWebview: types_impl_1.WebviewEditorTabInput,
            TabInputTerminal: types_impl_1.TerminalEditorTabInput,
            TerminalLocation: types_impl_1.TerminalLocation,
            TerminalOutputAnchor: types_impl_1.TerminalOutputAnchor,
            TerminalExitReason: types_impl_1.TerminalExitReason,
            DocumentPasteEdit: types_impl_1.DocumentPasteEdit,
            ExternalUriOpenerPriority: types_impl_1.ExternalUriOpenerPriority,
            TerminalQuickFixType: types_impl_1.TerminalQuickFixType,
            EditSessionIdentityMatch: types_impl_1.EditSessionIdentityMatch
        };
    };
}
exports.createAPIFactory = createAPIFactory;
class Plugin {
    constructor(pluginManager, plugin) {
        _Plugin_pluginManager.set(this, void 0);
        __classPrivateFieldSet(this, _Plugin_pluginManager, pluginManager, "f");
        this.id = plugin.model.id;
        this.pluginPath = plugin.pluginFolder;
        this.packageJSON = plugin.rawModel;
        this.pluginType = plugin.model.entryPoint.frontend ? 'frontend' : 'backend';
        if (this.pluginType === 'frontend') {
            const { origin } = new endpoint_1.Endpoint();
            this.pluginUri = types_impl_1.URI.parse(origin + '/' + common_1.PluginPackage.toPluginUrl(plugin.model, ''));
        }
        else {
            this.pluginUri = types_impl_1.URI.parse(plugin.pluginUri);
        }
    }
    get isActive() {
        return __classPrivateFieldGet(this, _Plugin_pluginManager, "f").isActive(this.id);
    }
    get exports() {
        return __classPrivateFieldGet(this, _Plugin_pluginManager, "f").getPluginExport(this.id);
    }
    activate() {
        return __classPrivateFieldGet(this, _Plugin_pluginManager, "f").activatePlugin(this.id).then(() => this.exports);
    }
}
exports.Plugin = Plugin;
_Plugin_pluginManager = new WeakMap();
class PluginExt extends Plugin {
    constructor(pluginManager, plugin, isFromDifferentExtensionHost = false) {
        super(pluginManager, plugin);
        _PluginExt_pluginManager.set(this, void 0);
        __classPrivateFieldSet(this, _PluginExt_pluginManager, pluginManager, "f");
        this.extensionPath = this.pluginPath;
        this.extensionUri = this.pluginUri;
        this.extensionKind = types_impl_1.ExtensionKind.UI; // stub as a local extension (not running on a remote workspace)
        this.isFromDifferentExtensionHost = isFromDifferentExtensionHost;
    }
    get isActive() {
        return __classPrivateFieldGet(this, _PluginExt_pluginManager, "f").isActive(this.id);
    }
    get exports() {
        return __classPrivateFieldGet(this, _PluginExt_pluginManager, "f").getPluginExport(this.id);
    }
    activate() {
        return __classPrivateFieldGet(this, _PluginExt_pluginManager, "f").activatePlugin(this.id).then(() => this.exports);
    }
}
exports.PluginExt = PluginExt;
_PluginExt_pluginManager = new WeakMap();


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/plugin-icon-path.js":
/*!****************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/plugin-icon-path.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginIconPath = void 0;
const path = __webpack_require__(/*! path */ "path");
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const plugin_protocol_1 = __webpack_require__(/*! ../common/plugin-protocol */ "../../packages/plugin-ext/lib/common/plugin-protocol.js");
var PluginIconPath;
(function (PluginIconPath) {
    function toUrl(iconPath, plugin) {
        if (!iconPath) {
            return undefined;
        }
        if (typeof iconPath === 'object' && 'light' in iconPath) {
            return {
                light: asString(iconPath.light, plugin),
                dark: asString(iconPath.dark, plugin)
            };
        }
        return asString(iconPath, plugin);
    }
    PluginIconPath.toUrl = toUrl;
    function asString(arg, plugin) {
        arg = arg instanceof types_impl_1.URI && arg.scheme === 'file' ? arg.fsPath : arg;
        if (typeof arg !== 'string') {
            return arg.toString(true);
        }
        const { packagePath } = plugin.rawModel;
        const absolutePath = path.isAbsolute(arg) ? arg : path.join(packagePath, arg);
        const normalizedPath = path.normalize(absolutePath);
        const relativePath = path.relative(packagePath, normalizedPath);
        return plugin_protocol_1.PluginPackage.toPluginUrl(plugin.rawModel, relativePath);
    }
    PluginIconPath.asString = asString;
})(PluginIconPath = exports.PluginIconPath || (exports.PluginIconPath = {}));


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/plugin-manager.js":
/*!**************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/plugin-manager.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginManagerExtImpl = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const types = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const path_1 = __webpack_require__(/*! ./path */ "../../packages/plugin-ext/lib/plugin/path.js");
const plugin_storage_1 = __webpack_require__(/*! ./plugin-storage */ "../../packages/plugin-ext/lib/plugin/plugin-storage.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../packages/core/lib/common/event.js");
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const secrets_ext_1 = __webpack_require__(/*! ../plugin/secrets-ext */ "../../packages/plugin-ext/lib/plugin/secrets-ext.js");
const plugin_context_1 = __webpack_require__(/*! ./plugin-context */ "../../packages/plugin-ext/lib/plugin/plugin-context.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../../packages/core/lib/common/promise-util.js");
class ActivatedPlugin {
    constructor(pluginContext, exports, stopFn) {
        this.pluginContext = pluginContext;
        this.exports = exports;
        this.stopFn = stopFn;
    }
}
class PluginManagerExtImpl {
    constructor(host, envExt, terminalService, storageProxy, secrets, preferencesManager, webview, localization, rpc) {
        this.host = host;
        this.envExt = envExt;
        this.terminalService = terminalService;
        this.storageProxy = storageProxy;
        this.secrets = secrets;
        this.preferencesManager = preferencesManager;
        this.webview = webview;
        this.localization = localization;
        this.rpc = rpc;
        this.registry = new Map();
        this.activations = new Map();
        /** promises to whether loading each plugin has been successful */
        this.loadedPlugins = new Map();
        this.activatedPlugins = new Map();
        this.pluginContextsMap = new Map();
        this.onDidChangeEmitter = new event_1.Emitter();
        this.jsonValidation = [];
        this.ready = new promise_util_1.Deferred();
        this.messageRegistryProxy = this.rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.MESSAGE_REGISTRY_MAIN);
        this.notificationMain = this.rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.NOTIFICATION_MAIN);
    }
    fireOnDidChange() {
        this.onDidChangeEmitter.fire(undefined);
    }
    async $stop(pluginId) {
        if (!pluginId) {
            return this.stopAll();
        }
        this.registry.delete(pluginId);
        this.pluginContextsMap.delete(pluginId);
        this.loadedPlugins.delete(pluginId);
        const plugin = this.activatedPlugins.get(pluginId);
        if (!plugin) {
            return;
        }
        this.activatedPlugins.delete(pluginId);
        return this.stopPlugin(pluginId, plugin);
    }
    async terminate() {
        return this.stopAll({ terminating: true });
    }
    async stopAll(options = { terminating: false }) {
        const promises = [];
        for (const [id, plugin] of this.activatedPlugins) {
            promises.push(this.stopPlugin(id, plugin, options));
        }
        this.registry.clear();
        this.loadedPlugins.clear();
        this.activatedPlugins.clear();
        this.pluginContextsMap.clear();
        await Promise.all(promises);
    }
    async stopPlugin(id, plugin, options = { terminating: false }) {
        let result;
        if (plugin.stopFn) {
            try {
                result = plugin.stopFn();
            }
            catch (e) {
                if (!options.terminating) {
                    console.error(`[${id}]: failed to stop:`, e);
                }
            }
        }
        const pluginContext = plugin.pluginContext;
        if (pluginContext) {
            for (const subscription of pluginContext.subscriptions) {
                try {
                    subscription.dispose();
                }
                catch (e) {
                    if (!options.terminating) {
                        console.error(`[${id}]: failed to dispose subscription:`, e);
                    }
                }
            }
        }
        try {
            await result;
        }
        catch (e) {
            if (!options.terminating) {
                console.error(`[${id}]: failed to stop:`, e);
            }
        }
    }
    async $init(params) {
        this.storageProxy.init(params.globalState, params.workspaceState);
        this.envExt.setQueryParameters(params.env.queryParams);
        this.envExt.setLanguage(params.env.language);
        this.envExt.setShell(params.env.shell);
        this.envExt.setUIKind(params.env.uiKind);
        this.envExt.setApplicationName(params.env.appName);
        this.envExt.setAppHost(params.env.appHost);
        this.preferencesManager.init(params.preferences);
        if (params.extApi) {
            this.host.initExtApi(params.extApi);
        }
        this.webview.init(params.webview);
        this.jsonValidation = params.jsonValidation;
    }
    async $start(params) {
        this.configStorage = params.configStorage;
        const [plugins, foreignPlugins] = await this.host.init(params.plugins);
        // add foreign plugins
        for (const plugin of foreignPlugins) {
            this.registerPlugin(plugin);
        }
        // add own plugins, before initialization
        for (const plugin of plugins) {
            this.registerPlugin(plugin);
        }
        // ensure plugins are registered before running activation events
        this.ready.resolve();
        // run eager plugins
        await this.$activateByEvent('*');
        for (const activationEvent of params.activationEvents) {
            await this.$activateByEvent(activationEvent);
        }
        if (this.host.loadTests) {
            return this.host.loadTests();
        }
        this.fireOnDidChange();
    }
    registerPlugin(plugin) {
        if (plugin.model.id === 'vscode.json-language-features' && this.jsonValidation.length) {
            // VS Code contributes all built-in validations via vscode.json-language-features;
            // we enrich them with Theia validations registered on startup.
            // Dynamic validations can be provided only via VS Code extensions.
            // Content is fetched by the extension later via vscode.workspace.openTextDocument.
            const contributes = plugin.rawModel.contributes = (plugin.rawModel.contributes || {});
            contributes.jsonValidation = (contributes.jsonValidation || []).concat(this.jsonValidation);
        }
        this.registry.set(plugin.model.id, plugin);
        if (plugin.pluginPath && Array.isArray(plugin.rawModel.activationEvents)) {
            const activation = () => this.$activatePlugin(plugin.model.id);
            // an internal activation event is a subject to change
            this.setActivation(`onPlugin:${plugin.model.id}`, activation);
            const unsupportedActivationEvents = plugin.rawModel.activationEvents.filter(e => !PluginManagerExtImpl.SUPPORTED_ACTIVATION_EVENTS.has(e.split(':')[0]));
            if (unsupportedActivationEvents.length) {
                console.warn(`Unsupported activation events: ${unsupportedActivationEvents.join(', ')}, please open an issue: https://github.com/eclipse-theia/theia/issues/new`);
            }
            for (let activationEvent of plugin.rawModel.activationEvents) {
                if (activationEvent === 'onUri') {
                    activationEvent = `onUri:theia://${plugin.model.id}`;
                }
                this.setActivation(activationEvent, activation);
            }
        }
    }
    setActivation(activationEvent, activation) {
        const activations = this.activations.get(activationEvent) || [];
        activations.push(activation);
        this.activations.set(activationEvent, activations);
    }
    async loadPlugin(plugin, configStorage, visited = new Set()) {
        // in order to break cycles
        if (visited.has(plugin.model.id)) {
            return true;
        }
        visited.add(plugin.model.id);
        let loading = this.loadedPlugins.get(plugin.model.id);
        if (!loading) {
            loading = (async () => {
                const progressId = await this.notificationMain.$startProgress({
                    title: `Activating ${plugin.model.displayName || plugin.model.name}`,
                    location: 'window'
                });
                try {
                    if (plugin.rawModel.extensionDependencies) {
                        for (const dependencyId of plugin.rawModel.extensionDependencies) {
                            const dependency = this.registry.get(dependencyId.toLowerCase());
                            if (dependency) {
                                const loadedSuccessfully = await this.loadPlugin(dependency, configStorage, visited);
                                if (!loadedSuccessfully) {
                                    throw new Error(`Dependent extension '${dependency.model.displayName || dependency.model.id}' failed to activate.`);
                                }
                            }
                            else {
                                throw new Error(`Dependent extension '${dependencyId}' is not installed.`);
                            }
                        }
                    }
                    let pluginMain = this.host.loadPlugin(plugin);
                    // see https://github.com/TypeFox/vscode/blob/70b8db24a37fafc77247de7f7cb5bb0195120ed0/src/vs/workbench/api/common/extHostExtensionService.ts#L372-L376
                    pluginMain = pluginMain || {};
                    await this.startPlugin(plugin, configStorage, pluginMain);
                    return true;
                }
                catch (err) {
                    const message = `Activating extension '${plugin.model.displayName || plugin.model.name}' failed:`;
                    this.messageRegistryProxy.$showMessage(plugin_api_rpc_1.MainMessageType.Error, message + ' ' + err.message, {}, []);
                    console.error(message, err);
                    return false;
                }
                finally {
                    this.notificationMain.$stopProgress(progressId);
                }
            })();
        }
        this.loadedPlugins.set(plugin.model.id, loading);
        return loading;
    }
    async $updateStoragePath(path) {
        if (this.configStorage) {
            this.configStorage.hostStoragePath = path;
        }
        this.pluginContextsMap.forEach((pluginContext, pluginId) => {
            pluginContext.storagePath = path ? (0, path_1.join)(path, pluginId) : undefined;
        });
    }
    async $activateByEvent(activationEvent) {
        // Prevent the plugin manager from performing activations before plugins are registered
        await this.ready.promise;
        if (activationEvent.endsWith(':*')) {
            const baseEvent = activationEvent.substring(0, activationEvent.length - 2);
            await this.activateByBaseEvent(baseEvent);
        }
        else {
            await this.activateBySingleEvent(activationEvent);
        }
    }
    async activateByBaseEvent(baseEvent) {
        await Promise.all(Array.from(this.activations.keys(), activation => activation.startsWith(baseEvent) && this.activateBySingleEvent(activation)));
    }
    async activateBySingleEvent(activationEvent) {
        const activations = this.activations.get(activationEvent);
        if (!activations) {
            return;
        }
        this.activations.set(activationEvent, undefined);
        const pendingActivations = [];
        while (activations.length) {
            pendingActivations.push(activations.pop()());
        }
        await Promise.all(pendingActivations);
    }
    async $activatePlugin(id) {
        const plugin = this.registry.get(id);
        if (plugin && this.configStorage) {
            await this.loadPlugin(plugin, this.configStorage);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async startPlugin(plugin, configStorage, pluginMain) {
        const subscriptions = [];
        const asAbsolutePath = (relativePath) => (0, path_1.join)(plugin.pluginFolder, relativePath);
        const logPath = (0, path_1.join)(configStorage.hostLogPath, plugin.model.id); // todo check format
        const storagePath = configStorage.hostStoragePath ? (0, path_1.join)(configStorage.hostStoragePath, plugin.model.id) : undefined;
        const secrets = new secrets_ext_1.SecretStorageExt(plugin, this.secrets);
        const globalStoragePath = (0, path_1.join)(configStorage.hostGlobalStoragePath, plugin.model.id);
        const extension = new plugin_context_1.PluginExt(this, plugin);
        const extensionModeValue = plugin.isUnderDevelopment ? types.ExtensionMode.Development : types.ExtensionMode.Production;
        const pluginContext = {
            extensionPath: extension.extensionPath,
            extensionUri: extension.extensionUri,
            globalState: new plugin_storage_1.GlobalState(plugin.model.id, true, this.storageProxy),
            workspaceState: new plugin_storage_1.Memento(plugin.model.id, false, this.storageProxy),
            subscriptions: subscriptions,
            asAbsolutePath: asAbsolutePath,
            logPath: logPath,
            storagePath: storagePath,
            storageUri: storagePath ? types_impl_1.URI.file(storagePath) : undefined,
            secrets,
            globalStoragePath: globalStoragePath,
            globalStorageUri: types_impl_1.URI.file(globalStoragePath),
            environmentVariableCollection: this.terminalService.getEnvironmentVariableCollection(plugin.model.id),
            extensionMode: extensionModeValue,
            extension,
            logUri: types_impl_1.URI.file(logPath)
        };
        this.pluginContextsMap.set(plugin.model.id, pluginContext);
        let stopFn = undefined;
        if (typeof pluginMain[plugin.lifecycle.stopMethod] === 'function') {
            stopFn = pluginMain[plugin.lifecycle.stopMethod];
        }
        const id = plugin.model.displayName || plugin.model.id;
        if (typeof pluginMain[plugin.lifecycle.startMethod] === 'function') {
            await this.localization.initializeLocalizedMessages(plugin, this.envExt.language);
            const pluginExport = await pluginMain[plugin.lifecycle.startMethod].apply(getGlobal(), [pluginContext]);
            console.log(`calling activation function on ${id}`);
            this.activatedPlugins.set(plugin.model.id, new ActivatedPlugin(pluginContext, pluginExport, stopFn));
        }
        else {
            // https://github.com/TypeFox/vscode/blob/70b8db24a37fafc77247de7f7cb5bb0195120ed0/src/vs/workbench/api/common/extHostExtensionService.ts#L400-L401
            console.log(`plugin ${id}, ${plugin.lifecycle.startMethod} method is undefined so the module is the extension's exports`);
            this.activatedPlugins.set(plugin.model.id, new ActivatedPlugin(pluginContext, pluginMain));
        }
    }
    getAllPlugins() {
        return Array.from(this.registry.values());
    }
    getPluginExport(pluginId) {
        const activePlugin = this.activatedPlugins.get(pluginId);
        if (activePlugin) {
            return activePlugin.exports;
        }
        return undefined;
    }
    getPluginById(pluginId) {
        return this.registry.get(pluginId);
    }
    isRunning(pluginId) {
        return this.registry.has(pluginId);
    }
    isActive(pluginId) {
        return this.activatedPlugins.has(pluginId);
    }
    activatePlugin(pluginId) {
        return this.$activatePlugin(pluginId);
    }
    get onDidChange() {
        return this.onDidChangeEmitter.event;
    }
}
exports.PluginManagerExtImpl = PluginManagerExtImpl;
PluginManagerExtImpl.SUPPORTED_ACTIVATION_EVENTS = new Set([
    '*',
    'onLanguage',
    'onCommand',
    'onDebug',
    'onDebugInitialConfigurations',
    'onDebugResolve',
    'onDebugAdapterProtocolTracker',
    'onDebugDynamicConfigurations',
    'onTaskType',
    'workspaceContains',
    'onView',
    'onUri',
    'onTerminalProfile',
    'onWebviewPanel',
    'onFileSystem',
    'onCustomEditor',
    'onStartupFinished',
    'onAuthenticationRequest',
    'onNotebook',
    'onNotebookSerializer'
]);
// for electron
function getGlobal() {
    return typeof self === 'undefined' ? typeof global === 'undefined' ? null : global : self;
}


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/plugin-storage.js":
/*!**************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/plugin-storage.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KeyValueStorageProxy = exports.GlobalState = exports.Memento = void 0;
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../packages/core/lib/common/event.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
class Memento {
    constructor(pluginId, isPluginGlobalData, storage) {
        this.pluginId = pluginId;
        this.isPluginGlobalData = isPluginGlobalData;
        this.storage = storage;
        this.cache = storage.getPerPluginData(pluginId, isPluginGlobalData);
        if (!this.isPluginGlobalData) {
            this.storage.storageDataChangedEvent((data) => {
                this.cache = data[this.pluginId] ? data[this.pluginId] : {};
            });
        }
    }
    keys() {
        return Object.entries(this.cache).filter(([, value]) => value !== undefined).map(([key]) => key);
    }
    get(key, defaultValue) {
        if (key && this.cache.hasOwnProperty(key)) {
            return this.cache[key];
        }
        else {
            return defaultValue;
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    update(key, value) {
        if (value === undefined) {
            delete this.cache[key];
        }
        else {
            this.cache[key] = value;
        }
        return this.storage.setPerPluginData(this.pluginId, this.cache, this.isPluginGlobalData).then(_ => undefined);
    }
}
exports.Memento = Memento;
class GlobalState extends Memento {
    /** @todo: API is not yet implemented. */
    setKeysForSync(keys) { }
}
exports.GlobalState = GlobalState;
/**
 * Singleton.
 * Is used to proxy storage requests to main side.
 */
class KeyValueStorageProxy {
    constructor(rpc) {
        this.storageDataChangedEmitter = new event_1.Emitter();
        this.storageDataChangedEvent = this.storageDataChangedEmitter.event;
        this.proxy = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.STORAGE_MAIN);
    }
    init(initGlobalData, initWorkspaceData) {
        this.globalDataCache = initGlobalData;
        this.workspaceDataCache = initWorkspaceData;
    }
    getPerPluginData(key, isGlobal) {
        if (isGlobal) {
            const existed = this.globalDataCache[key];
            return existed ? existed : {};
        }
        else {
            const existed = this.workspaceDataCache[key];
            return existed ? existed : {};
        }
    }
    setPerPluginData(key, value, isGlobal) {
        if (isGlobal) {
            this.globalDataCache[key] = value;
        }
        else {
            this.workspaceDataCache[key] = value;
        }
        return this.proxy.$set(key, value, isGlobal);
    }
    $updatePluginsWorkspaceData(workspaceData) {
        this.workspaceDataCache = workspaceData;
        this.storageDataChangedEmitter.fire(workspaceData);
    }
}
exports.KeyValueStorageProxy = KeyValueStorageProxy;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/preference-registry.js":
/*!*******************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/preference-registry.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PreferenceRegistryExtImpl = exports.TheiaWorkspace = exports.PreferenceScope = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../packages/core/lib/common/event.js");
const os_1 = __webpack_require__(/*! @theia/core/lib/common/os */ "../../packages/core/lib/common/os.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../../packages/core/shared/vscode-uri/index.js");
const map_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/base/common/map */ "../../node_modules/@theia/monaco-editor-core/esm/vs/base/common/map.js");
const configurationModels_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/platform/configuration/common/configurationModels */ "../../node_modules/@theia/monaco-editor-core/esm/vs/platform/configuration/common/configurationModels.js");
const workspace_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/platform/workspace/common/workspace */ "../../node_modules/@theia/monaco-editor-core/esm/vs/platform/workspace/common/workspace.js");
const uuid_1 = __webpack_require__(/*! uuid */ "../../node_modules/uuid/dist/esm-node/index.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const types_1 = __webpack_require__(/*! ../common/types */ "../../packages/plugin-ext/lib/common/types.js");
const cloneDeep = __webpack_require__(/*! lodash.clonedeep */ "../../node_modules/lodash.clonedeep/index.js");
const injectionRe = /\b__proto__\b|\bconstructor\.prototype\b/;
var ConfigurationTarget;
(function (ConfigurationTarget) {
    ConfigurationTarget[ConfigurationTarget["Global"] = 1] = "Global";
    ConfigurationTarget[ConfigurationTarget["Workspace"] = 2] = "Workspace";
    ConfigurationTarget[ConfigurationTarget["WorkspaceFolder"] = 3] = "WorkspaceFolder"; // eslint-disable-line @typescript-eslint/no-shadow
})(ConfigurationTarget || (ConfigurationTarget = {}));
var PreferenceScope;
(function (PreferenceScope) {
    PreferenceScope[PreferenceScope["Default"] = 0] = "Default";
    PreferenceScope[PreferenceScope["User"] = 1] = "User";
    PreferenceScope[PreferenceScope["Workspace"] = 2] = "Workspace";
    PreferenceScope[PreferenceScope["Folder"] = 3] = "Folder";
})(PreferenceScope = exports.PreferenceScope || (exports.PreferenceScope = {}));
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function lookUp(tree, key) {
    if (!key) {
        return;
    }
    const parts = key.split('.');
    let node = tree;
    for (let i = 0; node && i < parts.length; i++) {
        node = node[parts[i]];
    }
    return node;
}
class TheiaWorkspace extends workspace_1.Workspace {
    constructor(ext) {
        var _a, _b;
        const folders = ((_a = ext.workspaceFolders) !== null && _a !== void 0 ? _a : []).map(folder => new workspace_1.WorkspaceFolder(folder));
        super((0, uuid_1.v4)(), folders, false, (_b = ext.workspaceFile) !== null && _b !== void 0 ? _b : null, () => os_1.isOSX || os_1.isWindows);
    }
}
exports.TheiaWorkspace = TheiaWorkspace;
class PreferenceRegistryExtImpl {
    constructor(rpc, workspace) {
        this.workspace = workspace;
        this._onDidChangeConfiguration = new event_1.Emitter();
        this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
        this.OVERRIDE_KEY_TEST = /^\[([^\]]+)\]\./;
        this.proxy = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.PREFERENCE_REGISTRY_MAIN);
    }
    init(data) {
        this.preferencesChanged(data);
    }
    $acceptConfigurationChanged(data, eventData) {
        this.preferencesChanged(data, eventData);
    }
    preferencesChanged(data, eventData) {
        this._preferences = this.parse(data);
        this._onDidChangeConfiguration.fire(this.toConfigurationChangeEvent(eventData !== null && eventData !== void 0 ? eventData : []));
    }
    getConfiguration(rawSection, rawScope, extensionId) {
        const overrides = this.parseConfigurationAccessOptions(rawScope);
        const preferences = this.toReadonlyValue(this._preferences.getValue(rawSection, overrides, new TheiaWorkspace(this.workspace)));
        const configuration = {
            has(key) {
                return typeof lookUp(preferences, key) !== 'undefined';
            },
            get: (key, defaultValue) => {
                const result = lookUp(preferences, key);
                if (typeof result === 'undefined') {
                    return defaultValue;
                }
                else {
                    let clonedConfig = undefined;
                    const cloneOnWriteProxy = (target, accessor) => {
                        let clonedTarget = undefined;
                        const cloneTarget = () => {
                            clonedConfig = clonedConfig ? clonedConfig : cloneDeep(preferences);
                            clonedTarget = clonedTarget ? clonedTarget : lookUp(clonedConfig, accessor);
                        };
                        if (!(0, types_1.isObject)(target)) {
                            return target;
                        }
                        return new Proxy(target, {
                            get: (targ, prop) => {
                                const config = Object.getOwnPropertyDescriptor(targ, prop);
                                // This check ensures that https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/get#invariants are satisfied
                                if ((config === null || config === void 0 ? void 0 : config.configurable) === false && (config === null || config === void 0 ? void 0 : config.writable) === false) {
                                    return targ[prop];
                                }
                                if (typeof prop === 'string' && prop.toLowerCase() === 'tojson') {
                                    cloneTarget();
                                    return () => clonedTarget;
                                }
                                if (clonedConfig) {
                                    clonedTarget = clonedTarget ? clonedTarget : lookUp(clonedConfig, accessor);
                                    return clonedTarget[prop];
                                }
                                const res = targ[prop];
                                if (typeof prop === 'string') {
                                    return cloneOnWriteProxy(res, `${accessor}.${prop}`);
                                }
                                return res;
                            },
                            set: (targ, prop, val) => {
                                cloneTarget();
                                clonedTarget[prop] = val;
                                return true;
                            },
                            deleteProperty: (targ, prop) => {
                                cloneTarget();
                                delete clonedTarget[prop];
                                return true;
                            },
                            defineProperty: (targ, prop, descr) => {
                                cloneTarget();
                                Object.defineProperty(clonedTarget, prop, descr);
                                return true;
                            }
                        });
                    };
                    return cloneOnWriteProxy(result, key);
                }
            },
            update: (key, value, targetScope, withLanguageOverride) => {
                var _a;
                const resourceStr = (_a = overrides.resource) === null || _a === void 0 ? void 0 : _a.toString();
                const overrideSegment = overrides.overrideIdentifier ? `[${overrides.overrideIdentifier}].` : '';
                const preferenceKey = rawSection ? `${rawSection}.${key}` : key;
                const fullPath = overrideSegment + preferenceKey;
                if (typeof value !== 'undefined') {
                    return this.proxy.$updateConfigurationOption(targetScope, fullPath, value, resourceStr, withLanguageOverride);
                }
                else {
                    return this.proxy.$removeConfigurationOption(targetScope, fullPath, resourceStr, withLanguageOverride);
                }
            },
            inspect: (key) => {
                var _a, _b, _c, _d;
                const path = rawSection ? `${rawSection}.${key}` : key;
                const result = this._preferences.inspect(path, overrides, new TheiaWorkspace(this.workspace));
                if (!result) {
                    return undefined;
                }
                const configInspect = { key };
                configInspect.defaultValue = (_a = result.default) === null || _a === void 0 ? void 0 : _a.value;
                configInspect.globalValue = (_b = result.user) === null || _b === void 0 ? void 0 : _b.value;
                configInspect.workspaceValue = (_c = result.workspace) === null || _c === void 0 ? void 0 : _c.value;
                configInspect.workspaceFolderValue = (_d = result.workspaceFolder) === null || _d === void 0 ? void 0 : _d.value;
                return configInspect;
            }
        };
        if (typeof preferences === 'object') {
            (0, types_1.mixin)(configuration, preferences, false);
        }
        return Object.freeze(configuration);
    }
    toReadonlyValue(data) {
        const readonlyProxy = (target) => (0, types_1.isObject)(target)
            ? new Proxy(target, {
                get: (targ, prop) => {
                    const config = Object.getOwnPropertyDescriptor(targ, prop);
                    // This check ensures that https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/get#invariants are satisfied
                    if ((config === null || config === void 0 ? void 0 : config.configurable) === false && (config === null || config === void 0 ? void 0 : config.writable) === false) {
                        return targ[prop];
                    }
                    return readonlyProxy(targ[prop]);
                },
                set: (targ, prop, val) => {
                    throw new Error(`TypeError: Cannot assign to read only property '${prop}' of object`);
                },
                deleteProperty: (targ, prop) => {
                    throw new Error(`TypeError: Cannot delete read only property '${prop}' of object`);
                },
                defineProperty: (targ, prop) => {
                    throw new Error(`TypeError: Cannot define property '${prop}' of a readonly object`);
                },
                setPrototypeOf: (targ) => {
                    throw new Error('TypeError: Cannot set prototype for a readonly object');
                },
                isExtensible: () => false,
                preventExtensions: () => true
            })
            : target;
        return readonlyProxy(data);
    }
    parse(data) {
        const defaultConfiguration = this.getConfigurationModel('Default', data[PreferenceScope.Default]);
        const userConfiguration = this.getConfigurationModel('User', data[PreferenceScope.User]);
        const workspaceConfiguration = this.getConfigurationModel('Workspace', data[PreferenceScope.Workspace]);
        const folderConfigurations = new map_1.ResourceMap();
        Object.keys(data[PreferenceScope.Folder]).forEach(resource => {
            folderConfigurations.set(vscode_uri_1.URI.parse(resource), this.getConfigurationModel(`Folder: ${resource}`, data[PreferenceScope.Folder][resource]));
        });
        return new configurationModels_1.Configuration(defaultConfiguration, new configurationModels_1.ConfigurationModel(), /** policy configuration. */ new configurationModels_1.ConfigurationModel(), /** application configuration. */ userConfiguration, new configurationModels_1.ConfigurationModel(), /** remote configuration. */ workspaceConfiguration, folderConfigurations);
    }
    getConfigurationModel(label, data) {
        const parser = new configurationModels_1.ConfigurationModelParser(label);
        const sanitized = this.sanitize(data);
        parser.parseRaw(sanitized);
        return parser.configurationModel;
    }
    /**
     * Creates a new object and assigns those keys of raw to it that are not likely to cause prototype pollution.
     * Also preprocesses override identifiers so that they take the form [identifier]: {...contents}.
     */
    sanitize(raw) {
        if (!(0, types_1.isObject)(raw)) {
            return raw;
        }
        const asObject = raw;
        const sanitized = Object.create(null);
        for (const key of Object.keys(asObject)) {
            if (!injectionRe.test(key)) {
                const override = this.OVERRIDE_KEY_TEST.exec(key);
                if (override) {
                    const overrideKey = `[${override[1]}]`;
                    const remainder = key.slice(override[0].length);
                    if (!(0, types_1.isObject)(sanitized[overrideKey])) {
                        sanitized[overrideKey] = Object.create(null);
                    }
                    sanitized[overrideKey][remainder] = this.sanitize(asObject[key]);
                }
                else {
                    sanitized[key] = this.sanitize(asObject[key]);
                }
            }
        }
        return sanitized;
    }
    toConfigurationChangeEvent(eventData) {
        return Object.freeze({
            affectsConfiguration: (section, scope) => {
                const { resource, overrideIdentifier } = this.parseConfigurationAccessOptions(scope);
                const sectionWithLanguage = overrideIdentifier ? `[${overrideIdentifier}].${section}` : section;
                return eventData.some(change => {
                    var _a, _b;
                    const matchesUri = !resource || !change.scope || (resource.toString() + '/').startsWith(change.scope.endsWith('/') ? change.scope : change.scope + '/');
                    const sliceIndex = overrideIdentifier ? 0 : ((_b = (_a = this.OVERRIDE_KEY_TEST.exec(change.preferenceName)) === null || _a === void 0 ? void 0 : _a[0].length) !== null && _b !== void 0 ? _b : 0);
                    const changedPreferenceName = sliceIndex ? change.preferenceName.slice(sliceIndex) : change.preferenceName;
                    return matchesUri && (sectionWithLanguage === changedPreferenceName
                        || sectionWithLanguage.startsWith(`${changedPreferenceName}.`)
                        || changedPreferenceName.startsWith(`${sectionWithLanguage}.`));
                });
            }
        });
    }
    parseConfigurationAccessOptions(scope) {
        if (!scope) {
            return {};
        }
        let overrideIdentifier = undefined;
        let resource;
        if ('uri' in scope || 'languageId' in scope) {
            resource = scope.uri;
        }
        else {
            resource = scope;
        }
        if ('languageId' in scope) {
            overrideIdentifier = scope.languageId;
        }
        return { resource, overrideIdentifier };
    }
}
exports.PreferenceRegistryExtImpl = PreferenceRegistryExtImpl;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/prefix-sum-computer.js":
/*!*******************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/prefix-sum-computer.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PrefixSumComputer = exports.PrefixSumIndexOfResult = exports.toUint32 = void 0;
// Copied from https://github.com/Microsoft/vscode/blob/master/src/vs/editor/common/viewModel/prefixSumComputer.ts
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * Max unsigned integer that fits on 32 bits.
 */
const MAX_UINT_32 = 4294967295; // 2^32 - 1
function toUint32(v) {
    if (v < 0) {
        return 0;
    }
    if (v > MAX_UINT_32) {
        return MAX_UINT_32;
    }
    return v | 0;
}
exports.toUint32 = toUint32;
class PrefixSumIndexOfResult {
    constructor(index, remainder) {
        this.index = index;
        this.remainder = remainder;
    }
}
exports.PrefixSumIndexOfResult = PrefixSumIndexOfResult;
class PrefixSumComputer {
    constructor(values) {
        this.values = values;
        this.prefixSum = new Uint32Array(values.length);
        this.prefixSumValidIndex = new Int32Array(1);
        this.prefixSumValidIndex[0] = -1;
    }
    getCount() {
        return this.values.length;
    }
    insertValues(insertIndex, insertValues) {
        insertIndex = toUint32(insertIndex);
        const oldValues = this.values;
        const oldPrefixSum = this.prefixSum;
        const insertValuesLen = insertValues.length;
        if (insertValuesLen === 0) {
            return false;
        }
        this.values = new Uint32Array(oldValues.length + insertValuesLen);
        this.values.set(oldValues.subarray(0, insertIndex), 0);
        this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);
        this.values.set(insertValues, insertIndex);
        if (insertIndex - 1 < this.prefixSumValidIndex[0]) {
            this.prefixSumValidIndex[0] = insertIndex - 1;
        }
        this.prefixSum = new Uint32Array(this.values.length);
        if (this.prefixSumValidIndex[0] >= 0) {
            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
        }
        return true;
    }
    changeValue(index, value) {
        index = toUint32(index);
        value = toUint32(value);
        if (this.values[index] === value) {
            return false;
        }
        this.values[index] = value;
        if (index - 1 < this.prefixSumValidIndex[0]) {
            this.prefixSumValidIndex[0] = index - 1;
        }
        return true;
    }
    removeValues(startIndex, count) {
        startIndex = toUint32(startIndex);
        count = toUint32(count);
        const oldValues = this.values;
        const oldPrefixSum = this.prefixSum;
        if (startIndex >= oldValues.length) {
            return false;
        }
        const maxCount = oldValues.length - startIndex;
        if (count >= maxCount) {
            count = maxCount;
        }
        if (count === 0) {
            return false;
        }
        this.values = new Uint32Array(oldValues.length - count);
        this.values.set(oldValues.subarray(0, startIndex), 0);
        this.values.set(oldValues.subarray(startIndex + count), startIndex);
        this.prefixSum = new Uint32Array(this.values.length);
        if (startIndex - 1 < this.prefixSumValidIndex[0]) {
            this.prefixSumValidIndex[0] = startIndex - 1;
        }
        if (this.prefixSumValidIndex[0] >= 0) {
            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
        }
        return true;
    }
    getTotalValue() {
        if (this.values.length === 0) {
            return 0;
        }
        return this._getAccumulatedValue(this.values.length - 1);
    }
    getAccumulatedValue(index) {
        if (index < 0) {
            return 0;
        }
        index = toUint32(index);
        return this._getAccumulatedValue(index);
    }
    _getAccumulatedValue(index) {
        if (index <= this.prefixSumValidIndex[0]) {
            return this.prefixSum[index];
        }
        let startIndex = this.prefixSumValidIndex[0] + 1;
        if (startIndex === 0) {
            this.prefixSum[0] = this.values[0];
            startIndex++;
        }
        if (index >= this.values.length) {
            index = this.values.length - 1;
        }
        for (let i = startIndex; i <= index; i++) {
            this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
        }
        this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);
        return this.prefixSum[index];
    }
    getIndexOf(accumulatedValue) {
        accumulatedValue = Math.floor(accumulatedValue);
        // Compute all sums (to get a fully valid prefixSum)
        this.getTotalValue();
        let low = 0;
        let high = this.values.length - 1;
        let mid;
        let midStop;
        let midStart;
        while (low <= high) {
            mid = low + ((high - low) / 2) | 0;
            midStop = this.prefixSum[mid];
            midStart = midStop - this.values[mid];
            if (accumulatedValue < midStart) {
                high = mid - 1;
            }
            else if (accumulatedValue >= midStop) {
                low = mid + 1;
            }
            else {
                break;
            }
        }
        return new PrefixSumIndexOfResult(mid, accumulatedValue - midStart);
    }
}
exports.PrefixSumComputer = PrefixSumComputer;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/quick-open.js":
/*!**********************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/quick-open.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.QuickPickExt = exports.InputBoxExt = exports.QuickInputExt = exports.QuickOpenExtImpl = exports.getIconPathOrClass = exports.getDarkIconUri = exports.getLightIconUri = exports.getIconUris = exports.isPromiseCanceledError = void 0;
// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/* eslint-disable @typescript-eslint/no-explicit-any */
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const cancellation_1 = __webpack_require__(/*! @theia/core/lib/common/cancellation */ "../../packages/core/lib/common/cancellation.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../packages/core/lib/common/event.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../packages/core/lib/common/disposable.js");
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../../packages/core/shared/vscode-uri/index.js");
const path = __webpack_require__(/*! path */ "path");
const type_converters_1 = __webpack_require__(/*! ./type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const plugin_protocol_1 = __webpack_require__(/*! ../common/plugin-protocol */ "../../packages/plugin-ext/lib/common/plugin-protocol.js");
const severity_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/base/common/severity */ "../../node_modules/@theia/monaco-editor-core/esm/vs/base/common/severity.js");
const themeService_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/platform/theme/common/themeService */ "../../node_modules/@theia/monaco-editor-core/esm/vs/platform/theme/common/themeService.js");
const canceledName = 'Canceled';
/**
 * Checks if the given error is a promise in canceled state
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isPromiseCanceledError(error) {
    return error instanceof Error && error.name === canceledName && error.message === canceledName;
}
exports.isPromiseCanceledError = isPromiseCanceledError;
function getIconUris(iconPath) {
    if (types_impl_1.ThemeIcon.is(iconPath)) {
        return { id: iconPath.id };
    }
    const dark = getDarkIconUri(iconPath);
    const light = getLightIconUri(iconPath);
    // Tolerate strings: https://github.com/microsoft/vscode/issues/110432#issuecomment-726144556
    return {
        dark: typeof dark === 'string' ? vscode_uri_1.URI.file(dark) : dark,
        light: typeof light === 'string' ? vscode_uri_1.URI.file(light) : light
    };
}
exports.getIconUris = getIconUris;
function getLightIconUri(iconPath) {
    return typeof iconPath === 'object' && 'light' in iconPath ? iconPath.light : iconPath;
}
exports.getLightIconUri = getLightIconUri;
function getDarkIconUri(iconPath) {
    return typeof iconPath === 'object' && 'dark' in iconPath ? iconPath.dark : iconPath;
}
exports.getDarkIconUri = getDarkIconUri;
function getIconPathOrClass(button) {
    const iconPathOrIconClass = getIconUris(button.iconPath);
    let iconPath;
    let iconClass;
    if ('id' in iconPathOrIconClass) {
        iconClass = themeService_1.ThemeIcon.asClassName(iconPathOrIconClass);
    }
    else {
        iconPath = iconPathOrIconClass;
    }
    return {
        iconPath,
        iconClass
    };
}
exports.getIconPathOrClass = getIconPathOrClass;
class QuickOpenExtImpl {
    constructor(rpc) {
        this._sessions = new Map(); // Each quickinput will have a number so that we know where to fire events
        this._instances = 0;
        this.proxy = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.QUICK_OPEN_MAIN);
    }
    showQuickPick(itemsOrItemsPromise, options, token = cancellation_1.CancellationToken.None) {
        this.onDidSelectItem = undefined;
        const itemsPromise = Promise.resolve(itemsOrItemsPromise);
        const instance = ++this._instances;
        const widgetPromise = this.proxy.$show(instance, {
            title: options && options.title,
            canPickMany: options && options.canPickMany,
            placeHolder: options && options.placeHolder,
            matchOnDescription: options && options.matchOnDescription,
            matchOnDetail: options && options.matchOnDetail,
            ignoreFocusLost: options && options.ignoreFocusOut
        }, token);
        const widgetClosedMarker = {};
        const widgetClosedPromise = widgetPromise.then(() => widgetClosedMarker);
        return Promise.race([widgetClosedPromise, itemsPromise]).then(result => {
            if (result === widgetClosedMarker) {
                return undefined;
            }
            return itemsPromise.then(async (items) => {
                const pickItems = (0, type_converters_1.convertToTransferQuickPickItems)(items);
                if (options && typeof options.onDidSelectItem === 'function') {
                    this.onDidSelectItem = handle => {
                        options.onDidSelectItem(items[handle]);
                    };
                }
                this.proxy.$setItems(instance, pickItems);
                return widgetPromise.then(handle => {
                    if (typeof handle === 'number') {
                        if (options && options.canPickMany) {
                            return Array.of(items[handle]);
                        }
                        else {
                            return items[handle];
                        }
                    }
                    else if (Array.isArray(handle)) {
                        return handle.map(h => items[h]);
                    }
                    return undefined;
                });
            });
        }).then(undefined, err => {
            if (isPromiseCanceledError(err)) {
                return undefined;
            }
            this.proxy.$setError(instance, err);
            return Promise.reject(err);
        });
    }
    $onItemSelected(handle) {
        if (this.onDidSelectItem) {
            this.onDidSelectItem(handle);
        }
    }
    // ---- input
    showInput(options, token = cancellation_1.CancellationToken.None) {
        this.validateInputHandler = options === null || options === void 0 ? void 0 : options.validateInput;
        if (!options) {
            options = { placeHolder: '' };
        }
        return this.proxy.$input(options, typeof this.validateInputHandler === 'function', token);
    }
    async showInputBox(options) {
        this.validateInputHandler = typeof options.validateInput === 'function' ? options.validateInput : undefined;
        return this.proxy.$showInputBox(options, typeof this.validateInputHandler === 'function');
    }
    async $validateInput(input) {
        if (!this.validateInputHandler) {
            return;
        }
        const result = await this.validateInputHandler(input);
        if (!result || typeof result === 'string') {
            return result;
        }
        let severity;
        switch (result.severity) {
            case types_impl_1.InputBoxValidationSeverity.Info:
                severity = severity_1.default.Info;
                break;
            case types_impl_1.InputBoxValidationSeverity.Warning:
                severity = severity_1.default.Warning;
                break;
            case types_impl_1.InputBoxValidationSeverity.Error:
                severity = severity_1.default.Error;
                break;
            default:
                severity = result.message ? severity_1.default.Error : severity_1.default.Ignore;
                break;
        }
        return {
            content: result.message,
            severity
        };
    }
    // ---- QuickInput
    createQuickPick(plugin) {
        const session = new QuickPickExt(this, this.proxy, plugin, () => this._sessions.delete(session._id));
        this._sessions.set(session._id, session);
        return session;
    }
    createInputBox(plugin) {
        const session = new InputBoxExt(this, this.proxy, plugin, () => this._sessions.delete(session._id));
        this._sessions.set(session._id, session);
        return session;
    }
    hide() {
        this.proxy.$hide();
    }
    async $acceptOnDidAccept(sessionId) {
        const session = this._sessions.get(sessionId);
        if (session) {
            session._fireAccept();
        }
    }
    async $acceptDidChangeValue(sessionId, changedValue) {
        const session = this._sessions.get(sessionId);
        if (session) {
            session._fireChangedValue(changedValue);
        }
    }
    async $acceptOnDidHide(sessionId) {
        const session = this._sessions.get(sessionId);
        if (session) {
            session._fireHide();
        }
    }
    async $acceptOnDidTriggerButton(sessionId, btn) {
        const session = this._sessions.get(sessionId);
        if (session) {
            if (btn.index === -1) {
                session._fireButtonTrigger(types_impl_1.QuickInputButtons.Back);
            }
            else if (session && (session instanceof InputBoxExt || session instanceof QuickPickExt)) {
                const btnFromIndex = session.buttons[btn.index];
                session._fireButtonTrigger(btnFromIndex);
            }
        }
    }
    $onDidChangeActive(sessionId, handles) {
        const session = this._sessions.get(sessionId);
        if (session instanceof QuickPickExt) {
            session._fireDidChangeActive(handles);
        }
    }
    $onDidChangeSelection(sessionId, handles) {
        const session = this._sessions.get(sessionId);
        if (session instanceof QuickPickExt) {
            session._fireDidChangeSelection(handles);
        }
    }
    $onDidTriggerItemButton(sessionId, itemHandle, buttonHandle) {
        const session = this._sessions.get(sessionId);
        if (session instanceof QuickPickExt) {
            session._fireDidTriggerItemButton(itemHandle, buttonHandle);
        }
    }
}
exports.QuickOpenExtImpl = QuickOpenExtImpl;
class QuickInputExt {
    constructor(quickOpen, quickOpenMain, plugin, _onDidDispose) {
        this.quickOpen = quickOpen;
        this.quickOpenMain = quickOpenMain;
        this.plugin = plugin;
        this._onDidDispose = _onDidDispose;
        this._id = QuickInputExt._nextId++;
        this._buttons = [];
        this._handlesToButtons = new Map();
        this.expectingHide = false;
        this._disposed = false;
        this._pendingUpdate = { id: this._id };
        this.title = undefined;
        this.step = undefined;
        this.totalSteps = undefined;
        this.enabled = true;
        this.busy = false;
        this.ignoreFocusOut = false;
        this.value = '';
        this.visible = false;
        this.disposableCollection = new disposable_1.DisposableCollection();
        this.disposableCollection.push(this.onDidAcceptEmitter = new event_1.Emitter());
        this.disposableCollection.push(this._onDidChangeValueEmitter = new event_1.Emitter());
        this.disposableCollection.push(this.onDidHideEmitter = new event_1.Emitter());
        this.disposableCollection.push(this.onDidTriggerButtonEmitter = new event_1.Emitter());
    }
    get title() {
        return this._title;
    }
    set title(title) {
        this._title = title;
        this.update({ title });
    }
    get step() {
        return this._step;
    }
    set step(step) {
        this._step = step;
        this.update({ step });
    }
    get totalSteps() {
        return this._totalSteps;
    }
    set totalSteps(totalSteps) {
        this._totalSteps = totalSteps;
        this.update({ totalSteps });
    }
    get enabled() {
        return this._enabled;
    }
    set enabled(enabled) {
        this._enabled = enabled;
        this.update({ enabled });
    }
    get busy() {
        return this._busy;
    }
    set busy(busy) {
        this._busy = busy;
        this.update({ busy });
    }
    get ignoreFocusOut() {
        return this._ignoreFocusOut;
    }
    set ignoreFocusOut(ignoreFocusOut) {
        this._ignoreFocusOut = ignoreFocusOut;
        this.update({ ignoreFocusOut });
    }
    get value() {
        return this._value;
    }
    set value(value) {
        this._value = value;
        this.update({ value });
    }
    get placeholder() {
        return this._placeholder;
    }
    set placeholder(placeholder) {
        this._placeholder = placeholder;
        this.update({ placeholder });
    }
    get buttons() {
        return this._buttons;
    }
    set buttons(buttons) {
        this._buttons = buttons.slice();
        this._handlesToButtons.clear();
        buttons.forEach((button, i) => {
            const handle = button === types_impl_1.QuickInputButtons.Back ? -1 : i;
            this._handlesToButtons.set(handle, button);
        });
        this.update({
            buttons: buttons.map((button, i) => ({
                iconPath: getIconUris(button.iconPath),
                iconClass: types_impl_1.ThemeIcon.is(button.iconPath) ? themeService_1.ThemeIcon.asClassName(button.iconPath) : undefined,
                tooltip: button.tooltip,
                handle: button === types_impl_1.QuickInputButtons.Back ? -1 : i,
            }))
        });
    }
    show() {
        this.visible = true;
        this.expectingHide = true;
        this.update({ visible: true });
    }
    dispose() {
        if (this._disposed) {
            return;
        }
        this._disposed = true;
        this._fireHide();
        this.disposableCollection.dispose();
        this._onDidDispose();
        this.quickOpenMain.$dispose(this._id);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    update(properties) {
        if (this._disposed) {
            return;
        }
        for (const key of Object.keys(properties)) {
            const value = properties[key];
            this._pendingUpdate[key] = value === undefined ? null : value;
        }
        if ('visible' in this._pendingUpdate) {
            if (this._updateTimeout) {
                clearTimeout(this._updateTimeout);
                this._updateTimeout = undefined;
            }
            this.dispatchUpdate();
        }
        else if (this.visible && !this._updateTimeout) {
            // Defer the update so that multiple changes to setters dont cause a redraw each
            this._updateTimeout = setTimeout(() => {
                this._updateTimeout = undefined;
                this.dispatchUpdate();
            }, 0);
        }
    }
    dispatchUpdate() {
        this.quickOpenMain.$createOrUpdate(this._pendingUpdate);
        this._pendingUpdate = { id: this._id };
    }
    hide() {
        this.quickOpenMain.$hide();
        this.dispose();
    }
    convertURL(iconPath) {
        const toUrl = (arg) => {
            arg = arg instanceof vscode_uri_1.URI && arg.scheme === 'file' ? arg.fsPath : arg;
            if (typeof arg !== 'string') {
                return arg.toString(true);
            }
            const { packagePath } = this.plugin.rawModel;
            const absolutePath = path.isAbsolute(arg) ? arg : path.join(packagePath, arg);
            const normalizedPath = path.normalize(absolutePath);
            const relativePath = path.relative(packagePath, normalizedPath);
            return plugin_protocol_1.PluginPackage.toPluginUrl(this.plugin.rawModel, relativePath);
        };
        if (types_impl_1.ThemeIcon.is(iconPath)) {
            return iconPath;
        }
        else if (typeof iconPath === 'string' || iconPath instanceof vscode_uri_1.URI) {
            return vscode_uri_1.URI.parse(toUrl(iconPath));
        }
        else {
            const { light, dark } = iconPath;
            return {
                light: toUrl(light),
                dark: toUrl(dark)
            };
        }
    }
    _fireAccept() {
        this.onDidAcceptEmitter.fire(undefined);
    }
    _fireChangedValue(changedValue) {
        this._value = changedValue;
        this._onDidChangeValueEmitter.fire(changedValue);
    }
    _fireHide() {
        if (this.expectingHide) {
            this.expectingHide = false;
            this.onDidHideEmitter.fire(undefined);
        }
    }
    _fireButtonTrigger(btn) {
        this.onDidTriggerButtonEmitter.fire(btn);
    }
    get onDidHide() {
        return this.onDidHideEmitter.event;
    }
    get onDidAccept() {
        return this.onDidAcceptEmitter.event;
    }
    get onDidChangeValue() {
        return this._onDidChangeValueEmitter.event;
    }
    get onDidTriggerButton() {
        return this.onDidTriggerButtonEmitter.event;
    }
}
exports.QuickInputExt = QuickInputExt;
QuickInputExt._nextId = 1;
/**
 * Base implementation of {@link InputBox} that uses {@link QuickOpenExt}.
 * Missing functionality is going to be implemented in the scope of https://github.com/eclipse-theia/theia/issues/5109
 */
class InputBoxExt extends QuickInputExt {
    constructor(quickOpen, quickOpenMain, plugin, onDispose) {
        super(quickOpen, quickOpenMain, plugin, onDispose);
        this.quickOpen = quickOpen;
        this.quickOpenMain = quickOpenMain;
        this.plugin = plugin;
        this.buttons = [];
        this.password = false;
        this.value = '';
    }
    get password() {
        return this._password;
    }
    set password(password) {
        this._password = password;
        this.update({ password });
    }
    get prompt() {
        return this._prompt;
    }
    set prompt(prompt) {
        this._prompt = prompt;
        this.update({ prompt });
    }
    get valueSelection() {
        return this._valueSelection;
    }
    set valueSelection(valueSelection) {
        this._valueSelection = valueSelection;
        this.update({ valueSelection });
    }
    get validationMessage() {
        return this._validationMessage;
    }
    set validationMessage(validationMessage) {
        if (this._validationMessage !== validationMessage) {
            this._validationMessage = validationMessage;
            this.update({ validationMessage });
        }
    }
}
exports.InputBoxExt = InputBoxExt;
/**
 * Base implementation of {@link QuickPick} that uses {@link QuickOpenExt}.
 * Missing functionality is going to be implemented in the scope of https://github.com/eclipse-theia/theia/issues/5059
 */
class QuickPickExt extends QuickInputExt {
    constructor(quickOpen, quickOpenMain, plugin, onDispose) {
        super(quickOpen, quickOpenMain, plugin, onDispose);
        this.quickOpen = quickOpen;
        this.quickOpenMain = quickOpenMain;
        this.plugin = plugin;
        this._items = [];
        this._handlesToItems = new Map();
        this._itemsToHandles = new Map();
        this._canSelectMany = false;
        this._matchOnDescription = true;
        this._matchOnDetail = true;
        this._sortByLabel = true;
        this._keepScrollPosition = false;
        this._activeItems = [];
        this._selectedItems = [];
        this._onDidChangeActiveEmitter = new event_1.Emitter();
        this._onDidChangeSelectionEmitter = new event_1.Emitter();
        this._onDidTriggerItemButtonEmitter = new event_1.Emitter();
        this.onDidChangeActive = this._onDidChangeActiveEmitter.event;
        this.onDidChangeSelection = this._onDidChangeSelectionEmitter.event;
        this.onDidTriggerItemButton = this._onDidTriggerItemButtonEmitter.event;
        this.buttons = [];
        this.disposableCollection.push(this._onDidChangeActiveEmitter);
        this.disposableCollection.push(this._onDidChangeSelectionEmitter);
        this.disposableCollection.push(this._onDidTriggerItemButtonEmitter);
        this.update({ type: 'quickPick' });
    }
    get items() {
        return this._items;
    }
    set items(items) {
        var _a;
        this._items = items.slice();
        this._handlesToItems.clear();
        this._itemsToHandles.clear();
        items.forEach((item, i) => {
            this._handlesToItems.set(i, item);
            this._itemsToHandles.set(item, i);
        });
        const pickItems = [];
        for (let handle = 0; handle < items.length; handle++) {
            const item = items[handle];
            if (item.kind === types_impl_1.QuickPickItemKind.Separator) {
                pickItems.push({ type: 'separator', label: item.label, handle });
            }
            else {
                pickItems.push({
                    kind: item.kind,
                    label: item.label,
                    description: item.description,
                    handle,
                    detail: item.detail,
                    picked: item.picked,
                    alwaysShow: item.alwaysShow,
                    buttons: (_a = item.buttons) === null || _a === void 0 ? void 0 : _a.map((button, index) => ({
                        iconPath: getIconUris(button.iconPath),
                        iconClass: types_impl_1.ThemeIcon.is(button.iconPath) ? themeService_1.ThemeIcon.asClassName(button.iconPath) : undefined,
                        tooltip: button.tooltip,
                        handle: button === types_impl_1.QuickInputButtons.Back ? -1 : index,
                    }))
                });
            }
        }
        this.update({
            items: pickItems,
        });
    }
    get canSelectMany() {
        return this._canSelectMany;
    }
    set canSelectMany(canSelectMany) {
        this._canSelectMany = canSelectMany;
        this.update({ canSelectMany });
    }
    get matchOnDescription() {
        return this._matchOnDescription;
    }
    set matchOnDescription(matchOnDescription) {
        this._matchOnDescription = matchOnDescription;
        this.update({ matchOnDescription });
    }
    get matchOnDetail() {
        return this._matchOnDetail;
    }
    set matchOnDetail(matchOnDetail) {
        this._matchOnDetail = matchOnDetail;
        this.update({ matchOnDetail });
    }
    get sortByLabel() {
        return this._sortByLabel;
    }
    set sortByLabel(sortByLabel) {
        this._sortByLabel = sortByLabel;
        this.update({ sortByLabel });
    }
    get keepScrollPosition() {
        return this._keepScrollPosition;
    }
    set keepScrollPosition(keepScrollPosition) {
        this._keepScrollPosition = keepScrollPosition;
        this.update({ keepScrollPosition });
    }
    get activeItems() {
        return this._activeItems;
    }
    set activeItems(activeItems) {
        this._activeItems = activeItems.filter(item => this._itemsToHandles.has(item));
        this.update({ activeItems: this._activeItems.map(item => this._itemsToHandles.get(item)) });
    }
    get selectedItems() {
        return this._selectedItems;
    }
    set selectedItems(selectedItems) {
        this._selectedItems = selectedItems.filter(item => this._itemsToHandles.has(item));
        this.update({ selectedItems: this._selectedItems.map(item => this._itemsToHandles.get(item)) });
    }
    _fireDidChangeActive(handles) {
        const items = handles.map(handle => this._handlesToItems.get(handle)).filter(e => !!e);
        this._activeItems = items;
        this._onDidChangeActiveEmitter.fire(items);
    }
    _fireDidChangeSelection(handles) {
        const items = handles.map(handle => this._handlesToItems.get(handle)).filter(e => !!e);
        this._selectedItems = items;
        this._onDidChangeSelectionEmitter.fire(items);
    }
    _fireDidTriggerItemButton(itemHandle, buttonHandle) {
        const item = this._handlesToItems.get(itemHandle);
        if (!item || !item.buttons || !item.buttons.length) {
            return;
        }
        const button = item.buttons[buttonHandle];
        if (button) {
            this._onDidTriggerItemButtonEmitter.fire({
                button,
                item
            });
        }
    }
}
exports.QuickPickExt = QuickPickExt;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/scm.js":
/*!***************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/scm.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019-2021 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmExtImpl = exports.ScmInputBoxImpl = void 0;
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../packages/core/lib/common/event.js");
const common_1 = __webpack_require__(/*! ../common */ "../../packages/plugin-ext/lib/common/index.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../packages/core/lib/common/disposable.js");
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const paths_1 = __webpack_require__(/*! @theia/core/lib/common/paths */ "../../packages/core/lib/common/paths.js");
const plugin_icon_path_1 = __webpack_require__(/*! ./plugin-icon-path */ "../../packages/plugin-ext/lib/plugin/plugin-icon-path.js");
function getIconResource(decorations) {
    if (!decorations || !decorations.iconPath) {
        return undefined;
    }
    else if (typeof decorations.iconPath === 'string') {
        return types_impl_1.URI.file(decorations.iconPath);
    }
    else if (types_impl_1.URI.isUri(decorations.iconPath)) {
        return decorations.iconPath;
    }
    else if (types_impl_1.ThemeIcon.is(decorations.iconPath)) {
        return decorations.iconPath;
    }
    else {
        console.warn(`Unexpected Value ${decorations.iconPath} in Source Control Resource Themable Decoration. URI, ThemeIcon or string expected.`);
        return undefined;
    }
}
function comparePaths(one, other, caseSensitive = false) {
    const oneParts = one.split(paths_1.sep);
    const otherParts = other.split(paths_1.sep);
    const lastOne = oneParts.length - 1;
    const lastOther = otherParts.length - 1;
    let endOne;
    let endOther;
    for (let i = 0;; i++) {
        endOne = lastOne === i;
        endOther = lastOther === i;
        if (endOne && endOther) {
            const onePart = caseSensitive ? oneParts[i].toLocaleLowerCase() : oneParts[i];
            const otherPart = caseSensitive ? otherParts[i].toLocaleLowerCase() : otherParts[i];
            return onePart > otherPart ? -1 : 1;
        }
        else if (endOne) {
            return -1;
        }
        else if (endOther) {
            return 1;
        }
        if (endOne) {
            return -1;
        }
        else if (endOther) {
            return 1;
        }
        const result = comparePathComponents(oneParts[i], otherParts[i], caseSensitive);
        if (result !== 0) {
            return result;
        }
    }
}
function comparePathComponents(one, other, caseSensitive = false) {
    if (!caseSensitive) {
        one = one && one.toLowerCase();
        other = other && other.toLowerCase();
    }
    if (one === other) {
        return 0;
    }
    return one < other ? -1 : 1;
}
function compareResourceThemableDecorations(a, b) {
    if (!a.iconPath && !b.iconPath) {
        return 0;
    }
    else if (!a.iconPath) {
        return -1;
    }
    else if (!b.iconPath) {
        return 1;
    }
    const aPath = typeof a.iconPath === 'string' ? a.iconPath : types_impl_1.URI.isUri(a.iconPath) ? a.iconPath.fsPath : a.iconPath.id;
    const bPath = typeof b.iconPath === 'string' ? b.iconPath : types_impl_1.URI.isUri(b.iconPath) ? b.iconPath.fsPath : b.iconPath.id;
    return comparePaths(aPath, bPath);
}
function compareResourceStatesDecorations(a, b) {
    let result = 0;
    if (a.strikeThrough !== b.strikeThrough) {
        return a.strikeThrough ? 1 : -1;
    }
    if (a.faded !== b.faded) {
        return a.faded ? 1 : -1;
    }
    if (a.tooltip !== b.tooltip) {
        return (a.tooltip || '').localeCompare(b.tooltip || '');
    }
    result = compareResourceThemableDecorations(a, b);
    if (result !== 0) {
        return result;
    }
    if (a.light && b.light) {
        result = compareResourceThemableDecorations(a.light, b.light);
    }
    else if (a.light) {
        return 1;
    }
    else if (b.light) {
        return -1;
    }
    if (result !== 0) {
        return result;
    }
    if (a.dark && b.dark) {
        result = compareResourceThemableDecorations(a.dark, b.dark);
    }
    else if (a.dark) {
        return 1;
    }
    else if (b.dark) {
        return -1;
    }
    return result;
}
function compareCommands(a, b) {
    if (a.command !== b.command) {
        return a.command < b.command ? -1 : 1;
    }
    if (a.title !== b.title) {
        return a.title < b.title ? -1 : 1;
    }
    if (a.tooltip !== b.tooltip) {
        if (a.tooltip !== undefined && b.tooltip !== undefined) {
            return a.tooltip < b.tooltip ? -1 : 1;
        }
        else if (a.tooltip !== undefined) {
            return 1;
        }
        else if (b.tooltip !== undefined) {
            return -1;
        }
    }
    if (a.arguments === b.arguments) {
        return 0;
    }
    else if (!a.arguments) {
        return -1;
    }
    else if (!b.arguments) {
        return 1;
    }
    else if (a.arguments.length !== b.arguments.length) {
        return a.arguments.length - b.arguments.length;
    }
    for (let i = 0; i < a.arguments.length; i++) {
        const aArg = a.arguments[i];
        const bArg = b.arguments[i];
        if (aArg === bArg) {
            continue;
        }
        return aArg < bArg ? -1 : 1;
    }
    return 0;
}
function compareResourceStates(a, b) {
    let result = comparePaths(a.resourceUri.fsPath, b.resourceUri.fsPath, true);
    if (result !== 0) {
        return result;
    }
    if (a.command && b.command) {
        result = compareCommands(a.command, b.command);
    }
    else if (a.command) {
        return 1;
    }
    else if (b.command) {
        return -1;
    }
    if (result !== 0) {
        return result;
    }
    if (a.decorations && b.decorations) {
        result = compareResourceStatesDecorations(a.decorations, b.decorations);
    }
    else if (a.decorations) {
        return 1;
    }
    else if (b.decorations) {
        return -1;
    }
    return result;
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function compareArgs(a, b) {
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
function commandEquals(a, b) {
    return a.command === b.command
        && a.title === b.title
        && a.tooltip === b.tooltip
        && (a.arguments && b.arguments ? compareArgs(a.arguments, b.arguments) : a.arguments === b.arguments);
}
function commandListEquals(a, b) {
    return equals(a, b, commandEquals);
}
function equals(one, other, itemEquals = (a, b) => a === b) {
    if (one === other) {
        return true;
    }
    if (!one || !other) {
        return false;
    }
    if (one.length !== other.length) {
        return false;
    }
    for (let i = 0, len = one.length; i < len; i++) {
        if (!itemEquals(one[i], other[i])) {
            return false;
        }
    }
    return true;
}
class ScmInputBoxImpl {
    constructor(plugin, proxy, sourceControlHandle) {
        this.plugin = plugin;
        this.proxy = proxy;
        this.sourceControlHandle = sourceControlHandle;
        this._value = '';
        this.onDidChangeEmitter = new event_1.Emitter();
        this._placeholder = '';
        this._visible = true;
        // noop
    }
    get value() {
        return this._value;
    }
    set value(value) {
        this.proxy.$setInputBoxValue(this.sourceControlHandle, value);
        this.updateValue(value);
    }
    get onDidChange() {
        return this.onDidChangeEmitter.event;
    }
    get placeholder() {
        return this._placeholder;
    }
    set placeholder(placeholder) {
        this.proxy.$setInputBoxPlaceholder(this.sourceControlHandle, placeholder);
        this._placeholder = placeholder;
    }
    get visible() {
        return this._visible;
    }
    set visible(visible) {
        this.proxy.$setInputBoxVisible(this.sourceControlHandle, visible);
        this._visible = visible;
    }
    get enabled() {
        return this._enabled;
    }
    set enabled(enabled) {
        this.proxy.$setInputBoxEnabled(this.sourceControlHandle, enabled);
        this._enabled = enabled;
    }
    get validateInput() {
        return this._validateInput;
    }
    set validateInput(fn) {
        if (fn && typeof fn !== 'function') {
            throw new Error(`[${this.plugin.model.id}]: Invalid SCM input box validation function`);
        }
        this._validateInput = fn;
    }
    onInputBoxValueChange(value) {
        this.updateValue(value);
    }
    updateValue(value) {
        this._value = value;
        this.onDidChangeEmitter.fire(value);
    }
}
exports.ScmInputBoxImpl = ScmInputBoxImpl;
class ScmResourceGroupImpl {
    constructor(proxy, commands, sourceControlHandle, plugin, _id, _label) {
        this.proxy = proxy;
        this.commands = commands;
        this.sourceControlHandle = sourceControlHandle;
        this.plugin = plugin;
        this._id = _id;
        this._label = _label;
        this.resourceHandlePool = 0;
        this._resourceStates = [];
        this.resourceStatesMap = new Map();
        this.resourceStatesCommandsMap = new Map();
        this.resourceStatesDisposablesMap = new Map();
        this.onDidUpdateResourceStatesEmitter = new event_1.Emitter();
        this.onDidUpdateResourceStates = this.onDidUpdateResourceStatesEmitter.event;
        this._disposed = false;
        this.onDidDisposeEmitter = new event_1.Emitter();
        this.onDidDispose = this.onDidDisposeEmitter.event;
        this.handlesSnapshot = [];
        this.resourceSnapshot = [];
        this._hideWhenEmpty = undefined;
        this.handle = ScmResourceGroupImpl.handlePool++;
    }
    get disposed() { return this._disposed; }
    get id() { return this._id; }
    get label() { return this._label; }
    set label(label) {
        this._label = label;
        this.proxy.$updateGroupLabel(this.sourceControlHandle, this.handle, label);
    }
    get hideWhenEmpty() { return this._hideWhenEmpty; }
    set hideWhenEmpty(hideWhenEmpty) {
        this._hideWhenEmpty = hideWhenEmpty;
        this.proxy.$updateGroup(this.sourceControlHandle, this.handle, this.features);
    }
    get features() {
        return {
            hideWhenEmpty: this.hideWhenEmpty
        };
    }
    get resourceStates() { return [...this._resourceStates]; }
    set resourceStates(resources) {
        this._resourceStates = [...resources];
        this.onDidUpdateResourceStatesEmitter.fire();
    }
    getResourceState(handle) {
        return this.resourceStatesMap.get(handle);
    }
    executeResourceCommand(handle) {
        const command = this.resourceStatesCommandsMap.get(handle);
        if (!command) {
            return Promise.resolve(undefined);
        }
        return new Promise(() => this.commands.executeCommand(command.command, ...(command.arguments || [])));
    }
    takeResourceStateSnapshot() {
        var _a;
        const snapshot = [...this._resourceStates];
        const diffs = sortedDiff(this.resourceSnapshot, snapshot, compareResourceStates);
        const splices = diffs.map(diff => {
            const toInsert = diff.toInsert.map(r => {
                const handle = this.resourceHandlePool++;
                this.resourceStatesMap.set(handle, r);
                const sourceUri = r.resourceUri;
                const icon = getIconResource(r.decorations);
                const lightIcon = r.decorations && getIconResource(r.decorations.light) || icon;
                const darkIcon = r.decorations && getIconResource(r.decorations.dark) || icon;
                const icons = [this.getThemableIcon(lightIcon), this.getThemableIcon(darkIcon)];
                let command;
                if (r.command) {
                    if (r.command.command === 'theia.open' || r.command.command === 'theia.diff') {
                        const disposables = new disposable_1.DisposableCollection();
                        command = this.commands.converter.toSafeCommand(r.command, disposables);
                        this.resourceStatesDisposablesMap.set(handle, disposables);
                    }
                    else {
                        this.resourceStatesCommandsMap.set(handle, r.command);
                    }
                }
                const tooltip = (r.decorations && r.decorations.tooltip) || '';
                const strikeThrough = r.decorations && !!r.decorations.strikeThrough;
                const faded = r.decorations && !!r.decorations.faded;
                const contextValue = r.contextValue || '';
                // TODO remove the letter and colorId fields when the FileDecorationProvider is applied, see https://github.com/eclipse-theia/theia/pull/8911
                const rawResource = {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    handle, sourceUri, letter: r.letter, colorId: r.color.id, icons,
                    tooltip, strikeThrough, faded, contextValue, command
                };
                return { rawResource, handle };
            });
            const { start, deleteCount } = diff;
            return { start, deleteCount, toInsert };
        });
        const rawResourceSplices = splices
            .map(({ start, deleteCount, toInsert }) => ({
            start: start,
            deleteCount: deleteCount,
            rawResources: toInsert.map(i => i.rawResource)
        }));
        const reverseSplices = splices.reverse();
        for (const { start, deleteCount, toInsert } of reverseSplices) {
            const handles = toInsert.map(i => i.handle);
            const handlesToDelete = this.handlesSnapshot.splice(start, deleteCount, ...handles);
            for (const handle of handlesToDelete) {
                this.resourceStatesMap.delete(handle);
                this.resourceStatesCommandsMap.delete(handle);
                (_a = this.resourceStatesDisposablesMap.get(handle)) === null || _a === void 0 ? void 0 : _a.dispose();
                this.resourceStatesDisposablesMap.delete(handle);
            }
        }
        this.resourceSnapshot = snapshot;
        return rawResourceSplices;
    }
    getThemableIcon(icon) {
        if (!icon) {
            return undefined;
        }
        else if (types_impl_1.ThemeIcon.is(icon)) {
            return icon;
        }
        return plugin_icon_path_1.PluginIconPath.asString(types_impl_1.URI.revive(icon), this.plugin);
    }
    dispose() {
        this._disposed = true;
        this.onDidDisposeEmitter.fire();
    }
}
ScmResourceGroupImpl.handlePool = 0;
class SourceControlImpl {
    constructor(plugin, proxy, commands, _id, _label, _rootUri) {
        this.plugin = plugin;
        this.proxy = proxy;
        this.commands = commands;
        this._id = _id;
        this._label = _label;
        this._rootUri = _rootUri;
        this.groups = new Map();
        this._count = undefined;
        this._quickDiffProvider = undefined;
        this._commitTemplate = undefined;
        this.acceptInputDisposables = new disposable_1.DisposableCollection();
        this._acceptInputCommand = undefined;
        this._statusBarDisposables = new disposable_1.DisposableCollection();
        this._statusBarCommands = undefined;
        this._selected = false;
        this.onDidChangeSelectionEmitter = new event_1.Emitter();
        this.onDidChangeSelection = this.onDidChangeSelectionEmitter.event;
        this.handle = SourceControlImpl.handlePool++;
        this.createdResourceGroups = new Map();
        this.updatedResourceGroups = new Set();
        this._inputBox = new ScmInputBoxImpl(plugin, this.proxy, this.handle);
        this.proxy.$registerSourceControl(this.handle, _id, _label, _rootUri);
    }
    get id() {
        return this._id;
    }
    get label() {
        return this._label;
    }
    get rootUri() {
        return this._rootUri;
    }
    get inputBox() { return this._inputBox; }
    get count() {
        return this._count;
    }
    set count(count) {
        if (this._count === count) {
            return;
        }
        this._count = count;
        this.proxy.$updateSourceControl(this.handle, { count });
    }
    get quickDiffProvider() {
        return this._quickDiffProvider;
    }
    set quickDiffProvider(quickDiffProvider) {
        this._quickDiffProvider = quickDiffProvider;
        this.proxy.$updateSourceControl(this.handle, { hasQuickDiffProvider: !!quickDiffProvider });
    }
    get commitTemplate() {
        return this._commitTemplate;
    }
    set commitTemplate(commitTemplate) {
        if (commitTemplate === this._commitTemplate) {
            return;
        }
        this._commitTemplate = commitTemplate;
        this.proxy.$updateSourceControl(this.handle, { commitTemplate });
    }
    get acceptInputCommand() {
        return this._acceptInputCommand;
    }
    set acceptInputCommand(acceptInputCommand) {
        this.acceptInputDisposables = new disposable_1.DisposableCollection();
        this._acceptInputCommand = acceptInputCommand;
        const internal = this.commands.converter.toSafeCommand(acceptInputCommand, this.acceptInputDisposables);
        this.proxy.$updateSourceControl(this.handle, { acceptInputCommand: internal });
    }
    get statusBarCommands() {
        return this._statusBarCommands;
    }
    set statusBarCommands(statusBarCommands) {
        if (this._statusBarCommands && statusBarCommands && commandListEquals(this._statusBarCommands, statusBarCommands)) {
            return;
        }
        this._statusBarDisposables = new disposable_1.DisposableCollection();
        this._statusBarCommands = statusBarCommands;
        const internal = (statusBarCommands || []).map(c => this.commands.converter.toSafeCommand(c, this._statusBarDisposables));
        this.proxy.$updateSourceControl(this.handle, { statusBarCommands: internal });
    }
    get selected() {
        return this._selected;
    }
    createResourceGroup(id, label) {
        const group = new ScmResourceGroupImpl(this.proxy, this.commands, this.handle, this.plugin, id, label);
        const disposable = group.onDidDispose(() => this.createdResourceGroups.delete(group));
        this.createdResourceGroups.set(group, disposable);
        this.eventuallyAddResourceGroups();
        return group;
    }
    eventuallyAddResourceGroups() {
        const groups = [];
        const splices = [];
        for (const [group, disposable] of this.createdResourceGroups) {
            disposable.dispose();
            const updateListener = group.onDidUpdateResourceStates(() => {
                this.updatedResourceGroups.add(group);
                this.eventuallyUpdateResourceStates();
            });
            group.onDidDispose(() => {
                this.updatedResourceGroups.delete(group);
                updateListener.dispose();
                this.groups.delete(group.handle);
                this.proxy.$unregisterGroup(this.handle, group.handle);
            });
            const { handle, id, label, features } = group;
            groups.push({ handle, id, label, features });
            const snapshot = group.takeResourceStateSnapshot();
            if (snapshot.length > 0) {
                splices.push({ handle: group.handle, splices: snapshot });
            }
            this.groups.set(group.handle, group);
        }
        this.proxy.$registerGroups(this.handle, groups, splices);
        this.createdResourceGroups.clear();
    }
    eventuallyUpdateResourceStates() {
        const splices = [];
        this.updatedResourceGroups.forEach(group => {
            const snapshot = group.takeResourceStateSnapshot();
            if (snapshot.length === 0) {
                return;
            }
            splices.push({ handle: group.handle, splices: snapshot });
        });
        if (splices.length > 0) {
            this.proxy.$spliceResourceStates(this.handle, splices);
        }
        this.updatedResourceGroups.clear();
    }
    getResourceGroup(handle) {
        return this.groups.get(handle);
    }
    setSelectionState(selected) {
        this._selected = selected;
        this.onDidChangeSelectionEmitter.fire(selected);
    }
    dispose() {
        this.acceptInputDisposables.dispose();
        this._statusBarDisposables.dispose();
        this.groups.forEach(group => group.dispose());
        this.proxy.$unregisterSourceControl(this.handle);
    }
}
SourceControlImpl.handlePool = 0;
class ScmExtImpl {
    constructor(rpc, commands) {
        this.commands = commands;
        this.sourceControls = new Map();
        this.sourceControlsByExtension = new Map();
        this.onDidChangeActiveProviderEmitter = new event_1.Emitter();
        this.proxy = rpc.getProxy(common_1.PLUGIN_RPC_CONTEXT.SCM_MAIN);
        commands.registerArgumentProcessor({
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            processArgument: (arg) => {
                if (!plugin_api_rpc_1.ScmCommandArg.is(arg)) {
                    return arg;
                }
                const sourceControl = this.sourceControls.get(arg.sourceControlHandle);
                if (!sourceControl) {
                    return undefined;
                }
                if (typeof arg.resourceGroupHandle !== 'number') {
                    return sourceControl;
                }
                const resourceGroup = sourceControl.getResourceGroup(arg.resourceGroupHandle);
                if (typeof arg.resourceStateHandle !== 'number') {
                    return resourceGroup;
                }
                return resourceGroup && resourceGroup.getResourceState(arg.resourceStateHandle);
            }
        });
    }
    get onDidChangeActiveProvider() { return this.onDidChangeActiveProviderEmitter.event; }
    createSourceControl(extension, id, label, rootUri) {
        const handle = ScmExtImpl.handlePool++;
        const sourceControl = new SourceControlImpl(extension, this.proxy, this.commands, id, label, rootUri);
        this.sourceControls.set(handle, sourceControl);
        const sourceControls = this.sourceControlsByExtension.get(extension.model.id) || [];
        sourceControls.push(sourceControl);
        this.sourceControlsByExtension.set(extension.model.id, sourceControls);
        return sourceControl;
    }
    getLastInputBox(extension) {
        const sourceControls = this.sourceControlsByExtension.get(extension.model.id);
        const sourceControl = sourceControls && sourceControls[sourceControls.length - 1];
        return sourceControl && sourceControl.inputBox;
    }
    $provideOriginalResource(sourceControlHandle, uriComponents, token) {
        const sourceControl = this.sourceControls.get(sourceControlHandle);
        if (!sourceControl || !sourceControl.quickDiffProvider || !sourceControl.quickDiffProvider.provideOriginalResource) {
            return Promise.resolve(undefined);
        }
        return new Promise(() => sourceControl.quickDiffProvider.provideOriginalResource(types_impl_1.URI.file(uriComponents), token))
            .then(r => r || undefined);
    }
    $onInputBoxValueChange(sourceControlHandle, value) {
        const sourceControl = this.sourceControls.get(sourceControlHandle);
        if (!sourceControl) {
            return Promise.resolve(undefined);
        }
        sourceControl.inputBox.onInputBoxValueChange(value);
        return Promise.resolve(undefined);
    }
    $executeResourceCommand(sourceControlHandle, groupHandle, handle) {
        const sourceControl = this.sourceControls.get(sourceControlHandle);
        if (!sourceControl) {
            return Promise.resolve(undefined);
        }
        const group = sourceControl.getResourceGroup(groupHandle);
        if (!group) {
            return Promise.resolve(undefined);
        }
        return group.executeResourceCommand(handle);
    }
    async $validateInput(sourceControlHandle, value, cursorPosition) {
        const sourceControl = this.sourceControls.get(sourceControlHandle);
        if (!sourceControl) {
            return Promise.resolve(undefined);
        }
        if (!sourceControl.inputBox.validateInput) {
            return Promise.resolve(undefined);
        }
        const result = await sourceControl.inputBox.validateInput(value, cursorPosition);
        if (!result) {
            return Promise.resolve(undefined);
        }
        return [result.message, result.type];
    }
    $setSelectedSourceControl(selectedSourceControlHandle) {
        var _a, _b;
        if (selectedSourceControlHandle !== undefined) {
            (_a = this.sourceControls.get(selectedSourceControlHandle)) === null || _a === void 0 ? void 0 : _a.setSelectionState(true);
        }
        if (this.selectedSourceControlHandle !== undefined) {
            (_b = this.sourceControls.get(this.selectedSourceControlHandle)) === null || _b === void 0 ? void 0 : _b.setSelectionState(false);
        }
        this.selectedSourceControlHandle = selectedSourceControlHandle;
        return Promise.resolve(undefined);
    }
}
exports.ScmExtImpl = ScmExtImpl;
ScmExtImpl.handlePool = 0;
/**
 * Diffs two *sorted* arrays and computes the splices which apply the diff.
 */
function sortedDiff(before, after, compare) {
    const result = [];
    function pushSplice(start, deleteCount, toInsert) {
        if (deleteCount === 0 && toInsert.length === 0) {
            return;
        }
        const latest = result[result.length - 1];
        if (latest && latest.start + latest.deleteCount === start) {
            latest.deleteCount += deleteCount;
            latest.toInsert.push(...toInsert);
        }
        else {
            result.push({ start, deleteCount, toInsert });
        }
    }
    let beforeIdx = 0;
    let afterIdx = 0;
    while (true) {
        if (beforeIdx === before.length) {
            pushSplice(beforeIdx, 0, after.slice(afterIdx));
            break;
        }
        if (afterIdx === after.length) {
            pushSplice(beforeIdx, before.length - beforeIdx, []);
            break;
        }
        const beforeElement = before[beforeIdx];
        const afterElement = after[afterIdx];
        const n = compare(beforeElement, afterElement);
        if (n === 0) {
            // equal
            beforeIdx += 1;
            afterIdx += 1;
        }
        else if (n < 0) {
            // beforeElement is smaller -> before element removed
            pushSplice(beforeIdx, 1, []);
            beforeIdx += 1;
        }
        else if (n > 0) {
            // beforeElement is greater -> after element added
            pushSplice(beforeIdx, 0, [afterElement]);
            afterIdx += 1;
        }
    }
    return result;
}


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/secrets-ext.js":
/*!***********************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/secrets-ext.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecretStorageExt = exports.SecretsExtImpl = void 0;
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// code copied and modified from https://github.com/microsoft/vscode/blob/1.55.2/src/vs/workbench/api/common/extHostSecrets.ts
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../packages/core/lib/common/event.js");
class SecretsExtImpl {
    constructor(rpc) {
        this.onDidChangePasswordEmitter = new event_1.Emitter();
        this.onDidChangePassword = this.onDidChangePasswordEmitter.event;
        this.proxy = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.SECRETS_MAIN);
    }
    async $onDidChangePassword(e) {
        this.onDidChangePasswordEmitter.fire(e);
    }
    get(extensionId, key) {
        return this.proxy.$getPassword(extensionId, key);
    }
    store(extensionId, key, value) {
        return this.proxy.$setPassword(extensionId, key, value);
    }
    delete(extensionId, key) {
        return this.proxy.$deletePassword(extensionId, key);
    }
}
exports.SecretsExtImpl = SecretsExtImpl;
class SecretStorageExt {
    constructor(pluginDescription, secretState) {
        this.onDidChangeEmitter = new event_1.Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
        this.id = pluginDescription.model.id.toLowerCase();
        this.secretState = secretState;
        this.secretState.onDidChangePassword(e => {
            if (e.extensionId === this.id) {
                this.onDidChangeEmitter.fire({ key: e.key });
            }
        });
    }
    get(key) {
        return this.secretState.get(this.id, key);
    }
    store(key, value) {
        return this.secretState.store(this.id, key, value);
    }
    delete(key) {
        return this.secretState.delete(this.id, key);
    }
}
exports.SecretStorageExt = SecretStorageExt;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/status-bar-message-registry.js":
/*!***************************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/status-bar-message-registry.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatusBarMessageRegistryExt = void 0;
// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const status_bar_item_1 = __webpack_require__(/*! ./status-bar/status-bar-item */ "../../packages/plugin-ext/lib/plugin/status-bar/status-bar-item.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
class StatusBarMessageRegistryExt {
    constructor(rpc) {
        this.proxy = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.STATUS_BAR_MESSAGE_REGISTRY_MAIN);
        this.statusMessage = new StatusBarMessage(this);
    }
    // copied from https://github.com/Microsoft/vscode/blob/6c8f02b41db9ae5c4d15df767d47755e5c73b9d5/src/vs/workbench/api/node/extHostStatusBar.ts#L174
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    setStatusBarMessage(text, timeoutOrThenable) {
        const d = this.statusMessage.setMessage(text);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        let handle;
        if (typeof timeoutOrThenable === 'number') {
            handle = setTimeout(() => d.dispose(), timeoutOrThenable);
        }
        else if (typeof timeoutOrThenable !== 'undefined') {
            timeoutOrThenable.then(() => d.dispose(), () => d.dispose());
        }
        return new types_impl_1.Disposable(() => {
            d.dispose();
            clearTimeout(handle);
        });
    }
    createStatusBarItem(alignment, priority, id) {
        return new status_bar_item_1.StatusBarItemImpl(this.proxy, alignment, priority, id);
    }
}
exports.StatusBarMessageRegistryExt = StatusBarMessageRegistryExt;
// copied from https://github.com/Microsoft/vscode/blob/6c8f02b41db9ae5c4d15df767d47755e5c73b9d5/src/vs/workbench/api/node/extHostStatusBar.ts#L122
class StatusBarMessage {
    constructor(statusBar) {
        this._messages = [];
        this._item = statusBar.createStatusBarItem(types_impl_1.StatusBarAlignment.Left, Number.MIN_VALUE);
    }
    dispose() {
        this._messages.length = 0;
        this._item.dispose();
    }
    setMessage(message) {
        const data = { message }; // use object to not confuse equal strings
        this._messages.unshift(data);
        this._update();
        return new types_impl_1.Disposable(() => {
            const idx = this._messages.indexOf(data);
            if (idx >= 0) {
                this._messages.splice(idx, 1);
                this._update();
            }
        });
    }
    _update() {
        if (this._messages.length > 0) {
            this._item.text = this._messages[0].message;
            this._item.show();
        }
        else {
            this._item.hide();
        }
    }
}


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/status-bar/status-bar-item.js":
/*!**************************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/status-bar/status-bar-item.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatusBarItemImpl = void 0;
const types_impl_1 = __webpack_require__(/*! ../types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const coreutils_1 = __webpack_require__(/*! @theia/core/shared/@phosphor/coreutils */ "../../packages/core/shared/@phosphor/coreutils/index.js");
class StatusBarItemImpl {
    constructor(_proxy, alignment = types_impl_1.StatusBarAlignment.Left, priority = 0, id = StatusBarItemImpl.nextId()) {
        this._proxy = _proxy;
        this._alignment = alignment;
        this._priority = priority;
        this._id = id;
    }
    get id() {
        return this._id;
    }
    get alignment() {
        return this._alignment;
    }
    get priority() {
        return this._priority;
    }
    get name() {
        return this._name;
    }
    get text() {
        return this._text;
    }
    get tooltip() {
        return this._tooltip;
    }
    get color() {
        return this._color;
    }
    get backgroundColor() {
        return this._backgroundColor;
    }
    get command() {
        return this._command;
    }
    get accessibilityInformation() {
        return this._accessibilityInformation;
    }
    set name(name) {
        this._name = name;
        this.update();
    }
    set text(text) {
        this._text = text;
        this.update();
    }
    set tooltip(tooltip) {
        this._tooltip = tooltip;
        this.update();
    }
    set color(color) {
        this._color = color;
        this.update();
    }
    set backgroundColor(backgroundColor) {
        if (backgroundColor && StatusBarItemImpl.BACKGROUND_COLORS.has(backgroundColor.id)) {
            this._backgroundColor = backgroundColor;
        }
        else {
            this._backgroundColor = undefined;
        }
        this.update();
    }
    set command(command) {
        this._command = command;
        this.update();
    }
    set accessibilityInformation(information) {
        this._accessibilityInformation = information;
        this.update();
    }
    show() {
        this._isVisible = true;
        this.update();
    }
    hide() {
        if (this._timeoutHandle) {
            clearTimeout(this._timeoutHandle);
        }
        this._proxy.$dispose(this.id);
        this._isVisible = false;
    }
    update() {
        if (!this._isVisible) {
            return;
        }
        if (this._timeoutHandle) {
            clearTimeout(this._timeoutHandle);
        }
        // Defer the update so that multiple changes to setters don't cause a redraw each
        this._timeoutHandle = setTimeout(() => {
            var _a;
            this._timeoutHandle = undefined;
            const commandId = typeof this.command === 'object' ? this.command.command : this.command;
            const args = typeof this.command === 'object' ? this.command.arguments : undefined;
            let color = this.color;
            if (this.backgroundColor) {
                // If an error or warning background color is set, set the corresponding foreground color
                color = StatusBarItemImpl.BACKGROUND_COLORS.get(this.backgroundColor.id);
            }
            // Set to status bar
            this._proxy.$setMessage(this.id, this.name, this.text, this.priority, this.alignment, typeof color === 'string' ? color : color === null || color === void 0 ? void 0 : color.id, (_a = this.backgroundColor) === null || _a === void 0 ? void 0 : _a.id, this.tooltip, commandId, this.accessibilityInformation, args);
        }, 0);
    }
    dispose() {
        this.hide();
    }
    static nextId() {
        return StatusBarItemImpl.ID_PREFIX + ':' + coreutils_1.UUID.uuid4();
    }
}
exports.StatusBarItemImpl = StatusBarItemImpl;
/** Map from allowed background colors to corresponding foreground colors. */
StatusBarItemImpl.BACKGROUND_COLORS = new Map([
    ['statusBarItem.errorBackground', 'statusBarItem.errorForeground'],
    ['statusBarItem.warningBackground', 'statusBarItem.warningForeground']
]);
StatusBarItemImpl.ID_PREFIX = 'plugin-status-bar-item';


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/stubs/tests-api.js":
/*!***************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/stubs/tests-api.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createTestItem = exports.testItemCollection = exports.createTestRun = exports.createRunProfile = void 0;
/* tslint:disable:typedef */
const cancellation_1 = __webpack_require__(/*! @theia/core/lib/common/cancellation */ "../../packages/core/lib/common/cancellation.js");
const createRunProfile = (label, kind, runHandler, isDefault, tag, supportsContinuousRun) => ({
    label,
    kind,
    isDefault: isDefault !== null && isDefault !== void 0 ? isDefault : false,
    tag,
    supportsContinuousRun: supportsContinuousRun !== null && supportsContinuousRun !== void 0 ? supportsContinuousRun : false,
    runHandler,
    configureHandler: undefined,
    dispose: () => undefined,
});
exports.createRunProfile = createRunProfile;
const createTestRun = (request, name, persist) => ({
    name,
    token: cancellation_1.CancellationToken.None,
    isPersisted: false,
    enqueued: (test) => undefined,
    started: (test) => undefined,
    skipped: (test) => undefined,
    failed: (test, message, duration) => undefined,
    errored: (test, message, duration) => undefined,
    passed: (test, duration) => undefined,
    appendOutput: (output, location, test) => undefined,
    end: () => undefined,
});
exports.createTestRun = createTestRun;
exports.testItemCollection = {
    add: () => { },
    delete: () => { },
    forEach: () => { },
    *[Symbol.iterator]() { },
    get: () => undefined,
    replace: () => { },
    size: 0,
};
const createTestItem = (id, label, uri) => ({
    id,
    label,
    uri,
    children: exports.testItemCollection,
    parent: undefined,
    tags: [],
    canResolveChildren: false,
    busy: false,
    range: undefined,
    error: undefined,
});
exports.createTestItem = createTestItem;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/tabs.js":
/*!****************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/tabs.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TabsExtImpl = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "../../packages/core/lib/common/index.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const types_1 = __webpack_require__(/*! ../common/types */ "../../packages/plugin-ext/lib/common/types.js");
const collections_1 = __webpack_require__(/*! ../common/collections */ "../../packages/plugin-ext/lib/common/collections.js");
const type_converters_1 = __webpack_require__(/*! ./type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
class TabExt {
    constructor(dto, parentGroup, activeTabIdGetter) {
        this.activeTabIdGetter = activeTabIdGetter;
        this.parentGroup = parentGroup;
        this.acceptDtoUpdate(dto);
    }
    get apiObject() {
        if (!this.tabApiObject) {
            // Don't want to lose reference to parent `this` in the getters
            const that = this;
            const obj = {
                get isActive() {
                    // We use a getter function here to always ensure at most 1 active tab per group and prevent iteration for being required
                    return that.tabDto.id === that.activeTabIdGetter();
                },
                get label() {
                    return that.tabDto.label;
                },
                get input() {
                    return that.input;
                },
                get isDirty() {
                    return that.tabDto.isDirty;
                },
                get isPinned() {
                    return that.tabDto.isPinned;
                },
                get isPreview() {
                    return that.tabDto.isPreview;
                },
                get group() {
                    return that.parentGroup.apiObject;
                }
            };
            this.tabApiObject = Object.freeze(obj);
        }
        return this.tabApiObject;
    }
    get tabId() {
        return this.tabDto.id;
    }
    acceptDtoUpdate(tabDto) {
        this.tabDto = tabDto;
        this.input = this.initInput();
    }
    initInput() {
        switch (this.tabDto.input.kind) {
            case 1 /* TextInput */:
                return new types_impl_1.TextTabInput(types_impl_1.URI.revive(this.tabDto.input.uri));
            case 2 /* TextDiffInput */:
                return new types_impl_1.TextDiffTabInput(types_impl_1.URI.revive(this.tabDto.input.original), types_impl_1.URI.revive(this.tabDto.input.modified));
            case 3 /* TextMergeInput */:
                return new types_impl_1.TextMergeTabInput(types_impl_1.URI.revive(this.tabDto.input.base), types_impl_1.URI.revive(this.tabDto.input.input1), types_impl_1.URI.revive(this.tabDto.input.input2), types_impl_1.URI.revive(this.tabDto.input.result));
            case 6 /* CustomEditorInput */:
                return new types_impl_1.CustomEditorTabInput(types_impl_1.URI.revive(this.tabDto.input.uri), this.tabDto.input.viewType);
            case 7 /* WebviewEditorInput */:
                return new types_impl_1.WebviewEditorTabInput(this.tabDto.input.viewType);
            case 4 /* NotebookInput */:
                return new types_impl_1.NotebookEditorTabInput(types_impl_1.URI.revive(this.tabDto.input.uri), this.tabDto.input.notebookType);
            case 5 /* NotebookDiffInput */:
                return new types_impl_1.NotebookDiffEditorTabInput(types_impl_1.URI.revive(this.tabDto.input.original), types_impl_1.URI.revive(this.tabDto.input.modified), this.tabDto.input.notebookType);
            case 8 /* TerminalEditorInput */:
                return new types_impl_1.TerminalEditorTabInput();
            case 9 /* InteractiveEditorInput */:
                return new types_impl_1.InteractiveWindowInput(types_impl_1.URI.revive(this.tabDto.input.uri), types_impl_1.URI.revive(this.tabDto.input.inputBoxUri));
            default:
                return undefined;
        }
    }
}
class TabGroupExt {
    constructor(dto, activeGroupIdGetter) {
        this.tabsArr = [];
        this.activeTabId = '';
        this.tabGroupDto = dto;
        this.activeGroupIdGetter = activeGroupIdGetter;
        // Construct all tabs from the given dto
        for (const tabDto of dto.tabs) {
            if (tabDto.isActive) {
                this.activeTabId = tabDto.id;
            }
            this.tabsArr.push(new TabExt(tabDto, this, () => this.getActiveTabId()));
        }
    }
    get apiObject() {
        if (!this.tabGroupApiObject) {
            // Don't want to lose reference to parent `this` in the getters
            const that = this;
            const obj = {
                get isActive() {
                    // We use a getter function here to always ensure at most 1 active group and prevent iteration for being required
                    return that.tabGroupDto.groupId === that.activeGroupIdGetter();
                },
                get viewColumn() {
                    return type_converters_1.ViewColumn.to(that.tabGroupDto.viewColumn);
                },
                get activeTab() {
                    var _a;
                    return (_a = that.tabsArr.find(tab => tab.tabId === that.activeTabId)) === null || _a === void 0 ? void 0 : _a.apiObject;
                },
                get tabs() {
                    return Object.freeze(that.tabsArr.map(tab => tab.apiObject));
                }
            };
            this.tabGroupApiObject = Object.freeze(obj);
        }
        return this.tabGroupApiObject;
    }
    get groupId() {
        return this.tabGroupDto.groupId;
    }
    get tabs() {
        return this.tabsArr;
    }
    acceptGroupDtoUpdate(dto) {
        this.tabGroupDto = dto;
    }
    acceptTabOperation(operation) {
        // In the open case we add the tab to the group
        if (operation.kind === 0 /* TAB_OPEN */) {
            const tab = new TabExt(operation.tabDto, this, () => this.getActiveTabId());
            // Insert tab at editor index
            this.tabsArr.splice(operation.index, 0, tab);
            if (operation.tabDto.isActive) {
                this.activeTabId = tab.tabId;
            }
            return tab;
        }
        else if (operation.kind === 1 /* TAB_CLOSE */) {
            const tab = this.tabsArr.splice(operation.index, 1)[0];
            if (!tab) {
                throw new Error(`Tab close updated received for index ${operation.index} which does not exist`);
            }
            if (tab.tabId === this.activeTabId) {
                this.activeTabId = '';
            }
            return tab;
        }
        else if (operation.kind === 3 /* TAB_MOVE */) {
            if (operation.oldIndex === undefined) {
                throw new Error('Invalid old index on move IPC');
            }
            // Splice to remove at old index and insert at new index === moving the tab
            const tab = this.tabsArr.splice(operation.oldIndex, 1)[0];
            if (!tab) {
                throw new Error(`Tab move updated received for index ${operation.oldIndex} which does not exist`);
            }
            this.tabsArr.splice(operation.index, 0, tab);
            return tab;
        }
        const _tab = this.tabsArr.find(extHostTab => extHostTab.tabId === operation.tabDto.id);
        if (!_tab) {
            throw new Error('INVALID tab');
        }
        if (operation.tabDto.isActive) {
            this.activeTabId = operation.tabDto.id;
        }
        else if (this.activeTabId === operation.tabDto.id && !operation.tabDto.isActive) {
            // Events aren't guaranteed to be in order so if we receive a dto that matches the active tab id
            // but isn't active we mark the active tab id as empty. This prevent onDidActiveTabChange from
            // firing incorrectly
            this.activeTabId = '';
        }
        _tab.acceptDtoUpdate(operation.tabDto);
        return _tab;
    }
    // Not a getter since it must be a function to be used as a callback for the tabs
    getActiveTabId() {
        return this.activeTabId;
    }
}
class TabsExtImpl {
    constructor(rpc) {
        this.rpc = rpc;
        this.onDidChangeTabs = new core_1.Emitter();
        this.onDidChangeTabGroups = new core_1.Emitter();
        this.tabGroupArr = [];
        this.proxy = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.TABS_MAIN);
    }
    get tabGroups() {
        if (!this.apiObject) {
            const that = this;
            const obj = {
                // never changes -> simple value
                onDidChangeTabGroups: that.onDidChangeTabGroups.event,
                onDidChangeTabs: that.onDidChangeTabs.event,
                // dynamic -> getters
                get all() {
                    return Object.freeze(that.tabGroupArr.map(group => group.apiObject));
                },
                get activeTabGroup() {
                    var _a;
                    const activeTabGroupId = that.activeGroupId;
                    const activeTabGroup = (0, types_1.assertIsDefined)((_a = that.tabGroupArr.find(candidate => candidate.groupId === activeTabGroupId)) === null || _a === void 0 ? void 0 : _a.apiObject);
                    return activeTabGroup;
                },
                close: async (tabOrTabGroup, preserveFocus) => {
                    const tabsOrTabGroups = Array.isArray(tabOrTabGroup) ? tabOrTabGroup : [tabOrTabGroup];
                    if (!tabsOrTabGroups.length) {
                        return true;
                    }
                    // Check which type was passed in and call the appropriate close
                    // Casting is needed as typescript doesn't seem to infer enough from this
                    if (isTabGroup(tabsOrTabGroups[0])) {
                        return this._closeGroups(tabsOrTabGroups, preserveFocus);
                    }
                    else {
                        return this._closeTabs(tabsOrTabGroups, preserveFocus);
                    }
                },
            };
            this.apiObject = Object.freeze(obj);
        }
        return this.apiObject;
    }
    $acceptEditorTabModel(tabGroups) {
        var _a;
        const groupIdsBefore = new Set(this.tabGroupArr.map(group => group.groupId));
        const groupIdsAfter = new Set(tabGroups.map(dto => dto.groupId));
        const diff = (0, collections_1.diffSets)(groupIdsBefore, groupIdsAfter);
        const closed = this.tabGroupArr.filter(group => diff.removed.includes(group.groupId)).map(group => group.apiObject);
        const opened = [];
        const changed = [];
        const tabsOpened = [];
        this.tabGroupArr = tabGroups.map(tabGroup => {
            const group = new TabGroupExt(tabGroup, () => this.activeGroupId);
            if (diff.added.includes(group.groupId)) {
                opened.push({ activeTab: undefined, isActive: group.apiObject.isActive, tabs: [], viewColumn: group.apiObject.viewColumn });
                tabsOpened.push(...group.apiObject.tabs);
            }
            else {
                changed.push(group.apiObject);
            }
            return group;
        });
        // Set the active tab group id. skip if no tabgroups are open
        if (tabGroups.length > 0) {
            const activeTabGroupId = (0, types_1.assertIsDefined)((_a = tabGroups.find(group => group.isActive === true)) === null || _a === void 0 ? void 0 : _a.groupId);
            if (this.activeGroupId !== activeTabGroupId) {
                this.activeGroupId = activeTabGroupId;
            }
        }
        this.onDidChangeTabGroups.fire(Object.freeze({ opened, closed, changed }));
        this.onDidChangeTabs.fire({ opened: tabsOpened, changed: [], closed: [] });
    }
    $acceptTabGroupUpdate(groupDto) {
        const group = this.tabGroupArr.find(tabGroup => tabGroup.groupId === groupDto.groupId);
        if (!group) {
            throw new Error('Update Group IPC call received before group creation.');
        }
        group.acceptGroupDtoUpdate(groupDto);
        if (groupDto.isActive) {
            this.activeGroupId = groupDto.groupId;
        }
        this.onDidChangeTabGroups.fire(Object.freeze({ changed: [group.apiObject], opened: [], closed: [] }));
    }
    $acceptTabOperation(operation) {
        const group = this.tabGroupArr.find(tabGroup => tabGroup.groupId === operation.groupId);
        if (!group) {
            throw new Error('Update Tabs IPC call received before group creation.');
        }
        const tab = group.acceptTabOperation(operation);
        // Construct the tab change event based on the operation
        switch (operation.kind) {
            case 0 /* TAB_OPEN */:
                this.onDidChangeTabs.fire(Object.freeze({
                    opened: [tab.apiObject],
                    closed: [],
                    changed: []
                }));
                return;
            case 1 /* TAB_CLOSE */:
                this.onDidChangeTabs.fire(Object.freeze({
                    opened: [],
                    closed: [tab.apiObject],
                    changed: []
                }));
                return;
            case 3 /* TAB_MOVE */:
            case 2 /* TAB_UPDATE */:
                this.onDidChangeTabs.fire(Object.freeze({
                    opened: [],
                    closed: [],
                    changed: [tab.apiObject]
                }));
                return;
        }
    }
    _findExtHostTabFromApi(apiTab) {
        for (const group of this.tabGroupArr) {
            for (const tab of group.tabs) {
                if (tab.apiObject === apiTab) {
                    return tab;
                }
            }
        }
        return;
    }
    _findExtHostTabGroupFromApi(apiTabGroup) {
        return this.tabGroupArr.find(candidate => candidate.apiObject === apiTabGroup);
    }
    async _closeTabs(tabs, preserveFocus) {
        const extHostTabIds = [];
        for (const tab of tabs) {
            const extHostTab = this._findExtHostTabFromApi(tab);
            if (!extHostTab) {
                throw new Error('Tab close: Invalid tab not found!');
            }
            extHostTabIds.push(extHostTab.tabId);
        }
        return this.proxy.$closeTab(extHostTabIds, preserveFocus);
    }
    async _closeGroups(groups, preserveFocus) {
        const extHostGroupIds = [];
        for (const group of groups) {
            const extHostGroup = this._findExtHostTabGroupFromApi(group);
            if (!extHostGroup) {
                throw new Error('Group close: Invalid group not found!');
            }
            extHostGroupIds.push(extHostGroup.groupId);
        }
        return this.proxy.$closeGroup(extHostGroupIds, preserveFocus);
    }
}
exports.TabsExtImpl = TabsExtImpl;
// #region Utils
function isTabGroup(obj) {
    const tabGroup = obj;
    if (tabGroup.tabs !== undefined) {
        return true;
    }
    return false;
}
// #endregion


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/tasks/task-provider.js":
/*!*******************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/tasks/task-provider.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskProviderAdapter = void 0;
const Converter = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
class TaskProviderAdapter {
    constructor(provider) {
        this.provider = provider;
    }
    provideTasks(token) {
        return Promise.resolve(this.provider.provideTasks(token)).then(tasks => {
            if (!Array.isArray(tasks)) {
                return [];
            }
            const result = [];
            for (const task of tasks) {
                const data = Converter.fromTask(task);
                if (!data) {
                    continue;
                }
                result.push(data);
            }
            return result;
        });
    }
    async resolveTask(task, token) {
        if (typeof this.provider.resolveTask !== 'function') {
            return task;
        }
        const item = Converter.toTask(task);
        if (!item) {
            return task;
        }
        const resolved = await this.provider.resolveTask(item, token);
        const converted = resolved ? Converter.fromTask(resolved) : Converter.fromTask(item);
        return converted !== null && converted !== void 0 ? converted : task;
    }
}
exports.TaskProviderAdapter = TaskProviderAdapter;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/tasks/tasks.js":
/*!***********************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/tasks/tasks.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TasksExtImpl = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const converter = __webpack_require__(/*! ../type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const types_impl_1 = __webpack_require__(/*! ../types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const task_provider_1 = __webpack_require__(/*! ./task-provider */ "../../packages/plugin-ext/lib/plugin/tasks/task-provider.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../packages/core/lib/common/event.js");
const coreutils_1 = __webpack_require__(/*! @theia/core/shared/@phosphor/coreutils */ "../../packages/core/shared/@phosphor/coreutils/index.js");
const cancellation_1 = __webpack_require__(/*! @theia/core/lib/common/cancellation */ "../../packages/core/lib/common/cancellation.js");
class TasksExtImpl {
    constructor(rpc, terminalExt) {
        this.terminalExt = terminalExt;
        this.callId = 0;
        this.adaptersMap = new Map();
        this.executions = new Map();
        this.callbackIdBase = coreutils_1.UUID.uuid4();
        this.customExecutionIds = new Map();
        this.customExecutionFunctions = new Map();
        this.onDidExecuteTask = new event_1.Emitter();
        this.onDidTerminateTask = new event_1.Emitter();
        this.onDidExecuteTaskProcess = new event_1.Emitter();
        this.onDidTerminateTaskProcess = new event_1.Emitter();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.TASKS_MAIN);
    }
    get taskExecutions() {
        return [...this.executions.values()];
    }
    get onDidStartTask() {
        return this.onDidExecuteTask.event;
    }
    async $onDidStartTask(execution, terminalId) {
        const customExecution = this.customExecutionFunctions.get(execution.task.executionId || '');
        if (customExecution) {
            const taskDefinition = converter.toTask(execution.task).definition;
            const pty = await customExecution(taskDefinition);
            this.terminalExt.attachPtyToTerminal(terminalId, pty);
            if (pty.onDidClose) {
                const disposable = pty.onDidClose((e = undefined) => {
                    disposable.dispose();
                    // eslint-disable-next-line no-void
                    this.proxy.$customExecutionComplete(execution.id, e === void 0 ? undefined : e);
                });
            }
        }
        this.lastStartedTask = execution.id;
        this.onDidExecuteTask.fire({
            execution: this.getTaskExecution(execution)
        });
    }
    get onDidEndTask() {
        return this.onDidTerminateTask.event;
    }
    $onDidEndTask(id) {
        const taskExecution = this.executions.get(id);
        if (!taskExecution) {
            throw new Error(`Task execution with id ${id} is not found`);
        }
        this.executions.delete(id);
        this.onDidTerminateTask.fire({
            execution: taskExecution
        });
    }
    get onDidStartTaskProcess() {
        return this.onDidExecuteTaskProcess.event;
    }
    $onDidStartTaskProcess(processId, executionDto) {
        this.onDidExecuteTaskProcess.fire({
            processId,
            execution: this.getTaskExecution(executionDto)
        });
    }
    get onDidEndTaskProcess() {
        return this.onDidTerminateTaskProcess.event;
    }
    $onDidEndTaskProcess(exitCode, taskId) {
        const taskExecution = this.executions.get(taskId);
        if (!taskExecution) {
            throw new Error(`Task execution with id ${taskId} is not found`);
        }
        this.onDidTerminateTaskProcess.fire({
            execution: taskExecution,
            exitCode
        });
    }
    registerTaskProvider(type, provider) {
        const callId = this.addNewAdapter(new task_provider_1.TaskProviderAdapter(provider));
        this.proxy.$registerTaskProvider(callId, type);
        return this.createDisposable(callId);
    }
    async fetchTasks(filter) {
        const taskVersion = filter ? filter.version : undefined;
        const taskType = filter ? filter.type : undefined;
        const taskDtos = await this.proxy.$fetchTasks(taskVersion, taskType);
        return taskDtos.map(dto => converter.toTask(dto));
    }
    async executeTask(task) {
        const taskDto = converter.fromTask(task);
        if (taskDto) {
            // If this task is a custom execution, then we need to save it away
            // in the provided custom execution map that is cleaned up after the
            // task is executed.
            if (types_impl_1.CustomExecution.is(task.execution)) {
                taskDto.executionId = this.addCustomExecution(task.execution.callback);
            }
            const executionDto = await this.proxy.$executeTask(taskDto);
            if (executionDto) {
                const taskExecution = this.getTaskExecution(executionDto);
                return taskExecution;
            }
            throw new Error('Run task config does not return after being started');
        }
        throw new Error('Task was not successfully transformed into a task config');
    }
    async $provideTasks(handle) {
        const adapter = this.adaptersMap.get(handle);
        if (adapter) {
            return adapter.provideTasks(cancellation_1.CancellationToken.None).then(tasks => {
                for (const task of tasks) {
                    if (task.taskType === 'customExecution') {
                        this.applyCustomExecution(task);
                    }
                }
                return tasks;
            });
        }
        else {
            throw new Error('No adapter found to provide tasks');
        }
    }
    async $resolveTask(handle, task, token) {
        const adapter = this.adaptersMap.get(handle);
        if (adapter) {
            return adapter.resolveTask(task, token).then(resolvedTask => {
                var _a;
                // ensure we do not lose task type and execution id during resolution as we need it for custom execution
                resolvedTask.taskType = (_a = resolvedTask.taskType) !== null && _a !== void 0 ? _a : task.taskType;
                if (resolvedTask.taskType === 'customExecution') {
                    this.applyCustomExecution(resolvedTask);
                }
                return resolvedTask;
            });
        }
        else {
            throw new Error('No adapter found to resolve task');
        }
    }
    applyCustomExecution(task) {
        if (task.callback) {
            task.executionId = this.addCustomExecution(task.callback);
            task.callback = undefined;
        }
    }
    addNewAdapter(adapter) {
        const callId = this.nextCallId();
        this.adaptersMap.set(callId, adapter);
        return callId;
    }
    nextCallId() {
        return this.callId++;
    }
    createDisposable(callId) {
        return new types_impl_1.Disposable(() => {
            this.adaptersMap.delete(callId);
            this.proxy.$unregister(callId);
        });
    }
    // Initial `this.executions` map with the running tasks from the previous session
    async $initLoadedTasks(taskExecutions) {
        taskExecutions.forEach(execution => this.getTaskExecution(execution));
    }
    getTaskExecution(execution) {
        const executionId = execution.id;
        let result = this.executions.get(executionId);
        if (result) {
            return result;
        }
        result = {
            task: converter.toTask(execution.task),
            terminate: () => {
                this.proxy.$terminateTask(executionId);
            }
        };
        this.executions.set(executionId, result);
        return result;
    }
    addCustomExecution(callback) {
        let id = this.customExecutionIds.get(callback);
        if (!id) {
            id = this.nextCallbackId();
            this.customExecutionIds.set(callback, id);
            this.customExecutionFunctions.set(id, callback);
        }
        return id;
    }
    nextCallbackId() {
        return this.callbackIdBase + this.callbackId++;
    }
}
exports.TasksExtImpl = TasksExtImpl;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/telemetry-ext.js":
/*!*************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/telemetry-ext.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 STMicroelectronics and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cleanData = exports.TelemetryLogger = exports.TelemetryExtImpl = void 0;
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../packages/core/lib/common/event.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../packages/core/lib/common/index.js");
const types_1 = __webpack_require__(/*! ../common/types */ "../../packages/plugin-ext/lib/common/types.js");
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
class TelemetryExtImpl {
    constructor() {
        this._isTelemetryEnabled = false; // telemetry not activated by default
        this.onDidChangeTelemetryEnabledEmitter = new event_1.Emitter();
        this.onDidChangeTelemetryEnabled = this.onDidChangeTelemetryEnabledEmitter.event;
    }
    get isTelemetryEnabled() {
        return this._isTelemetryEnabled;
    }
    set isTelemetryEnabled(isTelemetryEnabled) {
        if (this._isTelemetryEnabled !== isTelemetryEnabled) {
            this._isTelemetryEnabled = isTelemetryEnabled;
            this.onDidChangeTelemetryEnabledEmitter.fire(this._isTelemetryEnabled);
        }
    }
    createTelemetryLogger(sender, options) {
        const logger = new TelemetryLogger(sender, this._isTelemetryEnabled, options);
        this.onDidChangeTelemetryEnabled(isEnabled => {
            logger.telemetryEnabled = isEnabled;
        });
        return logger;
    }
}
exports.TelemetryExtImpl = TelemetryExtImpl;
class TelemetryLogger {
    constructor(sender, telemetryEnabled, options) {
        this.onDidChangeEnableStatesEmitter = new event_1.Emitter();
        this.onDidChangeEnableStates = this.onDidChangeEnableStatesEmitter.event;
        this.sender = sender;
        this.options = options;
        this.commonProperties = this.getCommonProperties();
        this._isErrorsEnabled = true;
        this._isUsageEnabled = true;
        this.telemetryEnabled = telemetryEnabled;
    }
    get isUsageEnabled() {
        return this._isUsageEnabled;
    }
    set isUsageEnabled(isUsageEnabled) {
        if (this._isUsageEnabled !== isUsageEnabled) {
            this._isUsageEnabled = isUsageEnabled;
            this.onDidChangeEnableStatesEmitter.fire(this);
        }
    }
    get isErrorsEnabled() {
        return this._isErrorsEnabled;
    }
    set isErrorsEnabled(isErrorsEnabled) {
        if (this._isErrorsEnabled !== isErrorsEnabled) {
            this._isErrorsEnabled = isErrorsEnabled;
            this.onDidChangeEnableStatesEmitter.fire(this);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    logUsage(eventName, data) {
        if (!this.telemetryEnabled || !this.isUsageEnabled) {
            return;
        }
        this.logEvent(eventName, data);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    logError(eventNameOrException, data) {
        if (!this.telemetryEnabled || !this.isErrorsEnabled || !this.sender) {
            // no sender available or error shall not be sent
            return;
        }
        if (typeof eventNameOrException === 'string') {
            this.logEvent(eventNameOrException, data);
        }
        else {
            this.sender.sendErrorData(eventNameOrException, data);
        }
    }
    dispose() {
        var _a;
        if ((_a = this.sender) === null || _a === void 0 ? void 0 : _a.flush) {
            let tempSender = this.sender;
            this.sender = undefined;
            Promise.resolve(tempSender.flush()).then(tempSender = undefined);
        }
        else {
            this.sender = undefined;
        }
    }
    ;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    logEvent(eventName, data) {
        var _a, _b, _c;
        // No sender means likely disposed of, we should no-op
        if (!this.sender) {
            return;
        }
        data = mixInCommonPropsAndCleanData(data || {}, (_a = this.options) === null || _a === void 0 ? void 0 : _a.additionalCommonProperties, ((_b = this.options) === null || _b === void 0 ? void 0 : _b.ignoreBuiltInCommonProperties) ? undefined : this.commonProperties);
        (_c = this.sender) === null || _c === void 0 ? void 0 : _c.sendEventData(eventName, data);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getCommonProperties() {
        return [];
    }
}
exports.TelemetryLogger = TelemetryLogger;
// copied and modified from https://github.com/microsoft/vscode/blob/1.76.0/src/vs/workbench/api/common/extHostTelemetry.ts
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function mixInCommonPropsAndCleanData(data, additionalProperties, commonProperties) {
    var _a;
    let updatedData = (_a = data.properties) !== null && _a !== void 0 ? _a : data;
    // We don't clean measurements since they are just numbers
    updatedData = cleanData(updatedData, []);
    if (additionalProperties) {
        updatedData = (0, types_1.mixin)(updatedData, additionalProperties);
    }
    if (commonProperties) {
        updatedData = (0, types_1.mixin)(updatedData, commonProperties);
    }
    if (data.properties) {
        data.properties = updatedData;
    }
    else {
        data = updatedData;
    }
    return data;
}
// copied and modified from https://github.com/microsoft/vscode/blob/1.76.0/src/vs/platform/telemetry/common/telemetryUtils.ts#L321-L442
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * Cleans a given stack of possible paths
 * @param stack The stack to sanitize
 * @param cleanupPatterns Cleanup patterns to remove from the stack
 * @returns The cleaned stack
 */
function anonymizeFilePaths(stack, cleanupPatterns) {
    // Fast check to see if it is a file path to avoid doing unnecessary heavy regex work
    if (!stack || (!stack.includes('/') && !stack.includes('\\'))) {
        return stack;
    }
    let updatedStack = stack;
    const cleanUpIndexes = [];
    for (const regexp of cleanupPatterns) {
        while (true) {
            const result = regexp.exec(stack);
            if (!result) {
                break;
            }
            cleanUpIndexes.push([result.index, regexp.lastIndex]);
        }
    }
    const nodeModulesRegex = /^[\\\/]?(node_modules|node_modules\.asar)[\\\/]/;
    const fileRegex = /(file:\/\/)?([a-zA-Z]:(\\\\|\\|\/)|(\\\\|\\|\/))?([\w-\._]+(\\\\|\\|\/))+[\w-\._]*/g;
    let lastIndex = 0;
    updatedStack = '';
    while (true) {
        const result = fileRegex.exec(stack);
        if (!result) {
            break;
        }
        // Check to see if the any cleanupIndexes partially overlap with this match
        const overlappingRange = cleanUpIndexes.some(([start, end]) => result.index < end && start < fileRegex.lastIndex);
        // anonymize user file paths that do not need to be retained or cleaned up.
        if (!nodeModulesRegex.test(result[0]) && !overlappingRange) {
            updatedStack += stack.substring(lastIndex, result.index) + '<REDACTED: user-file-path>';
            lastIndex = fileRegex.lastIndex;
        }
    }
    if (lastIndex < stack.length) {
        updatedStack += stack.substring(lastIndex);
    }
    return updatedStack;
}
/**
 * Attempts to remove commonly leaked PII
 * @param property The property which will be removed if it contains user data
 * @returns The new value for the property
 */
function removePropertiesWithPossibleUserInfo(property) {
    // If for some reason it is undefined we skip it (this shouldn't be possible);
    if (!property) {
        return property;
    }
    const value = property.toLowerCase();
    const userDataRegexes = [
        { label: 'Google API Key', regex: /AIza[0-9A-Za-z-_]{35}/ },
        { label: 'Slack Token', regex: /xox[pbar]\-[A-Za-z0-9]/ },
        { label: 'Generic Secret', regex: /(key|token|sig|secret|signature|password|passwd|pwd|android:value)[^a-zA-Z0-9]/ },
        { label: 'Email', regex: /@[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+/ } // Regex which matches @*.site
    ];
    // Check for common user data in the telemetry events
    for (const secretRegex of userDataRegexes) {
        if (secretRegex.regex.test(value)) {
            return `<REDACTED: ${secretRegex.label}>`;
        }
    }
    return property;
}
/**
 * Does a best possible effort to clean a data object from any possible PII.
 * @param data The data object to clean
 * @param paths Any additional patterns that should be removed from the data set
 * @returns A new object with the PII removed
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function cleanData(data, cleanUpPatterns) {
    return (0, core_1.cloneAndChange)(data, value => {
        // If it's a trusted value it means it's okay to skip cleaning so we don't clean it
        if (value instanceof types_impl_1.TelemetryTrustedValue) {
            return value.value;
        }
        // We only know how to clean strings
        if (typeof value === 'string') {
            let updatedProperty = value.replace(/%20/g, ' ');
            // First we anonymize any possible file paths
            updatedProperty = anonymizeFilePaths(updatedProperty, cleanUpPatterns);
            // Then we do a simple regex replace with the defined patterns
            for (const regexp of cleanUpPatterns) {
                updatedProperty = updatedProperty.replace(regexp, '');
            }
            // Lastly, remove commonly leaked PII
            updatedProperty = removePropertiesWithPossibleUserInfo(updatedProperty);
            return updatedProperty;
        }
        return undefined;
    }, new Set());
}
exports.cleanData = cleanData;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/terminal-ext.js":
/*!************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/terminal-ext.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PseudoTerminal = exports.TerminalExtImpl = exports.EnvironmentVariableCollection = exports.TerminalServiceExtImpl = exports.getIconClass = exports.getIconUris = void 0;
// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
const coreutils_1 = __webpack_require__(/*! @theia/core/shared/@phosphor/coreutils */ "../../packages/core/shared/@phosphor/coreutils/index.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../packages/core/lib/common/event.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../../packages/core/lib/common/promise-util.js");
const Converter = __webpack_require__(/*! ./type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const themeService_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/platform/theme/common/themeService */ "../../node_modules/@theia/monaco-editor-core/esm/vs/platform/theme/common/themeService.js");
function getIconUris(iconPath) {
    if (types_impl_1.ThemeIcon.is(iconPath)) {
        return { id: iconPath.id };
    }
    return undefined;
}
exports.getIconUris = getIconUris;
function getIconClass(options) {
    const iconClass = getIconUris(options.iconPath);
    if (iconClass) {
        return themeService_1.ThemeIcon.asClassName(iconClass);
    }
    return undefined;
}
exports.getIconClass = getIconClass;
/**
 * Provides high level terminal plugin api to use in the Theia plugins.
 * This service allow(with help proxy) create and use terminal emulator.
 */
class TerminalServiceExtImpl {
    constructor(rpc) {
        this._terminals = new Map();
        this._pseudoTerminals = new Map();
        this.terminalLinkProviders = new Map();
        this.terminalProfileProviders = new Map();
        this.onDidCloseTerminalEmitter = new event_1.Emitter();
        this.onDidCloseTerminal = this.onDidCloseTerminalEmitter.event;
        this.onDidOpenTerminalEmitter = new event_1.Emitter();
        this.onDidOpenTerminal = this.onDidOpenTerminalEmitter.event;
        this.onDidChangeActiveTerminalEmitter = new event_1.Emitter();
        this.onDidChangeActiveTerminal = this.onDidChangeActiveTerminalEmitter.event;
        this.onDidChangeTerminalStateEmitter = new event_1.Emitter();
        this.onDidChangeTerminalState = this.onDidChangeTerminalStateEmitter.event;
        this.environmentVariableCollections = new Map();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.TERMINAL_MAIN);
    }
    get terminals() {
        return [...this._terminals.values()];
    }
    createTerminal(nameOrOptions, shellPath, shellArgs) {
        const id = `plugin-terminal-${coreutils_1.UUID.uuid4()}`;
        let options;
        let pseudoTerminal = undefined;
        if (typeof nameOrOptions === 'object') {
            if ('pty' in nameOrOptions) {
                pseudoTerminal = nameOrOptions.pty;
                options = {
                    name: nameOrOptions.name,
                };
                this._pseudoTerminals.set(id, new PseudoTerminal(id, this.proxy, pseudoTerminal));
            }
            else {
                options = nameOrOptions;
            }
        }
        else {
            options = {
                name: nameOrOptions,
                shellPath: shellPath,
                shellArgs: shellArgs
            };
        }
        let parentId;
        if (options.location && typeof options.location === 'object' && 'parentTerminal' in options.location) {
            const parentTerminal = options.location.parentTerminal;
            if (parentTerminal instanceof TerminalExtImpl) {
                for (const [k, v] of this._terminals) {
                    if (v === parentTerminal) {
                        parentId = k;
                        break;
                    }
                }
            }
        }
        this.proxy.$createTerminal(id, options, parentId, !!pseudoTerminal);
        let creationOptions = options;
        // make sure to pass ExtensionTerminalOptions as creation options
        if (typeof nameOrOptions === 'object' && 'pty' in nameOrOptions) {
            creationOptions = nameOrOptions;
        }
        return this.obtainTerminal(id, options.name || 'Terminal', creationOptions);
    }
    attachPtyToTerminal(terminalId, pty) {
        this._pseudoTerminals.set(terminalId.toString(), new PseudoTerminal(terminalId, this.proxy, pty, true));
    }
    obtainTerminal(id, name, options) {
        let terminal = this._terminals.get(id);
        if (!terminal) {
            terminal = new TerminalExtImpl(this.proxy, options !== null && options !== void 0 ? options : {});
            this._terminals.set(id, terminal);
        }
        terminal.name = name;
        return terminal;
    }
    $terminalOnInput(id, data) {
        const terminal = this._pseudoTerminals.get(id);
        if (!terminal) {
            return;
        }
        terminal.emitOnInput(data);
    }
    $terminalStateChanged(id) {
        const terminal = this._terminals.get(id);
        if (!terminal) {
            return;
        }
        if (!terminal.state.isInteractedWith) {
            terminal.state = { isInteractedWith: true };
            this.onDidChangeTerminalStateEmitter.fire(terminal);
        }
    }
    $terminalSizeChanged(id, clos, rows) {
        const terminal = this._pseudoTerminals.get(id);
        if (!terminal) {
            return;
        }
        terminal.emitOnResize(clos, rows);
    }
    $terminalCreated(id, name) {
        const terminal = this.obtainTerminal(id, name);
        terminal.id.resolve(id);
        this.onDidOpenTerminalEmitter.fire(terminal);
    }
    $terminalNameChanged(id, name) {
        const terminal = this._terminals.get(id);
        if (terminal) {
            terminal.name = name;
        }
    }
    $terminalOpened(id, processId, terminalId, cols, rows) {
        const terminal = this._terminals.get(id);
        if (terminal) {
            // resolve for existing clients
            terminal.deferredProcessId.resolve(processId);
            // install new if terminal is reconnected
            terminal.deferredProcessId = new promise_util_1.Deferred();
            terminal.deferredProcessId.resolve(processId);
        }
        // Switch the pseudoterminal keyed by terminalId to be keyed by terminal ID
        const tId = terminalId.toString();
        if (this._pseudoTerminals.has(tId)) {
            const pseudo = this._pseudoTerminals.get(tId);
            if (pseudo) {
                this._pseudoTerminals.set(id, pseudo);
            }
            this._pseudoTerminals.delete(tId);
        }
        const pseudoTerminal = this._pseudoTerminals.get(id);
        if (pseudoTerminal) {
            pseudoTerminal.emitOnOpen(cols, rows);
        }
    }
    $terminalClosed(id, exitStatus) {
        const terminal = this._terminals.get(id);
        if (terminal) {
            terminal.exitStatus = exitStatus !== null && exitStatus !== void 0 ? exitStatus : { code: undefined, reason: types_impl_1.TerminalExitReason.Unknown };
            this.onDidCloseTerminalEmitter.fire(terminal);
            this._terminals.delete(id);
        }
        const pseudoTerminal = this._pseudoTerminals.get(id);
        if (pseudoTerminal) {
            pseudoTerminal.emitOnClose();
            this._pseudoTerminals.delete(id);
        }
    }
    get activeTerminal() {
        return this.activeTerminalId && this._terminals.get(this.activeTerminalId) || undefined;
    }
    $currentTerminalChanged(id) {
        this.activeTerminalId = id;
        this.onDidChangeActiveTerminalEmitter.fire(this.activeTerminal);
    }
    registerTerminalLinkProvider(provider) {
        const providerId = (TerminalServiceExtImpl.nextProviderId++).toString();
        this.terminalLinkProviders.set(providerId, provider);
        this.proxy.$registerTerminalLinkProvider(providerId);
        return types_impl_1.Disposable.create(() => {
            this.proxy.$unregisterTerminalLinkProvider(providerId);
            this.terminalLinkProviders.delete(providerId);
        });
    }
    registerTerminalProfileProvider(id, provider) {
        this.terminalProfileProviders.set(id, provider);
        return types_impl_1.Disposable.create(() => {
            this.terminalProfileProviders.delete(id);
        });
    }
    /** @stubbed */
    registerTerminalQuickFixProvider(id, provider) {
        return types_impl_1.Disposable.NULL;
    }
    isExtensionTerminalOptions(options) {
        return 'pty' in options;
    }
    async $startProfile(profileId, cancellationToken) {
        const provider = this.terminalProfileProviders.get(profileId);
        if (!provider) {
            throw new Error(`No terminal profile provider with id '${profileId}'`);
        }
        const profile = await provider.provideTerminalProfile(cancellationToken);
        if (!profile) {
            throw new Error(`Profile with id ${profileId} could not be created`);
        }
        const id = `plugin-terminal-${coreutils_1.UUID.uuid4()}`;
        const options = profile.options;
        if (this.isExtensionTerminalOptions(options)) {
            this._pseudoTerminals.set(id, new PseudoTerminal(id, this.proxy, options.pty));
            return this.proxy.$createTerminal(id, { name: options.name }, undefined, true);
        }
        else {
            return this.proxy.$createTerminal(id, profile.options);
        }
    }
    async $provideTerminalLinks(line, terminalId, token) {
        const links = [];
        const terminal = this._terminals.get(terminalId);
        if (terminal) {
            for (const [providerId, provider] of this.terminalLinkProviders) {
                const providedLinks = await provider.provideTerminalLinks({ line, terminal }, token);
                if (providedLinks) {
                    links.push(...providedLinks.map(link => ({ ...link, providerId })));
                }
            }
        }
        return links;
    }
    async $handleTerminalLink(link) {
        const provider = this.terminalLinkProviders.get(link.providerId);
        if (!provider) {
            throw Error('Terminal link provider not found');
        }
        await provider.handleTerminalLink(link);
    }
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    // some code copied and modified from https://github.com/microsoft/vscode/blob/1.49.0/src/vs/workbench/api/common/extHostTerminalService.ts
    getEnvironmentVariableCollection(extensionIdentifier) {
        let collection = this.environmentVariableCollections.get(extensionIdentifier);
        if (!collection) {
            collection = new EnvironmentVariableCollection();
            this.setEnvironmentVariableCollection(extensionIdentifier, collection);
        }
        return collection;
    }
    syncEnvironmentVariableCollection(extensionIdentifier, collection) {
        const serialized = [...collection.map.entries()];
        this.proxy.$setEnvironmentVariableCollection(collection.persistent, {
            extensionIdentifier,
            collection: serialized.length === 0 ? undefined : serialized,
            description: Converter.fromMarkdownOrString(collection.description)
        });
    }
    setEnvironmentVariableCollection(extensionIdentifier, collection) {
        this.environmentVariableCollections.set(extensionIdentifier, collection);
        collection.onDidChangeCollection(() => {
            // When any collection value changes send this immediately, this is done to ensure
            // following calls to createTerminal will be created with the new environment. It will
            // result in more noise by sending multiple updates when called but collections are
            // expected to be small.
            this.syncEnvironmentVariableCollection(extensionIdentifier, collection);
        });
    }
    $initEnvironmentVariableCollections(collections) {
        collections.forEach(entry => {
            const extensionIdentifier = entry[0];
            const collection = new EnvironmentVariableCollection(entry[1]);
            this.setEnvironmentVariableCollection(extensionIdentifier, collection);
        });
    }
}
exports.TerminalServiceExtImpl = TerminalServiceExtImpl;
TerminalServiceExtImpl.nextProviderId = 0;
class EnvironmentVariableCollection {
    constructor(serialized) {
        this.map = new Map();
        this._persistent = true;
        this.onDidChangeCollectionEmitter = new event_1.Emitter();
        this.onDidChangeCollection = this.onDidChangeCollectionEmitter.event;
        this.map = new Map(serialized);
    }
    get description() { return this._description; }
    set description(value) {
        this._description = value;
        this.onDidChangeCollectionEmitter.fire();
    }
    get persistent() { return this._persistent; }
    set persistent(value) {
        this._persistent = value;
        this.onDidChangeCollectionEmitter.fire();
    }
    get size() {
        return this.map.size;
    }
    replace(variable, value) {
        this._setIfDiffers(variable, { value, type: types_impl_1.EnvironmentVariableMutatorType.Replace });
    }
    append(variable, value) {
        this._setIfDiffers(variable, { value, type: types_impl_1.EnvironmentVariableMutatorType.Append });
    }
    prepend(variable, value) {
        this._setIfDiffers(variable, { value, type: types_impl_1.EnvironmentVariableMutatorType.Prepend });
    }
    _setIfDiffers(variable, mutator) {
        const current = this.map.get(variable);
        if (!current || current.value !== mutator.value || current.type !== mutator.type) {
            this.map.set(variable, mutator);
            this.onDidChangeCollectionEmitter.fire();
        }
    }
    get(variable) {
        return this.map.get(variable);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    forEach(callback, thisArg) {
        this.map.forEach((value, key) => callback.call(thisArg, key, value, this));
    }
    delete(variable) {
        this.map.delete(variable);
        this.onDidChangeCollectionEmitter.fire();
    }
    clear() {
        this.map.clear();
        this.onDidChangeCollectionEmitter.fire();
    }
}
exports.EnvironmentVariableCollection = EnvironmentVariableCollection;
class TerminalExtImpl {
    constructor(proxy, options) {
        this.proxy = proxy;
        this.options = options;
        this.id = new promise_util_1.Deferred();
        this.deferredProcessId = new promise_util_1.Deferred();
        this.state = { isInteractedWith: false };
        this.creationOptions = this.options;
    }
    get processId() {
        return this.deferredProcessId.promise;
    }
    sendText(text, addNewLine = true) {
        this.id.promise.then(id => this.proxy.$sendText(id, text, addNewLine));
    }
    show(preserveFocus) {
        this.id.promise.then(id => this.proxy.$show(id, preserveFocus));
    }
    hide() {
        this.id.promise.then(id => this.proxy.$hide(id));
    }
    dispose() {
        this.id.promise.then(id => this.proxy.$dispose(id));
    }
}
exports.TerminalExtImpl = TerminalExtImpl;
class PseudoTerminal {
    constructor(id, proxy, pseudoTerminal, waitOnExit) {
        this.proxy = proxy;
        this.pseudoTerminal = pseudoTerminal;
        pseudoTerminal.onDidWrite(data => {
            if (typeof id === 'string') {
                this.proxy.$write(id, data);
            }
            else {
                this.proxy.$writeByTerminalId(id, data);
            }
        });
        if (pseudoTerminal.onDidClose) {
            pseudoTerminal.onDidClose((e = undefined) => {
                if (typeof id === 'string') {
                    this.proxy.$dispose(id);
                }
                else {
                    this.proxy.$disposeByTerminalId(id, waitOnExit);
                }
            });
        }
        if (pseudoTerminal.onDidOverrideDimensions) {
            pseudoTerminal.onDidOverrideDimensions(e => {
                if (e) {
                    if (typeof id === 'string') {
                        this.proxy.$resize(id, e.columns, e.rows);
                    }
                    else {
                        this.proxy.$resizeByTerminalId(id, e.columns, e.rows);
                    }
                }
            });
        }
        if (pseudoTerminal.onDidChangeName) {
            pseudoTerminal.onDidChangeName(name => {
                if (typeof id === 'string') {
                    this.proxy.$setName(id, name);
                }
                else {
                    this.proxy.$setNameByTerminalId(id, name);
                }
            });
        }
    }
    emitOnClose() {
        this.pseudoTerminal.close();
    }
    emitOnInput(data) {
        if (this.pseudoTerminal.handleInput) {
            this.pseudoTerminal.handleInput(data);
        }
    }
    emitOnOpen(cols, rows) {
        this.pseudoTerminal.open({
            rows,
            columns: cols,
        });
    }
    emitOnResize(cols, rows) {
        if (this.pseudoTerminal.setDimensions) {
            this.pseudoTerminal.setDimensions({ columns: cols, rows });
        }
    }
}
exports.PseudoTerminal = PseudoTerminal;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/text-editor.js":
/*!***********************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/text-editor.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextEditorEdit = exports.TextEditorOptionsExt = exports.TextEditorExt = void 0;
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const errors_1 = __webpack_require__(/*! ../common/errors */ "../../packages/plugin-ext/lib/common/errors.js");
const assert_1 = __webpack_require__(/*! ../common/assert */ "../../packages/plugin-ext/lib/common/assert.js");
const Converter = __webpack_require__(/*! ./type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
class TextEditorExt {
    constructor(proxy, id, document, _selections, options, _visibleRanges, viewColumn) {
        this.proxy = proxy;
        this.id = id;
        this._selections = _selections;
        this._visibleRanges = _visibleRanges;
        this.disposed = false;
        this._options = new TextEditorOptionsExt(proxy, id, options);
        this._viewColumn = viewColumn;
        this._document = document;
    }
    get document() {
        return this._document.document;
    }
    set document(doc) {
        throw (0, errors_1.readonly)('Document');
    }
    acceptViewColumn(val) {
        this._viewColumn = val;
    }
    dispose() {
        this.disposed = true;
    }
    get options() {
        return this._options;
    }
    set options(val) {
        if (!this.disposed) {
            this._options.assign(val);
        }
    }
    acceptOptions(options) {
        (0, assert_1.ok)(!this.disposed);
        this._options.accept(options);
    }
    get selection() {
        return this._selections && this._selections[0];
    }
    set selection(val) {
        if (!(val instanceof types_impl_1.Selection)) {
            throw (0, errors_1.illegalArgument)('selection');
        }
        this._selections = [val];
        this.trySetSelection();
    }
    trySetSelection() {
        const selection = this._selections.map(Converter.fromSelection);
        return this.runOnProxy(() => this.proxy.$trySetSelections(this.id, selection));
    }
    get selections() {
        return this._selections;
    }
    set selections(val) {
        if (!Array.isArray(val) || val.some(s => !(s instanceof types_impl_1.Selection))) {
            throw (0, errors_1.illegalArgument)('selections');
        }
        this._selections = val;
        this.trySetSelection();
    }
    acceptSelections(selections) {
        (0, assert_1.ok)(!this.disposed);
        this._selections = selections;
    }
    get visibleRanges() {
        return this._visibleRanges;
    }
    set visibleRanges(val) {
        throw (0, errors_1.readonly)('visibleRanges');
    }
    acceptVisibleRanges(range) {
        (0, assert_1.ok)(!this.disposed);
        this._visibleRanges = range;
    }
    get viewColumn() {
        return this._viewColumn;
    }
    set viewColumn(value) {
        throw (0, errors_1.readonly)('viewColumn');
    }
    _acceptViewColumn(value) {
        (0, assert_1.ok)(!this.disposed);
        this._viewColumn = value;
    }
    // eslint-disable-next-line max-len
    edit(callback, options = { undoStopBefore: true, undoStopAfter: true }) {
        if (this.disposed) {
            return Promise.reject(new Error('TextEditor#edit not possible on closed editor'));
        }
        const edit = new TextEditorEdit(this._document.document, options);
        callback(edit);
        return this.applyEdit(edit);
    }
    // eslint-disable-next-line max-len
    insertSnippet(snippet, location, options = { undoStopBefore: true, undoStopAfter: true }) {
        if (this.disposed) {
            return Promise.reject(new Error('TextEditor#insertSnippet not possible on closed editors'));
        }
        let ranges;
        if (!location || (Array.isArray(location) && location.length === 0)) {
            ranges = this._selections.map(s => Converter.fromRange(s));
        }
        else if (location instanceof types_impl_1.Position) {
            const { lineNumber, column } = Converter.fromPosition(location);
            ranges = [{ startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn: column }];
        }
        else if (location instanceof types_impl_1.Range) {
            ranges = [Converter.fromRange(location)];
        }
        else {
            ranges = [];
            for (const posOrRange of location) {
                if (posOrRange instanceof types_impl_1.Range) {
                    ranges.push(Converter.fromRange(posOrRange));
                }
                else {
                    const { lineNumber, column } = Converter.fromPosition(posOrRange);
                    ranges.push({ startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn: column });
                }
            }
        }
        return this.proxy.$tryInsertSnippet(this.id, snippet.value, ranges, options);
    }
    setDecorations(decorationType, rangesOrOptions) {
        this.runOnProxy(() => {
            if (Converter.isDecorationOptionsArr(rangesOrOptions)) {
                return this.proxy.$trySetDecorations(this.id, decorationType.key, Converter.fromRangeOrRangeWithMessage(rangesOrOptions));
            }
            else {
                const ranges = new Array(4 * rangesOrOptions.length);
                const len = rangesOrOptions.length;
                for (let i = 0; i < len; i++) {
                    const range = rangesOrOptions[i];
                    ranges[4 * i] = range.start.line + 1;
                    ranges[4 * i + 1] = range.start.character + 1;
                    ranges[4 * i + 2] = range.end.line + 1;
                    ranges[4 * i + 3] = range.end.character + 1;
                }
                return this.proxy.$trySetDecorationsFast(this.id, decorationType.key, ranges);
            }
        });
    }
    revealRange(range, revealType) {
        this.runOnProxy(() => this.proxy.$tryRevealRange(this.id, Converter.fromRange(range), (revealType || types_impl_1.TextEditorRevealType.Default)));
    }
    applyEdit(edit) {
        const editData = edit.finalize();
        const editRanges = editData.edits.map(e => e.range);
        editRanges.sort((a, b) => {
            if (a.end.line === b.end.line) {
                if (a.end.character === b.end.character) {
                    if (a.start.line === b.start.line) {
                        return a.start.character - b.start.character;
                    }
                    return a.start.line - b.start.line;
                }
                return a.end.character - b.end.character;
            }
            return a.end.line - b.end.line;
        });
        const count = editRanges.length - 1;
        for (let i = 0; i < count; i++) {
            const rangeEnd = editRanges[i].end;
            const nextRangeStart = editRanges[i + 1].start;
            if (nextRangeStart.isBefore(rangeEnd)) {
                return Promise.reject(new Error('Overlapping ranges are not allowed!'));
            }
        }
        // prepare data for serialization
        const edits = editData.edits.map(e => ({
            range: Converter.fromRange(e.range),
            text: e.text,
            forceMoveMarkers: e.forceMoveMarkers
        }));
        return this.proxy.$tryApplyEdits(this.id, editData.documentVersionId, edits, {
            setEndOfLine: editData.setEndOfLine,
            undoStopBefore: editData.undoStopBefore,
            undoStopAfter: editData.undoStopAfter
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    runOnProxy(callback) {
        if (this.disposed) {
            console.warn('TextEditor is disposed!');
            return Promise.resolve(undefined);
        }
        return callback().then(() => this, err => {
            if (!(err instanceof Error && err.name === 'DISPOSED')) {
                console.warn(err);
            }
            return undefined;
        });
    }
    show(column) {
        this.proxy.$tryShowTextDocument(this.document.uri, {
            viewColumn: column,
            preview: true,
        });
    }
    hide() {
        this.proxy.$tryHideEditor(this.id);
    }
}
exports.TextEditorExt = TextEditorExt;
class TextEditorOptionsExt {
    constructor(proxy, id, source) {
        this.proxy = proxy;
        this.id = id;
        this.accept(source);
    }
    accept(source) {
        this._tabSize = source.tabSize;
        this._insertSpace = source.insertSpaces;
        this._cursorStyle = source.cursorStyle;
        this._lineNumbers = source.lineNumbers;
    }
    get tabSize() {
        return this._tabSize;
    }
    set tabSize(val) {
        const tabSize = this.validateTabSize(val);
        if (!tabSize) {
            return; // ignore invalid values
        }
        if (typeof tabSize === 'number') {
            if (this.tabSize === tabSize) {
                return;
            }
            this.tabSize = tabSize;
        }
        warnOnError(this.proxy.$trySetOptions(this.id, {
            tabSize
        }));
    }
    validateTabSize(val) {
        if (val === 'auto') {
            return 'auto';
        }
        if (typeof val === 'number') {
            const r = Math.floor(val);
            return r > 0 ? r : undefined;
        }
        if (typeof val === 'string') {
            const r = parseInt(val, undefined);
            if (isNaN(r)) {
                return undefined;
            }
            return r > 0 ? r : undefined;
        }
        return undefined;
    }
    get insertSpaces() {
        return this._insertSpace;
    }
    set insertSpaces(val) {
        const insertSpaces = this.validateInsertSpaces(val);
        if (typeof insertSpaces === 'boolean') {
            if (this._insertSpace === insertSpaces) {
                return;
            }
            this._insertSpace = insertSpaces;
        }
        warnOnError(this.proxy.$trySetOptions(this.id, { insertSpaces }));
    }
    validateInsertSpaces(val) {
        if (val === 'auto') {
            return 'auto';
        }
        return val === 'false' ? false : Boolean(val);
    }
    get cursorStyle() {
        return this._cursorStyle;
    }
    set cursorStyle(val) {
        if (this._cursorStyle === val) {
            return;
        }
        this._cursorStyle = val;
        warnOnError(this.proxy.$trySetOptions(this.id, { cursorStyle: val }));
    }
    get lineNumbers() {
        return this._lineNumbers;
    }
    set lineNumbers(val) {
        if (this._lineNumbers === val) {
            return;
        }
        this._lineNumbers = val;
        warnOnError(this.proxy.$trySetOptions(this.id, { lineNumbers: val }));
    }
    assign(newOptions) {
        const configurationUpdate = {};
        let hasUpdate = false;
        if (typeof newOptions.tabSize !== 'undefined') {
            const tabSize = this.validateTabSize(newOptions.tabSize);
            if (tabSize === 'auto') {
                hasUpdate = true;
                configurationUpdate.tabSize = tabSize;
            }
            else if (typeof tabSize === 'number' && this._tabSize !== tabSize) {
                this._tabSize = tabSize;
                hasUpdate = true;
                configurationUpdate.tabSize = tabSize;
            }
        }
        if (typeof newOptions.insertSpaces !== 'undefined') {
            const insertSpaces = this.validateInsertSpaces(newOptions.insertSpaces);
            if (insertSpaces === 'auto') {
                hasUpdate = true;
                configurationUpdate.insertSpaces = insertSpaces;
            }
            else if (this.insertSpaces !== insertSpaces) {
                this.insertSpaces = insertSpaces;
                hasUpdate = true;
                configurationUpdate.insertSpaces = insertSpaces;
            }
        }
        if (typeof newOptions.cursorStyle !== 'undefined') {
            if (this._cursorStyle !== newOptions.cursorStyle) {
                this._cursorStyle = newOptions.cursorStyle;
                hasUpdate = true;
                configurationUpdate.cursorStyle = newOptions.cursorStyle;
            }
        }
        if (typeof newOptions.lineNumbers !== 'undefined') {
            if (this._lineNumbers !== newOptions.lineNumbers) {
                this._lineNumbers = newOptions.lineNumbers;
                hasUpdate = true;
                configurationUpdate.lineNumbers = newOptions.lineNumbers;
            }
        }
        if (hasUpdate) {
            warnOnError(this.proxy.$trySetOptions(this.id, configurationUpdate));
        }
    }
}
exports.TextEditorOptionsExt = TextEditorOptionsExt;
class TextEditorEdit {
    constructor(document, options) {
        this.document = document;
        this.documentVersionId = document.version;
        this.collectedEdits = [];
        this.eol = 0;
        this.undoStopBefore = options.undoStopBefore;
        this.undoStopAfter = options.undoStopAfter;
    }
    finalize() {
        return {
            documentVersionId: this.documentVersionId,
            edits: this.collectedEdits,
            setEndOfLine: this.eol,
            undoStopAfter: this.undoStopAfter,
            undoStopBefore: this.undoStopBefore
        };
    }
    replace(location, val) {
        let range;
        if (location instanceof types_impl_1.Position) {
            range = new types_impl_1.Range(location, location);
        }
        else if (location instanceof types_impl_1.Range) {
            range = location;
        }
        else {
            throw new Error('Unknown location');
        }
        this.addEdit(range, val, false);
    }
    insert(location, val) {
        this.addEdit(new types_impl_1.Range(location, location), val, true);
    }
    delete(location) {
        let range;
        if (location instanceof types_impl_1.Range) {
            range = location;
        }
        else {
            throw new Error('Unknown location');
        }
        this.addEdit(range, undefined, true);
    }
    setEndOfLine(endOfLine) {
        if (endOfLine !== types_impl_1.EndOfLine.CRLF && endOfLine !== types_impl_1.EndOfLine.LF) {
            throw (0, errors_1.illegalArgument)('endOfLine');
        }
        this.eol = endOfLine;
    }
    addEdit(range, text, moveMarkers) {
        const validatedRange = this.document.validateRange(range);
        this.collectedEdits.push({
            range: validatedRange,
            forceMoveMarkers: moveMarkers,
            text: text
        });
    }
}
exports.TextEditorEdit = TextEditorEdit;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function warnOnError(promise) {
    promise.then(undefined, err => {
        console.warn(err);
    });
}


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/text-editors.js":
/*!************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/text-editors.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextEditorDecorationType = exports.TextEditorsExtImpl = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../packages/core/lib/common/event.js");
const Converters = __webpack_require__(/*! ./type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const id_generator_1 = __webpack_require__(/*! ../common/id-generator */ "../../packages/plugin-ext/lib/common/id-generator.js");
class TextEditorsExtImpl {
    constructor(rpc, editorsAndDocuments) {
        this.editorsAndDocuments = editorsAndDocuments;
        this._onDidChangeTextEditorSelection = new event_1.Emitter();
        this._onDidChangeTextEditorOptions = new event_1.Emitter();
        this._onDidChangeTextEditorVisibleRanges = new event_1.Emitter();
        this._onDidChangeTextEditorViewColumn = new event_1.Emitter();
        this._onDidChangeActiveTextEditor = new event_1.Emitter();
        this._onDidChangeVisibleTextEditors = new event_1.Emitter();
        this.onDidChangeTextEditorSelection = this._onDidChangeTextEditorSelection.event;
        this.onDidChangeTextEditorOptions = this._onDidChangeTextEditorOptions.event;
        this.onDidChangeTextEditorVisibleRanges = this._onDidChangeTextEditorVisibleRanges.event;
        this.onDidChangeTextEditorViewColumn = this._onDidChangeTextEditorViewColumn.event;
        this.onDidChangeActiveTextEditor = this._onDidChangeActiveTextEditor.event;
        this.onDidChangeVisibleTextEditors = this._onDidChangeVisibleTextEditors.event;
        this.proxy = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.TEXT_EDITORS_MAIN);
        this.editorsAndDocuments.onDidChangeActiveTextEditor(e => this._onDidChangeActiveTextEditor.fire(e));
        this.editorsAndDocuments.onDidChangeVisibleTextEditors(e => this._onDidChangeVisibleTextEditors.fire(e));
    }
    $acceptEditorPropertiesChanged(id, props) {
        const textEditor = this.editorsAndDocuments.getEditor(id);
        if (!textEditor) {
            return;
        }
        if (props.options) {
            textEditor.acceptOptions(props.options);
        }
        if (props.selections) {
            const selections = props.selections.selections.map(Converters.toSelection);
            textEditor.acceptSelections(selections);
        }
        if (props.visibleRanges) {
            const visibleRanges = props.visibleRanges.map(Converters.toRange);
            textEditor.acceptVisibleRanges(visibleRanges);
        }
        if (props.options) {
            this._onDidChangeTextEditorOptions.fire({
                textEditor,
                options: props.options
            });
        }
        if (props.selections) {
            const kind = types_impl_1.TextEditorSelectionChangeKind.fromValue(props.selections.source);
            const selections = props.selections.selections.map(Converters.toSelection);
            this._onDidChangeTextEditorSelection.fire({
                textEditor,
                selections,
                kind
            });
        }
        if (props.visibleRanges) {
            const visibleRanges = props.visibleRanges.map(Converters.toRange);
            this._onDidChangeTextEditorVisibleRanges.fire({
                textEditor,
                visibleRanges
            });
        }
    }
    $acceptEditorPositionData(data) {
        for (const id in data) {
            if (data.hasOwnProperty(id)) {
                const textEditor = this.editorsAndDocuments.getEditor(id);
                const viewColumn = Converters.toViewColumn(data[id]);
                if (textEditor && viewColumn) {
                    if (textEditor.viewColumn !== viewColumn) {
                        textEditor.acceptViewColumn(viewColumn);
                        this._onDidChangeTextEditorViewColumn.fire({ textEditor, viewColumn });
                    }
                }
            }
        }
    }
    getActiveEditor() {
        return this.editorsAndDocuments.activeEditor();
    }
    getVisibleTextEditors() {
        return this.editorsAndDocuments.allEditors();
    }
    createTextEditorDecorationType(options) {
        return new TextEditorDecorationType(this.proxy, options);
    }
    applyWorkspaceEdit(edit, metadata) {
        const dto = Converters.fromWorkspaceEdit(edit, this.editorsAndDocuments);
        return this.proxy.$tryApplyWorkspaceEdit(dto, metadata);
    }
    saveAll(includeUntitled) {
        return this.proxy.$saveAll(includeUntitled);
    }
}
exports.TextEditorsExtImpl = TextEditorsExtImpl;
class TextEditorDecorationType {
    constructor(proxy, options) {
        this.key = TextEditorDecorationType.Keys.nextId();
        this.proxy = proxy;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.proxy.$registerTextEditorDecorationType(this.key, Converters.DecorationRenderOptions.from(options));
    }
    dispose() {
        this.proxy.$removeTextEditorDecorationType(this.key);
    }
}
exports.TextEditorDecorationType = TextEditorDecorationType;
TextEditorDecorationType.Keys = new id_generator_1.IdGenerator('TextEditorDecorationType');


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/theming.js":
/*!*******************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/theming.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ThemingExtImpl = void 0;
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../packages/core/lib/common/event.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// some code copied and modified from https://github.com/microsoft/vscode/blob/5ddbda0172d80bfbb2529987ba9020848e8771f7/src/vs/workbench/api/common/extHostTheming.ts
class ThemingExtImpl {
    constructor(rpc) {
        this.rpc = rpc;
        this.actual = new types_impl_1.ColorTheme(types_impl_1.ColorThemeKind.Dark);
        this._onDidChangeActiveColorTheme = new event_1.Emitter();
    }
    get activeColorTheme() {
        return this.actual;
    }
    $onColorThemeChange(type) {
        this.actual = new types_impl_1.ColorTheme(this.convertKind(type));
        this._onDidChangeActiveColorTheme.fire(this.actual);
    }
    convertKind(type) {
        let kind;
        switch (type) {
            case 'light':
                kind = types_impl_1.ColorThemeKind.Light;
                break;
            case 'dark':
                kind = types_impl_1.ColorThemeKind.Dark;
                break;
            case 'hc':
                kind = types_impl_1.ColorThemeKind.HighContrast;
                break;
            case 'hcLight':
                kind = types_impl_1.ColorThemeKind.HighContrastLight;
                break;
        }
        return kind;
    }
    get onDidChangeActiveColorTheme() {
        return this._onDidChangeActiveColorTheme.event;
    }
}
exports.ThemingExtImpl = ThemingExtImpl;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/timeline.js":
/*!********************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/timeline.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimelineExtImpl = void 0;
// *****************************************************************************
// Copyright (C) 2019 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
const common_1 = __webpack_require__(/*! ../common */ "../../packages/plugin-ext/lib/common/index.js");
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../packages/core/lib/common/disposable.js");
const cancellation_1 = __webpack_require__(/*! @theia/core/lib/common/cancellation */ "../../packages/core/lib/common/cancellation.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// copied and modified from https://github.com/microsoft/theia/blob/afacd2bdfe7060f09df9b9139521718915949757/src/vs/workbench/api/common/extHostTimeline.ts
class TimelineExtImpl {
    constructor(rpc, commands) {
        this.rpc = rpc;
        this.commands = commands;
        this.providers = new Map();
        this.itemsBySourceAndUriMap = new Map();
        this.proxy = rpc.getProxy(common_1.PLUGIN_RPC_CONTEXT.TIMELINE_MAIN);
        commands.registerArgumentProcessor({
            processArgument: arg => {
                var _a, _b, _c;
                if (!common_1.TimelineCommandArg.is(arg)) {
                    return arg;
                }
                else {
                    return (_c = (_a = this.itemsBySourceAndUriMap.get(arg.source)) === null || _a === void 0 ? void 0 : _a.get((_b = arg.uri) === null || _b === void 0 ? void 0 : _b.toString())) === null || _c === void 0 ? void 0 : _c.get(arg.timelineHandle);
                }
            }
        });
    }
    async $getTimeline(id, uri, options, internalOptions) {
        const provider = this.providers.get(id);
        return provider === null || provider === void 0 ? void 0 : provider.provideTimeline(types_impl_1.URI.revive(uri), options, internalOptions);
    }
    registerTimelineProvider(plugin, scheme, provider) {
        const timelineDisposables = new disposable_1.DisposableCollection();
        const convertTimelineItem = this.convertTimelineItem(provider.id, timelineDisposables).bind(this);
        let disposable;
        if (provider.onDidChange) {
            disposable = types_impl_1.Disposable.from(provider.onDidChange(e => this.proxy.$fireTimelineChanged({ uri: undefined, reset: true, ...e, id: provider.id }), this));
        }
        const itemsBySourceAndUriMap = this.itemsBySourceAndUriMap;
        return this.registerTimelineProviderCore({
            ...provider,
            scheme: scheme,
            onDidChange: undefined,
            async provideTimeline(uri, options, internalOptions) {
                if (internalOptions === null || internalOptions === void 0 ? void 0 : internalOptions.resetCache) {
                    timelineDisposables.dispose();
                    const items = itemsBySourceAndUriMap.get(provider.id);
                    if (items) {
                        items.clear();
                    }
                }
                const result = await provider.provideTimeline(uri, options, cancellation_1.CancellationToken.None);
                if (!result) {
                    return undefined;
                }
                const convertItem = convertTimelineItem(uri, internalOptions);
                return {
                    ...result,
                    source: provider.id,
                    items: result.items.map(convertItem)
                };
            },
            dispose() {
                for (const sourceMap of itemsBySourceAndUriMap.values()) {
                    const source = sourceMap.get(provider.id);
                    if (source) {
                        source.clear();
                    }
                }
                if (disposable) {
                    disposable.dispose();
                }
                timelineDisposables.dispose();
            }
        });
    }
    convertTimelineItem(source, disposables) {
        return (uri, options) => {
            let items;
            if (options === null || options === void 0 ? void 0 : options.cacheResults) {
                let itemsByUri = this.itemsBySourceAndUriMap.get(source);
                if (itemsByUri === undefined) {
                    itemsByUri = new Map();
                    this.itemsBySourceAndUriMap.set(source, itemsByUri);
                }
                const uriKey = getUriKey(uri);
                items = itemsByUri.get(uriKey);
                if (items === undefined) {
                    items = new Map();
                    itemsByUri.set(uriKey, items);
                }
            }
            return (item) => {
                var _a, _b;
                const { iconPath, ...props } = item;
                const handle = `${source}|${(_a = item.id) !== null && _a !== void 0 ? _a : item.timestamp}`;
                if (items) {
                    items.set(handle, item);
                }
                return {
                    ...props,
                    uri: uri.toString(),
                    id: (_b = props.id) !== null && _b !== void 0 ? _b : undefined,
                    handle: handle,
                    source: source,
                    command: item.command ? this.commands.converter.toSafeCommand(item.command, disposables) : undefined,
                };
            };
        };
    }
    registerTimelineProviderCore(provider) {
        const existing = this.providers.get(provider.id);
        if (existing) {
            throw new Error(`Timeline Provider ${provider.id} already exists.`);
        }
        this.proxy.$registerTimelineProvider({
            id: provider.id,
            label: provider.label,
            scheme: provider.scheme
        });
        this.providers.set(provider.id, provider);
        return types_impl_1.Disposable.create(() => {
            for (const sourceMap of this.itemsBySourceAndUriMap.values()) {
                const items = sourceMap.get(provider.id);
                if (items) {
                    items.clear();
                }
            }
            this.providers.delete(provider.id);
            this.proxy.$unregisterTimelineProvider(provider.id);
            provider.dispose();
        });
    }
}
exports.TimelineExtImpl = TimelineExtImpl;
function getUriKey(uri) {
    return uri === null || uri === void 0 ? void 0 : uri.toString();
}


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/tree/tree-views.js":
/*!***************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/tree/tree-views.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TreeViewsExtImpl = void 0;
// TODO: extract `@theia/util` for event, disposable, cancellation and common types
// don't use @theia/core directly from plugin host
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../packages/core/lib/common/event.js");
const paths_1 = __webpack_require__(/*! @theia/core/lib/common/paths */ "../../packages/core/lib/common/paths.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../packages/core/lib/common/disposable.js");
const types_impl_1 = __webpack_require__(/*! ../types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const common_1 = __webpack_require__(/*! ../../common */ "../../packages/plugin-ext/lib/common/index.js");
const plugin_icon_path_1 = __webpack_require__(/*! ../plugin-icon-path */ "../../packages/plugin-ext/lib/plugin/plugin-icon-path.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../../packages/core/shared/vscode-uri/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../packages/core/lib/common/index.js");
class TreeViewsExtImpl {
    constructor(rpc, commandRegistry) {
        this.commandRegistry = commandRegistry;
        this.treeViews = new Map();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.TREE_VIEWS_MAIN);
        commandRegistry.registerArgumentProcessor({
            processArgument: arg => {
                if (common_1.TreeViewItemReference.is(arg)) {
                    return this.toTreeElement(arg);
                }
                else if (Array.isArray(arg)) {
                    return arg.map(param => common_1.TreeViewItemReference.is(param) ? this.toTreeElement(param) : param);
                }
                else {
                    return arg;
                }
            }
        });
    }
    $checkStateChanged(treeViewId, itemIds) {
        return this.getTreeView(treeViewId).checkStateChanged(itemIds);
    }
    $dragStarted(treeViewId, treeItemIds, token) {
        return this.getTreeView(treeViewId).onDragStarted(treeItemIds, token);
    }
    $dragEnd(treeViewId) {
        return this.getTreeView(treeViewId).dragEnd();
    }
    $drop(treeViewId, treeItemId, dataTransferItems, token) {
        return this.getTreeView(treeViewId).handleDrop(treeItemId, dataTransferItems, token);
    }
    toTreeElement(treeViewItemRef) {
        var _a;
        return (_a = this.treeViews.get(treeViewItemRef.viewId)) === null || _a === void 0 ? void 0 : _a.getElement(treeViewItemRef.itemId);
    }
    registerTreeDataProvider(plugin, treeViewId, treeDataProvider) {
        const treeView = this.createTreeView(plugin, treeViewId, { treeDataProvider });
        return types_impl_1.Disposable.create(() => {
            this.treeViews.delete(treeViewId);
            treeView.dispose();
        });
    }
    createTreeView(plugin, treeViewId, options) {
        if (!options || !options.treeDataProvider) {
            throw new Error('Options with treeDataProvider is mandatory');
        }
        const treeView = new TreeViewExtImpl(plugin, treeViewId, options, this.proxy, this.commandRegistry.converter);
        this.treeViews.set(treeViewId, treeView);
        return {
            // tslint:disable:typedef
            get onDidExpandElement() {
                return treeView.onDidExpandElement;
            },
            get onDidCollapseElement() {
                return treeView.onDidCollapseElement;
            },
            get selection() {
                return treeView.selectedElements;
            },
            get onDidChangeSelection() {
                return treeView.onDidChangeSelection;
            },
            get visible() {
                return treeView.visible;
            },
            get onDidChangeVisibility() {
                return treeView.onDidChangeVisibility;
            },
            get onDidChangeCheckboxState() {
                return treeView.onDidChangeCheckboxState;
            },
            get message() {
                return treeView.message;
            },
            set message(message) {
                treeView.message = message;
            },
            get title() {
                return treeView.title;
            },
            set title(title) {
                treeView.title = title;
            },
            get description() {
                return treeView.description;
            },
            set description(description) {
                treeView.description = description;
            },
            get badge() {
                return treeView.badge;
            },
            set badge(badge) {
                treeView.badge = badge;
            },
            reveal: (element, revealOptions) => treeView.reveal(element, revealOptions),
            dispose: () => {
                this.treeViews.delete(treeViewId);
                treeView.dispose();
            }
        };
    }
    async $getChildren(treeViewId, treeItemId) {
        const treeView = this.getTreeView(treeViewId);
        return treeView.getChildren(treeItemId);
    }
    async $resolveTreeItem(treeViewId, treeItemId, token) {
        return this.getTreeView(treeViewId).resolveTreeItem(treeItemId, token);
    }
    async $hasResolveTreeItem(treeViewId) {
        return this.getTreeView(treeViewId).hasResolveTreeItem();
    }
    async $setExpanded(treeViewId, treeItemId, expanded) {
        const treeView = this.getTreeView(treeViewId);
        if (expanded) {
            return treeView.onExpanded(treeItemId);
        }
        else {
            return treeView.onCollapsed(treeItemId);
        }
    }
    async $setSelection(treeViewId, treeItemIds) {
        this.getTreeView(treeViewId).setSelection(treeItemIds);
    }
    async $setVisible(treeViewId, isVisible) {
        this.getTreeView(treeViewId).setVisible(isVisible);
    }
    getTreeView(treeViewId) {
        const treeView = this.treeViews.get(treeViewId);
        if (!treeView) {
            throw new Error(`No tree view with id '${treeViewId}' registered.`);
        }
        return treeView;
    }
}
exports.TreeViewsExtImpl = TreeViewsExtImpl;
class TreeViewExtImpl {
    constructor(plugin, treeViewId, options, proxy, commandsConverter) {
        var _a, _b, _c, _d, _e, _f;
        this.plugin = plugin;
        this.treeViewId = treeViewId;
        this.options = options;
        this.proxy = proxy;
        this.commandsConverter = commandsConverter;
        this.onDidExpandElementEmitter = new event_1.Emitter();
        this.onDidExpandElement = this.onDidExpandElementEmitter.event;
        this.onDidCollapseElementEmitter = new event_1.Emitter();
        this.onDidCollapseElement = this.onDidCollapseElementEmitter.event;
        this.onDidChangeSelectionEmitter = new event_1.Emitter();
        this.onDidChangeSelection = this.onDidChangeSelectionEmitter.event;
        this.onDidChangeVisibilityEmitter = new event_1.Emitter();
        this.onDidChangeVisibility = this.onDidChangeVisibilityEmitter.event;
        this.onDidChangeCheckboxStateEmitter = new event_1.Emitter();
        this.onDidChangeCheckboxState = this.onDidChangeCheckboxStateEmitter.event;
        this.nodes = new Map();
        this.pendingRefresh = Promise.resolve();
        this.localDataTransfer = new types_impl_1.DataTransfer();
        this.toDispose = new disposable_1.DisposableCollection(disposable_1.Disposable.create(() => this.clearAll()), this.onDidExpandElementEmitter, this.onDidCollapseElementEmitter, this.onDidChangeSelectionEmitter, this.onDidChangeVisibilityEmitter);
        this._message = '';
        this._title = '';
        this._description = '';
        this._badge = undefined;
        this.selectedItemIds = new Set();
        this._visible = false;
        // make copies of optionally provided MIME types:
        const dragMimeTypes = (_b = (_a = options.dragAndDropController) === null || _a === void 0 ? void 0 : _a.dragMimeTypes) === null || _b === void 0 ? void 0 : _b.slice();
        const dropMimeTypes = (_d = (_c = options.dragAndDropController) === null || _c === void 0 ? void 0 : _c.dropMimeTypes) === null || _d === void 0 ? void 0 : _d.slice();
        proxy.$registerTreeDataProvider(treeViewId, {
            manageCheckboxStateManually: options.manageCheckboxStateManually,
            showCollapseAll: options.showCollapseAll,
            canSelectMany: options.canSelectMany,
            dragMimeTypes, dropMimeTypes
        });
        this.toDispose.push(disposable_1.Disposable.create(() => this.proxy.$unregisterTreeDataProvider(treeViewId)));
        (_f = (_e = options.treeDataProvider).onDidChangeTreeData) === null || _f === void 0 ? void 0 : _f.call(_e, () => {
            this.pendingRefresh = proxy.$refresh(treeViewId);
        });
    }
    dispose() {
        this.toDispose.dispose();
    }
    async reveal(element, options) {
        await this.pendingRefresh;
        const select = (options === null || options === void 0 ? void 0 : options.select) !== false; // default to true
        const focus = !!(options === null || options === void 0 ? void 0 : options.focus);
        const expand = typeof (options === null || options === void 0 ? void 0 : options.expand) === 'undefined' ? false : options.expand;
        const elementParentChain = await this.calculateRevealParentChain(element);
        if (elementParentChain) {
            return this.proxy.$reveal(this.treeViewId, elementParentChain, {
                select, focus, expand, ...options
            });
        }
    }
    get message() {
        return this._message;
    }
    set message(message) {
        this._message = message;
        this.proxy.$setMessage(this.treeViewId, this._message);
    }
    get title() {
        return this._title;
    }
    set title(title) {
        this._title = title;
        this.proxy.$setTitle(this.treeViewId, title);
    }
    get description() {
        return this._description;
    }
    set description(description) {
        this._description = description;
        this.proxy.$setDescription(this.treeViewId, this._description);
    }
    get badge() {
        return this._badge;
    }
    set badge(badge) {
        this._badge = badge;
        this.proxy.$setBadge(this.treeViewId, badge ? { value: badge.value, tooltip: badge.tooltip } : undefined);
    }
    getElement(treeItemId) {
        var _a;
        return (_a = this.nodes.get(treeItemId)) === null || _a === void 0 ? void 0 : _a.value;
    }
    /**
     * calculate the chain of node ids from root to element so that the frontend can expand all of them and reveal element.
     * this is needed as the frontend may not have the full tree nodes.
     * throughout the parent chain this.getChildren is called in order to fill this.nodes cache.
     *
     * returns undefined if wasn't able to calculate the path due to inconsistencies.
     *
     * @param element element to reveal
     */
    async calculateRevealParentChain(element) {
        var _a, _b, _c;
        if (!element) {
            // root
            return [];
        }
        const parent = (_c = await ((_b = (_a = this.options.treeDataProvider).getParent) === null || _b === void 0 ? void 0 : _b.call(_a, element))) !== null && _c !== void 0 ? _c : undefined;
        const chain = await this.calculateRevealParentChain(parent);
        const parentId = chain.length ? chain[chain.length - 1] : '';
        const treeItem = await this.options.treeDataProvider.getTreeItem(element);
        return chain.concat(this.buildTreeItemId(parentId, treeItem, false));
    }
    getTreeItemLabel(treeItem) {
        const treeItemLabel = treeItem.label;
        return typeof treeItemLabel === 'object' ? treeItemLabel.label : treeItemLabel;
    }
    getTreeItemLabelHighlights(treeItem) {
        const treeItemLabel = treeItem.label;
        return typeof treeItemLabel === 'object' ? treeItemLabel.highlights : undefined;
    }
    getItemLabel(treeItem) {
        let idLabel = this.getTreeItemLabel(treeItem);
        // Use resource URI if label is not set
        if (idLabel === undefined && treeItem.resourceUri) {
            idLabel = treeItem.resourceUri.path.toString();
            idLabel = decodeURIComponent(idLabel);
            if (idLabel.indexOf('/') >= 0) {
                idLabel = idLabel.substring(idLabel.lastIndexOf('/') + 1);
            }
        }
        return idLabel;
    }
    // Modeled on https://github.com/microsoft/vscode/blob/main/src/vs/workbench/api/common/extHostTreeViews.ts#L822
    buildTreeItemId(parentId, item, mustReturnNew) {
        var _a;
        if (item.id) {
            return `${TreeViewExtImpl.ID_ITEM}-@-${parentId}-@-${item.id}`;
        }
        const treeItemLabel = this.getItemLabel(item);
        const prefix = `${TreeViewExtImpl.ID_COMPUTED}-@-${parentId || ''}-@-`;
        let elementId = treeItemLabel ? treeItemLabel : item.resourceUri ? (0, paths_1.basename)(item.resourceUri.fsPath) : '';
        elementId = elementId.indexOf('/') !== -1 ? elementId.replace('/', '//') : elementId;
        const childrenNodes = (((_a = this.nodes.get(parentId)) === null || _a === void 0 ? void 0 : _a.children) || []);
        let id;
        let counter = 0;
        do {
            id = `${prefix}/${counter}:${elementId}`;
            if (!mustReturnNew || !this.nodes.has(id) || this.nodes.get(id) === item) {
                // Return first if asked for or
                // Return if handle does not exist or
                // Return if handle is being reused
                break;
            }
            counter++;
        } while (counter <= childrenNodes.length);
        return id;
    }
    async getChildren(parentId) {
        let parentNode = this.nodes.get(parentId);
        const parent = parentNode === null || parentNode === void 0 ? void 0 : parentNode.value;
        if (parentId && !parent) {
            console.error(`No tree item with id '${parentId}' found.`);
            return [];
        }
        this.clearChildren(parentNode);
        // place root in the cache
        if (parentId === '' && !parentNode) {
            const rootNodeDisposables = new disposable_1.DisposableCollection();
            parentNode = { id: '', disposables: rootNodeDisposables, dispose: () => { rootNodeDisposables.dispose(); } };
            this.nodes.set(parentId, parentNode);
        }
        // ask data provider for children for cached element
        const result = await this.options.treeDataProvider.getChildren(parent);
        if (result) {
            const treeItemPromises = result.map(async (value) => {
                var _a;
                // Ask data provider for a tree item for the value
                // Data provider must return theia.TreeItem
                const treeItem = await this.options.treeDataProvider.getTreeItem(value);
                // Convert theia.TreeItem to the TreeViewItem
                const label = this.getItemLabel(treeItem) || '';
                const highlights = this.getTreeItemLabelHighlights(treeItem);
                // Generate the ID
                // ID is used for caching the element
                const id = this.buildTreeItemId(parentId, treeItem, true);
                const toDisposeElement = new disposable_1.DisposableCollection();
                const node = {
                    id,
                    pluginTreeItem: treeItem,
                    value,
                    disposables: toDisposeElement,
                    dispose: () => toDisposeElement.dispose()
                };
                if (parentNode) {
                    const children = parentNode.children || [];
                    children.push(node);
                    parentNode.children = children;
                }
                this.nodes.set(id, node);
                let icon;
                let iconUrl;
                let themeIcon;
                const { iconPath } = treeItem;
                if (typeof iconPath === 'string' && iconPath.indexOf('fa-') !== -1) {
                    icon = iconPath;
                }
                else if (types_impl_1.ThemeIcon.is(iconPath)) {
                    themeIcon = iconPath;
                }
                else {
                    iconUrl = plugin_icon_path_1.PluginIconPath.toUrl(iconPath, this.plugin);
                }
                let checkboxInfo;
                if (treeItem.checkboxState === undefined) {
                    checkboxInfo = undefined;
                }
                else if ((0, core_1.isObject)(treeItem.checkboxState)) {
                    checkboxInfo = {
                        checked: treeItem.checkboxState.state === types_impl_1.TreeItemCheckboxState.Checked,
                        tooltip: treeItem.checkboxState.tooltip,
                        accessibilityInformation: treeItem.accessibilityInformation
                    };
                }
                else {
                    checkboxInfo = {
                        checked: treeItem.checkboxState === types_impl_1.TreeItemCheckboxState.Checked
                    };
                }
                const treeViewItem = {
                    id,
                    label,
                    highlights,
                    icon,
                    iconUrl,
                    themeIcon,
                    description: treeItem.description,
                    resourceUri: treeItem.resourceUri,
                    tooltip: treeItem.tooltip,
                    collapsibleState: (_a = treeItem.collapsibleState) === null || _a === void 0 ? void 0 : _a.valueOf(),
                    checkboxInfo: checkboxInfo,
                    contextValue: treeItem.contextValue,
                    command: this.commandsConverter.toSafeCommand(treeItem.command, toDisposeElement),
                    accessibilityInformation: treeItem.accessibilityInformation
                };
                node.treeViewItem = treeViewItem;
                return treeViewItem;
            });
            return Promise.all(treeItemPromises);
        }
        else {
            return undefined;
        }
    }
    clearChildren(parentNode) {
        if (parentNode) {
            if (parentNode.children) {
                for (const child of parentNode.children) {
                    this.clear(child);
                }
            }
            delete parentNode['children'];
        }
        else {
            this.clearAll();
        }
    }
    clear(node) {
        if (node.children) {
            for (const child of node.children) {
                this.clear(child);
            }
        }
        this.nodes.delete(node.id);
        node.dispose();
    }
    clearAll() {
        this.nodes.forEach(node => node.dispose());
        this.nodes.clear();
    }
    async onExpanded(treeItemId) {
        // get element from a cache
        const cachedElement = this.getElement(treeItemId);
        // fire an event
        if (cachedElement) {
            this.onDidExpandElementEmitter.fire({
                element: cachedElement
            });
        }
    }
    async onCollapsed(treeItemId) {
        // get element from a cache
        const cachedElement = this.getElement(treeItemId);
        // fire an event
        if (cachedElement) {
            this.onDidCollapseElementEmitter.fire({
                element: cachedElement
            });
        }
    }
    async checkStateChanged(items) {
        const transformed = [];
        items.forEach(item => {
            const node = this.nodes.get(item.id);
            if (node) {
                if (node.value) {
                    transformed.push([node.value, item.checked ? types_impl_1.TreeItemCheckboxState.Checked : types_impl_1.TreeItemCheckboxState.Unchecked]);
                }
                if (node.treeViewItem) {
                    node.treeViewItem.checkboxInfo.checked = item.checked;
                }
            }
        });
        this.onDidChangeCheckboxStateEmitter.fire({
            items: transformed
        });
    }
    async resolveTreeItem(treeItemId, token) {
        var _a;
        if (!this.options.treeDataProvider.resolveTreeItem) {
            return undefined;
        }
        const node = this.nodes.get(treeItemId);
        if (node && node.treeViewItem && node.pluginTreeItem && node.value) {
            const resolved = (_a = await this.options.treeDataProvider.resolveTreeItem(node.pluginTreeItem, node.value, token)) !== null && _a !== void 0 ? _a : node.pluginTreeItem;
            node.treeViewItem.command = this.commandsConverter.toSafeCommand(resolved.command, node.disposables);
            node.treeViewItem.tooltip = resolved.tooltip;
            return node.treeViewItem;
        }
        return undefined;
    }
    hasResolveTreeItem() {
        return !!this.options.treeDataProvider.resolveTreeItem;
    }
    get selectedElements() {
        const items = [];
        for (const id of this.selectedItemIds) {
            const item = this.getElement(id);
            if (item) {
                items.push(item);
            }
        }
        return items;
    }
    setSelection(selectedItemIds) {
        const toDelete = new Set(this.selectedItemIds);
        for (const id of selectedItemIds) {
            toDelete.delete(id);
            if (!this.selectedItemIds.has(id)) {
                this.doSetSelection(selectedItemIds);
                return;
            }
        }
        if (toDelete.size) {
            this.doSetSelection(selectedItemIds);
        }
    }
    doSetSelection(selectedItemIts) {
        this.selectedItemIds = new Set(selectedItemIts);
        this.onDidChangeSelectionEmitter.fire(Object.freeze({ selection: this.selectedElements }));
    }
    get visible() {
        return this._visible;
    }
    setVisible(visible) {
        if (visible !== this._visible) {
            this._visible = visible;
            this.onDidChangeVisibilityEmitter.fire(Object.freeze({ visible: this._visible }));
        }
    }
    async onDragStarted(treeItemIds, token) {
        var _a, _b;
        const treeItems = [];
        for (const id of treeItemIds) {
            const item = this.getElement(id);
            if (item) {
                treeItems.push(item);
            }
        }
        if ((_a = this.options.dragAndDropController) === null || _a === void 0 ? void 0 : _a.handleDrag) {
            this.localDataTransfer.clear();
            await this.options.dragAndDropController.handleDrag(treeItems, this.localDataTransfer, token);
            const uriList = await ((_b = this.localDataTransfer.get('text/uri-list')) === null || _b === void 0 ? void 0 : _b.asString());
            if (uriList) {
                return uriList.split('\n').map(str => vscode_uri_1.URI.parse(str));
            }
        }
        return undefined;
    }
    async dragEnd() {
        this.localDataTransfer.clear();
    }
    async handleDrop(treeItemId, dataTransferItems, token) {
        var _a;
        const treeItem = treeItemId ? this.getElement(treeItemId) : undefined;
        const dropTransfer = new types_impl_1.DataTransfer();
        if ((_a = this.options.dragAndDropController) === null || _a === void 0 ? void 0 : _a.handleDrop) {
            this.localDataTransfer.forEach((item, type) => {
                dropTransfer.set(type, item);
            });
            for (const [type, item] of dataTransferItems) {
                // prefer the item the plugin has set in `onDragStarted`;
                if (!dropTransfer.has(type)) {
                    if (typeof item === 'string') {
                        dropTransfer.set(type, new types_impl_1.DataTransferItem(item));
                    }
                    else {
                        const file = {
                            name: item.name,
                            data: () => this.proxy.$readDroppedFile(item.contentId).then(buffer => buffer.buffer),
                            uri: item.uri ? vscode_uri_1.URI.revive(item.uri) : undefined
                        };
                        const fileItem = new class extends types_impl_1.DataTransferItem {
                            asFile() {
                                return file;
                            }
                        }(file);
                        dropTransfer.set(type, fileItem);
                    }
                }
            }
            return this.options.dragAndDropController.handleDrop(treeItem, dropTransfer, token);
        }
    }
}
TreeViewExtImpl.ID_COMPUTED = 'c';
TreeViewExtImpl.ID_ITEM = 'i';


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/type-converters.js":
/*!***************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/type-converters.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromHierarchyItem = exports.toLocation = exports.isModelCallHierarchyOutgoingCall = exports.isModelCallHierarchyIncomingCall = exports.isModelCallHierarchyItem = exports.isUriComponents = exports.isModelRange = exports.isModelLocation = exports.toSymbolTag = exports.fromSymbolTag = exports.toDocumentSymbol = exports.fromDocumentSymbol = exports.toCodeActionTriggerKind = exports.SymbolKind = exports.fromWorkspaceEdit = exports.SignatureHelp = exports.SignatureInformation = exports.ParameterInformation = exports.fromDocumentHighlight = exports.fromDocumentHighlightKind = exports.DocumentLink = exports.fromDefinitionLink = exports.fromTextDocumentShowOptions = exports.fromLocation = exports.toInlineValueContext = exports.fromInlineValue = exports.fromEvaluatableExpression = exports.fromHover = exports.convertCode = exports.convertDiagnosticToMarkerData = exports.fromTextEdit = exports.toCompletionItemKind = exports.fromCompletionItemKind = exports.fromGlobPattern = exports.fromDocumentSelector = exports.toMarkdown = exports.fromMarkdownOrString = exports.fromMarkdown = exports.fromManyMarkdown = exports.fromRangeOrRangeWithMessage = exports.isDecorationOptionsArr = exports.toPosition = exports.fromPosition = exports.fromRange = exports.toRange = exports.fromSelection = exports.toSelection = exports.toWebviewPanelShowOptions = exports.fromViewColumn = exports.toViewColumn = void 0;
exports.NotebookDto = exports.NotebookKernelSourceAction = exports.NotebookRange = exports.NotebookCellExecutionSummary = exports.NotebookCellOutputConverter = exports.NotebookCellOutputItem = exports.NotebookCellOutput = exports.NotebookCellKind = exports.NotebookCellData = exports.NotebookData = exports.NotebookStatusBarItem = exports.NotebookDocumentContentOptions = exports.DataTransfer = exports.DataTransferItem = exports.InlayHintKind = exports.pluginToPluginInfo = exports.pathOrURIToURI = exports.ViewColumn = exports.ThemableDecorationAttachmentRenderOptions = exports.ThemableDecorationRenderOptions = exports.DecorationRangeBehavior = exports.DecorationRenderOptions = exports.convertToTransferQuickPickItems = exports.fromColorPresentation = exports.toColor = exports.fromColor = exports.fromFoldingRangeKind = exports.fromFoldingRange = exports.fromSelectionRange = exports.toSymbolInformation = exports.fromSymbolInformation = exports.getShellExecutionOptions = exports.getShellArgs = exports.getCustomExecution = exports.getShellExecution = exports.getProcessExecution = exports.fromCustomExecution = exports.fromShellExecution = exports.fromProcessExecution = exports.toTask = exports.fromTask = exports.toWorkspaceFolder = exports.toTypeHierarchyItem = exports.fromTypeHierarchyItem = exports.isModelTypeHierarchyItem = exports.toCallHierarchyOutgoingCall = exports.toCallHierarchyIncomingCall = exports.toCallHierarchyItem = exports.fromCallHierarchyItem = void 0;
const lstypes = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "../../packages/core/shared/vscode-languageserver-protocol/index.js");
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const rpc = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const model = __webpack_require__(/*! ../common/plugin-api-rpc-model */ "../../packages/plugin-ext/lib/common/plugin-api-rpc-model.js");
const markdown_string_1 = __webpack_require__(/*! ./markdown-string */ "../../packages/plugin-ext/lib/plugin/markdown-string.js");
const types = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const arrays_1 = __webpack_require__(/*! ../common/arrays */ "../../packages/plugin-ext/lib/common/arrays.js");
const markdown_rendering_1 = __webpack_require__(/*! @theia/core/lib/common/markdown-rendering */ "../../packages/core/lib/common/markdown-rendering/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../../packages/core/lib/common/index.js");
const notebooks = __webpack_require__(/*! @theia/notebook/lib/common */ "../../packages/notebook/lib/common/index.js");
const buffer_1 = __webpack_require__(/*! @theia/core/lib/common/buffer */ "../../packages/core/lib/common/buffer.js");
const common_2 = __webpack_require__(/*! @theia/notebook/lib/common */ "../../packages/notebook/lib/common/index.js");
const SIDE_GROUP = -2;
const ACTIVE_GROUP = -1;
function toViewColumn(ep) {
    if (typeof ep !== 'number') {
        return undefined;
    }
    if (ep === plugin_api_rpc_1.EditorPosition.ONE) {
        return types.ViewColumn.One;
    }
    else if (ep === plugin_api_rpc_1.EditorPosition.TWO) {
        return types.ViewColumn.Two;
    }
    else if (ep === plugin_api_rpc_1.EditorPosition.THREE) {
        return types.ViewColumn.Three;
    }
    else if (ep === plugin_api_rpc_1.EditorPosition.FOUR) {
        return types.ViewColumn.Four;
    }
    else if (ep === plugin_api_rpc_1.EditorPosition.FIVE) {
        return types.ViewColumn.Five;
    }
    else if (ep === plugin_api_rpc_1.EditorPosition.SIX) {
        return types.ViewColumn.Six;
    }
    else if (ep === plugin_api_rpc_1.EditorPosition.SEVEN) {
        return types.ViewColumn.Seven;
    }
    else if (ep === plugin_api_rpc_1.EditorPosition.EIGHT) {
        return types.ViewColumn.Eight;
    }
    else if (ep === plugin_api_rpc_1.EditorPosition.NINE) {
        return types.ViewColumn.Nine;
    }
    return undefined;
}
exports.toViewColumn = toViewColumn;
function fromViewColumn(column) {
    if (typeof column === 'number' && column >= types.ViewColumn.One) {
        return column - 1;
    }
    if (column === types.ViewColumn.Beside) {
        return SIDE_GROUP;
    }
    return ACTIVE_GROUP;
}
exports.fromViewColumn = fromViewColumn;
function toWebviewPanelShowOptions(options) {
    if (typeof options === 'object') {
        const showOptions = options;
        return {
            area: showOptions.area ? showOptions.area : types.WebviewPanelTargetArea.Main,
            viewColumn: showOptions.viewColumn ? fromViewColumn(showOptions.viewColumn) : undefined,
            preserveFocus: showOptions.preserveFocus ? showOptions.preserveFocus : false
        };
    }
    return {
        area: types.WebviewPanelTargetArea.Main,
        viewColumn: fromViewColumn(options),
        preserveFocus: false
    };
}
exports.toWebviewPanelShowOptions = toWebviewPanelShowOptions;
function toSelection(selection) {
    const { selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn } = selection;
    const start = new types.Position(selectionStartLineNumber - 1, selectionStartColumn - 1);
    const end = new types.Position(positionLineNumber - 1, positionColumn - 1);
    return new types.Selection(start, end);
}
exports.toSelection = toSelection;
function fromSelection(selection) {
    const { active, anchor } = selection;
    return {
        selectionStartLineNumber: anchor.line + 1,
        selectionStartColumn: anchor.character + 1,
        positionLineNumber: active.line + 1,
        positionColumn: active.character + 1
    };
}
exports.fromSelection = fromSelection;
function toRange(range) {
    const { startLineNumber, startColumn, endLineNumber, endColumn } = range;
    return new types.Range(startLineNumber - 1, startColumn - 1, endLineNumber - 1, endColumn - 1);
}
exports.toRange = toRange;
function fromRange(range) {
    if (!range) {
        return undefined;
    }
    const { start, end } = range;
    return {
        startLineNumber: start.line + 1,
        startColumn: start.character + 1,
        endLineNumber: end.line + 1,
        endColumn: end.character + 1
    };
}
exports.fromRange = fromRange;
function fromPosition(position) {
    return { lineNumber: position.line + 1, column: position.character + 1 };
}
exports.fromPosition = fromPosition;
function toPosition(position) {
    return new types.Position(position.lineNumber - 1, position.column - 1);
}
exports.toPosition = toPosition;
function isDecorationOptions(arg) {
    return (0, common_1.isObject)(arg) && typeof arg.range !== 'undefined';
}
function isDecorationOptionsArr(something) {
    if (something.length === 0) {
        return true;
    }
    return isDecorationOptions(something[0]) ? true : false;
}
exports.isDecorationOptionsArr = isDecorationOptionsArr;
function fromRangeOrRangeWithMessage(ranges) {
    if (isDecorationOptionsArr(ranges)) {
        return ranges.map(r => {
            let hoverMessage;
            if (Array.isArray(r.hoverMessage)) {
                hoverMessage = fromManyMarkdown(r.hoverMessage);
            }
            else if (r.hoverMessage) {
                hoverMessage = fromMarkdown(r.hoverMessage);
            }
            else {
                hoverMessage = undefined;
            }
            return {
                range: fromRange(r.range),
                hoverMessage: hoverMessage,
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                renderOptions: r.renderOptions
            };
        });
    }
    else {
        return ranges.map(r => ({ range: fromRange(r) }));
    }
}
exports.fromRangeOrRangeWithMessage = fromRangeOrRangeWithMessage;
function fromManyMarkdown(markup) {
    return markup.map(fromMarkdown);
}
exports.fromManyMarkdown = fromManyMarkdown;
function isCodeblock(arg) {
    return (0, common_1.isObject)(arg)
        && typeof arg.language === 'string'
        && typeof arg.value === 'string';
}
function fromMarkdown(markup) {
    if (isCodeblock(markup)) {
        const { language, value } = markup;
        return { value: '```' + language + '\n' + value + '\n```\n' };
    }
    else if (markup instanceof markdown_string_1.MarkdownString) {
        return markup.toJSON();
    }
    else if (markdown_rendering_1.MarkdownString.is(markup)) {
        return markup;
    }
    else if (typeof markup === 'string') {
        return { value: markup };
    }
    else {
        return { value: '' };
    }
}
exports.fromMarkdown = fromMarkdown;
function fromMarkdownOrString(value) {
    if (value === undefined) {
        return undefined;
    }
    else if (typeof value === 'string') {
        return value;
    }
    else {
        return fromMarkdown(value);
    }
}
exports.fromMarkdownOrString = fromMarkdownOrString;
function toMarkdown(value) {
    const implemented = new markdown_string_1.MarkdownString(value.value, value.supportThemeIcons);
    implemented.isTrusted = value.isTrusted;
    implemented.supportHtml = value.supportHtml;
    implemented.baseUri = value.baseUri && types_impl_1.URI.revive(implemented.baseUri);
    return implemented;
}
exports.toMarkdown = toMarkdown;
function fromDocumentSelector(selector) {
    if (!selector) {
        return undefined;
    }
    else if ((0, arrays_1.isReadonlyArray)(selector)) {
        return selector.map(fromDocumentSelector);
    }
    else if (typeof selector === 'string') {
        return selector;
    }
    else {
        return {
            language: selector.language,
            scheme: selector.scheme,
            pattern: fromGlobPattern(selector.pattern)
        };
    }
}
exports.fromDocumentSelector = fromDocumentSelector;
function fromGlobPattern(pattern) {
    if (typeof pattern === 'string') {
        return pattern;
    }
    if (isRelativePattern(pattern)) {
        return new types.RelativePattern(pattern.baseUri, pattern.pattern);
    }
    return pattern;
}
exports.fromGlobPattern = fromGlobPattern;
function isRelativePattern(obj) {
    const rp = obj;
    return rp && typeof rp.baseUri === 'string' && typeof rp.pattern === 'string';
}
function fromCompletionItemKind(kind) {
    switch (kind) {
        case types.CompletionItemKind.Method: return model.CompletionItemKind.Method;
        case types.CompletionItemKind.Function: return model.CompletionItemKind.Function;
        case types.CompletionItemKind.Constructor: return model.CompletionItemKind.Constructor;
        case types.CompletionItemKind.Field: return model.CompletionItemKind.Field;
        case types.CompletionItemKind.Variable: return model.CompletionItemKind.Variable;
        case types.CompletionItemKind.Class: return model.CompletionItemKind.Class;
        case types.CompletionItemKind.Interface: return model.CompletionItemKind.Interface;
        case types.CompletionItemKind.Struct: return model.CompletionItemKind.Struct;
        case types.CompletionItemKind.Module: return model.CompletionItemKind.Module;
        case types.CompletionItemKind.Property: return model.CompletionItemKind.Property;
        case types.CompletionItemKind.Unit: return model.CompletionItemKind.Unit;
        case types.CompletionItemKind.Value: return model.CompletionItemKind.Value;
        case types.CompletionItemKind.Constant: return model.CompletionItemKind.Constant;
        case types.CompletionItemKind.Enum: return model.CompletionItemKind.Enum;
        case types.CompletionItemKind.EnumMember: return model.CompletionItemKind.EnumMember;
        case types.CompletionItemKind.Keyword: return model.CompletionItemKind.Keyword;
        case types.CompletionItemKind.Snippet: return model.CompletionItemKind.Snippet;
        case types.CompletionItemKind.Text: return model.CompletionItemKind.Text;
        case types.CompletionItemKind.Color: return model.CompletionItemKind.Color;
        case types.CompletionItemKind.File: return model.CompletionItemKind.File;
        case types.CompletionItemKind.Reference: return model.CompletionItemKind.Reference;
        case types.CompletionItemKind.Folder: return model.CompletionItemKind.Folder;
        case types.CompletionItemKind.Event: return model.CompletionItemKind.Event;
        case types.CompletionItemKind.Operator: return model.CompletionItemKind.Operator;
        case types.CompletionItemKind.TypeParameter: return model.CompletionItemKind.TypeParameter;
        case types.CompletionItemKind.User: return model.CompletionItemKind.User;
        case types.CompletionItemKind.Issue: return model.CompletionItemKind.Issue;
    }
    return model.CompletionItemKind.Property;
}
exports.fromCompletionItemKind = fromCompletionItemKind;
function toCompletionItemKind(kind) {
    switch (kind) {
        case model.CompletionItemKind.Method: return types.CompletionItemKind.Method;
        case model.CompletionItemKind.Function: return types.CompletionItemKind.Function;
        case model.CompletionItemKind.Constructor: return types.CompletionItemKind.Constructor;
        case model.CompletionItemKind.Field: return types.CompletionItemKind.Field;
        case model.CompletionItemKind.Variable: return types.CompletionItemKind.Variable;
        case model.CompletionItemKind.Class: return types.CompletionItemKind.Class;
        case model.CompletionItemKind.Interface: return types.CompletionItemKind.Interface;
        case model.CompletionItemKind.Struct: return types.CompletionItemKind.Struct;
        case model.CompletionItemKind.Module: return types.CompletionItemKind.Module;
        case model.CompletionItemKind.Property: return types.CompletionItemKind.Property;
        case model.CompletionItemKind.Unit: return types.CompletionItemKind.Unit;
        case model.CompletionItemKind.Value: return types.CompletionItemKind.Value;
        case model.CompletionItemKind.Constant: return types.CompletionItemKind.Constant;
        case model.CompletionItemKind.Enum: return types.CompletionItemKind.Enum;
        case model.CompletionItemKind.EnumMember: return types.CompletionItemKind.EnumMember;
        case model.CompletionItemKind.Keyword: return types.CompletionItemKind.Keyword;
        case model.CompletionItemKind.Snippet: return types.CompletionItemKind.Snippet;
        case model.CompletionItemKind.Text: return types.CompletionItemKind.Text;
        case model.CompletionItemKind.Color: return types.CompletionItemKind.Color;
        case model.CompletionItemKind.File: return types.CompletionItemKind.File;
        case model.CompletionItemKind.Reference: return types.CompletionItemKind.Reference;
        case model.CompletionItemKind.Folder: return types.CompletionItemKind.Folder;
        case model.CompletionItemKind.Event: return types.CompletionItemKind.Event;
        case model.CompletionItemKind.Operator: return types.CompletionItemKind.Operator;
        case model.CompletionItemKind.TypeParameter: return types.CompletionItemKind.TypeParameter;
        case model.CompletionItemKind.User: return types.CompletionItemKind.User;
        case model.CompletionItemKind.Issue: return types.CompletionItemKind.Issue;
    }
    return types.CompletionItemKind.Property;
}
exports.toCompletionItemKind = toCompletionItemKind;
function fromTextEdit(edit) {
    return {
        text: edit.newText,
        range: fromRange(edit.range)
    };
}
exports.fromTextEdit = fromTextEdit;
function fromSnippetTextEdit(edit) {
    return {
        text: edit.snippet.value,
        range: fromRange(edit.range),
        insertAsSnippet: true
    };
}
function convertDiagnosticToMarkerData(diagnostic) {
    return {
        code: convertCode(diagnostic.code),
        severity: convertSeverity(diagnostic.severity),
        message: diagnostic.message,
        source: diagnostic.source,
        startLineNumber: diagnostic.range.start.line + 1,
        startColumn: diagnostic.range.start.character + 1,
        endLineNumber: diagnostic.range.end.line + 1,
        endColumn: diagnostic.range.end.character + 1,
        relatedInformation: convertRelatedInformation(diagnostic.relatedInformation),
        tags: convertTags(diagnostic.tags)
    };
}
exports.convertDiagnosticToMarkerData = convertDiagnosticToMarkerData;
function convertCode(code) {
    if (typeof code === 'number') {
        return String(code);
    }
    if (typeof code === 'string' || typeof code === 'undefined') {
        return code;
    }
    else {
        return String(code.value);
    }
    ;
}
exports.convertCode = convertCode;
function convertSeverity(severity) {
    switch (severity) {
        case types.DiagnosticSeverity.Error: return types.MarkerSeverity.Error;
        case types.DiagnosticSeverity.Warning: return types.MarkerSeverity.Warning;
        case types.DiagnosticSeverity.Information: return types.MarkerSeverity.Info;
        case types.DiagnosticSeverity.Hint: return types.MarkerSeverity.Hint;
    }
}
function convertRelatedInformation(diagnosticsRelatedInformation) {
    if (!diagnosticsRelatedInformation) {
        return undefined;
    }
    const relatedInformation = [];
    for (const item of diagnosticsRelatedInformation) {
        relatedInformation.push({
            resource: item.location.uri.toString(),
            message: item.message,
            startLineNumber: item.location.range.start.line + 1,
            startColumn: item.location.range.start.character + 1,
            endLineNumber: item.location.range.end.line + 1,
            endColumn: item.location.range.end.character + 1
        });
    }
    return relatedInformation;
}
function convertTags(tags) {
    if (!tags) {
        return undefined;
    }
    const markerTags = [];
    for (const tag of tags) {
        switch (tag) {
            case types.DiagnosticTag.Unnecessary:
                markerTags.push(types.MarkerTag.Unnecessary);
                break;
            case types.DiagnosticTag.Deprecated:
                markerTags.push(types.MarkerTag.Deprecated);
                break;
        }
    }
    return markerTags;
}
function fromHover(hover) {
    return {
        range: fromRange(hover.range),
        contents: fromManyMarkdown(hover.contents)
    };
}
exports.fromHover = fromHover;
function fromEvaluatableExpression(evaluatableExpression) {
    return {
        range: fromRange(evaluatableExpression.range),
        expression: evaluatableExpression.expression
    };
}
exports.fromEvaluatableExpression = fromEvaluatableExpression;
function fromInlineValue(inlineValue) {
    if (inlineValue instanceof types_impl_1.InlineValueText) {
        return {
            type: 'text',
            range: fromRange(inlineValue.range),
            text: inlineValue.text
        };
    }
    else if (inlineValue instanceof types_impl_1.InlineValueVariableLookup) {
        return {
            type: 'variable',
            range: fromRange(inlineValue.range),
            variableName: inlineValue.variableName,
            caseSensitiveLookup: inlineValue.caseSensitiveLookup
        };
    }
    else if (inlineValue instanceof types_impl_1.InlineValueEvaluatableExpression) {
        return {
            type: 'expression',
            range: fromRange(inlineValue.range),
            expression: inlineValue.expression
        };
    }
    else {
        throw new Error('Unknown InlineValue type');
    }
}
exports.fromInlineValue = fromInlineValue;
function toInlineValueContext(inlineValueContext) {
    const ivLocation = inlineValueContext.stoppedLocation;
    return {
        frameId: inlineValueContext.frameId,
        stoppedLocation: new types.Range(ivLocation.startLineNumber, ivLocation.startColumn, ivLocation.endLineNumber, ivLocation.endColumn)
    };
}
exports.toInlineValueContext = toInlineValueContext;
function fromLocation(location) {
    return {
        uri: location.uri,
        range: fromRange(location.range)
    };
}
exports.fromLocation = fromLocation;
function fromTextDocumentShowOptions(options) {
    if (options.selection) {
        return {
            ...options,
            selection: fromRange(options.selection),
        };
    }
    return options;
}
exports.fromTextDocumentShowOptions = fromTextDocumentShowOptions;
function fromDefinitionLink(definitionLink) {
    return {
        uri: definitionLink.targetUri,
        range: fromRange(definitionLink.targetRange),
        originSelectionRange: definitionLink.originSelectionRange ? fromRange(definitionLink.originSelectionRange) : undefined,
        targetSelectionRange: definitionLink.targetSelectionRange ? fromRange(definitionLink.targetSelectionRange) : undefined
    };
}
exports.fromDefinitionLink = fromDefinitionLink;
var DocumentLink;
(function (DocumentLink) {
    function from(link) {
        return {
            range: fromRange(link.range),
            url: link.target,
            tooltip: link.tooltip
        };
    }
    DocumentLink.from = from;
    function to(link) {
        let target = undefined;
        if (link.url) {
            try {
                target = typeof link.url === 'string' ? types_impl_1.URI.parse(link.url, true) : types_impl_1.URI.revive(link.url);
            }
            catch (err) {
                // ignore
            }
        }
        return new types.DocumentLink(toRange(link.range), target);
    }
    DocumentLink.to = to;
})(DocumentLink = exports.DocumentLink || (exports.DocumentLink = {}));
function fromDocumentHighlightKind(kind) {
    switch (kind) {
        case types.DocumentHighlightKind.Text: return model.DocumentHighlightKind.Text;
        case types.DocumentHighlightKind.Read: return model.DocumentHighlightKind.Read;
        case types.DocumentHighlightKind.Write: return model.DocumentHighlightKind.Write;
    }
    return model.DocumentHighlightKind.Text;
}
exports.fromDocumentHighlightKind = fromDocumentHighlightKind;
function fromDocumentHighlight(documentHighlight) {
    return {
        range: fromRange(documentHighlight.range),
        kind: fromDocumentHighlightKind(documentHighlight.kind)
    };
}
exports.fromDocumentHighlight = fromDocumentHighlight;
var ParameterInformation;
(function (ParameterInformation) {
    function from(info) {
        return {
            label: info.label,
            documentation: info.documentation ? fromMarkdown(info.documentation) : undefined
        };
    }
    ParameterInformation.from = from;
    function to(info) {
        return {
            label: info.label,
            documentation: markdown_rendering_1.MarkdownString.is(info.documentation) ? toMarkdown(info.documentation) : info.documentation
        };
    }
    ParameterInformation.to = to;
})(ParameterInformation = exports.ParameterInformation || (exports.ParameterInformation = {}));
var SignatureInformation;
(function (SignatureInformation) {
    function from(info) {
        return {
            label: info.label,
            documentation: info.documentation ? fromMarkdown(info.documentation) : undefined,
            parameters: info.parameters && info.parameters.map(ParameterInformation.from),
            activeParameter: info.activeParameter
        };
    }
    SignatureInformation.from = from;
    function to(info) {
        return {
            label: info.label,
            documentation: markdown_rendering_1.MarkdownString.is(info.documentation) ? toMarkdown(info.documentation) : info.documentation,
            parameters: info.parameters && info.parameters.map(ParameterInformation.to),
            activeParameter: info.activeParameter
        };
    }
    SignatureInformation.to = to;
})(SignatureInformation = exports.SignatureInformation || (exports.SignatureInformation = {}));
var SignatureHelp;
(function (SignatureHelp) {
    function from(id, help) {
        return {
            id,
            activeSignature: help.activeSignature,
            activeParameter: help.activeParameter,
            signatures: help.signatures && help.signatures.map(SignatureInformation.from)
        };
    }
    SignatureHelp.from = from;
    function to(help) {
        return {
            activeSignature: help.activeSignature,
            activeParameter: help.activeParameter,
            signatures: help.signatures && help.signatures.map(SignatureInformation.to)
        };
    }
    SignatureHelp.to = to;
})(SignatureHelp = exports.SignatureHelp || (exports.SignatureHelp = {}));
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function fromWorkspaceEdit(value, documents) {
    const result = {
        edits: []
    };
    for (const entry of value._allEntries()) {
        if ((entry === null || entry === void 0 ? void 0 : entry._type) === 2 /* Text */) {
            // text edits
            const doc = documents ? documents.getDocument(entry.uri.toString()) : undefined;
            const workspaceTextEditDto = {
                resource: entry.uri,
                modelVersionId: doc === null || doc === void 0 ? void 0 : doc.version,
                textEdit: (entry.edit instanceof types.TextEdit) ? fromTextEdit(entry.edit) : fromSnippetTextEdit(entry.edit),
                metadata: entry.metadata
            };
            result.edits.push(workspaceTextEditDto);
        }
        else if ((entry === null || entry === void 0 ? void 0 : entry._type) === 1 /* File */) {
            // resource edits
            const workspaceFileEditDto = {
                oldResource: entry.from,
                newResource: entry.to,
                options: entry.options,
                metadata: entry.metadata
            };
            result.edits.push(workspaceFileEditDto);
        }
        else if ((entry === null || entry === void 0 ? void 0 : entry._type) === 3 /* Cell */) {
            // cell edit
            if (entry.edit) {
                result.edits.push({
                    metadata: entry.metadata,
                    resource: entry.uri,
                    cellEdit: entry.edit,
                });
            }
        }
        else if ((entry === null || entry === void 0 ? void 0 : entry._type) === 5 /* CellReplace */) {
            // cell replace
            result.edits.push({
                metadata: entry.metadata,
                resource: entry.uri,
                cellEdit: {
                    editType: 1 /* Replace */,
                    index: entry.index,
                    count: entry.count,
                    cells: entry.cells.map(NotebookCellData.from)
                }
            });
        }
    }
    return result;
}
exports.fromWorkspaceEdit = fromWorkspaceEdit;
var SymbolKind;
(function (SymbolKind) {
    const fromMapping = Object.create(null);
    fromMapping[model.SymbolKind.File] = model.SymbolKind.File;
    fromMapping[model.SymbolKind.Module] = model.SymbolKind.Module;
    fromMapping[model.SymbolKind.Namespace] = model.SymbolKind.Namespace;
    fromMapping[model.SymbolKind.Package] = model.SymbolKind.Package;
    fromMapping[model.SymbolKind.Class] = model.SymbolKind.Class;
    fromMapping[model.SymbolKind.Method] = model.SymbolKind.Method;
    fromMapping[model.SymbolKind.Property] = model.SymbolKind.Property;
    fromMapping[model.SymbolKind.Field] = model.SymbolKind.Field;
    fromMapping[model.SymbolKind.Constructor] = model.SymbolKind.Constructor;
    fromMapping[model.SymbolKind.Enum] = model.SymbolKind.Enum;
    fromMapping[model.SymbolKind.Interface] = model.SymbolKind.Interface;
    fromMapping[model.SymbolKind.Function] = model.SymbolKind.Function;
    fromMapping[model.SymbolKind.Variable] = model.SymbolKind.Variable;
    fromMapping[model.SymbolKind.Constant] = model.SymbolKind.Constant;
    fromMapping[model.SymbolKind.String] = model.SymbolKind.String;
    fromMapping[model.SymbolKind.Number] = model.SymbolKind.Number;
    fromMapping[model.SymbolKind.Boolean] = model.SymbolKind.Boolean;
    fromMapping[model.SymbolKind.Array] = model.SymbolKind.Array;
    fromMapping[model.SymbolKind.Object] = model.SymbolKind.Object;
    fromMapping[model.SymbolKind.Key] = model.SymbolKind.Key;
    fromMapping[model.SymbolKind.Null] = model.SymbolKind.Null;
    fromMapping[model.SymbolKind.EnumMember] = model.SymbolKind.EnumMember;
    fromMapping[model.SymbolKind.Struct] = model.SymbolKind.Struct;
    fromMapping[model.SymbolKind.Event] = model.SymbolKind.Event;
    fromMapping[model.SymbolKind.Operator] = model.SymbolKind.Operator;
    fromMapping[model.SymbolKind.TypeParameter] = model.SymbolKind.TypeParameter;
    function fromSymbolKind(kind) {
        return fromMapping[kind] || model.SymbolKind.Property;
    }
    SymbolKind.fromSymbolKind = fromSymbolKind;
    function toSymbolKind(kind) {
        for (const k in fromMapping) {
            if (fromMapping[k] === kind) {
                return Number(k);
            }
        }
        return model.SymbolKind.Property;
    }
    SymbolKind.toSymbolKind = toSymbolKind;
})(SymbolKind = exports.SymbolKind || (exports.SymbolKind = {}));
function toCodeActionTriggerKind(triggerKind) {
    switch (triggerKind) {
        case model.CodeActionTriggerKind.Invoke:
            return types.CodeActionTriggerKind.Invoke;
        case model.CodeActionTriggerKind.Automatic:
            return types.CodeActionTriggerKind.Automatic;
    }
}
exports.toCodeActionTriggerKind = toCodeActionTriggerKind;
function fromDocumentSymbol(info) {
    const result = {
        name: info.name,
        detail: info.detail,
        range: fromRange(info.range),
        tags: info.tags ? info.tags.map(fromSymbolTag) : [],
        selectionRange: fromRange(info.selectionRange),
        kind: SymbolKind.fromSymbolKind(info.kind)
    };
    if (info.children) {
        result.children = info.children.map(fromDocumentSymbol);
    }
    return result;
}
exports.fromDocumentSymbol = fromDocumentSymbol;
function toDocumentSymbol(symbol) {
    return {
        name: symbol.name,
        detail: symbol.detail,
        range: toRange(symbol.range),
        tags: symbol.tags && symbol.tags.length > 0 ? symbol.tags.map(toSymbolTag) : [],
        selectionRange: toRange(symbol.selectionRange),
        children: symbol.children ? symbol.children.map(toDocumentSymbol) : [],
        kind: SymbolKind.toSymbolKind(symbol.kind)
    };
}
exports.toDocumentSymbol = toDocumentSymbol;
function fromSymbolTag(kind) {
    switch (kind) {
        case types.SymbolTag.Deprecated: return model.SymbolTag.Deprecated;
    }
}
exports.fromSymbolTag = fromSymbolTag;
function toSymbolTag(kind) {
    switch (kind) {
        case model.SymbolTag.Deprecated: return types.SymbolTag.Deprecated;
    }
}
exports.toSymbolTag = toSymbolTag;
function isModelLocation(arg) {
    return (0, common_1.isObject)(arg) &&
        isModelRange(arg.range) &&
        isUriComponents(arg.uri);
}
exports.isModelLocation = isModelLocation;
function isModelRange(arg) {
    return (0, common_1.isObject)(arg) &&
        typeof arg.startLineNumber === 'number' &&
        typeof arg.startColumn === 'number' &&
        typeof arg.endLineNumber === 'number' &&
        typeof arg.endColumn === 'number';
}
exports.isModelRange = isModelRange;
function isUriComponents(arg) {
    return (0, common_1.isObject)(arg) &&
        typeof arg.scheme === 'string' &&
        typeof arg.path === 'string' &&
        typeof arg.query === 'string' &&
        typeof arg.fragment === 'string';
}
exports.isUriComponents = isUriComponents;
function isModelCallHierarchyItem(arg) {
    return (0, common_1.isObject)(arg)
        && isModelRange(arg.range)
        && isModelRange(arg.selectionRange)
        && isUriComponents(arg.uri)
        && !!arg.name;
}
exports.isModelCallHierarchyItem = isModelCallHierarchyItem;
function isModelCallHierarchyIncomingCall(arg) {
    return (0, common_1.isObject)(arg) &&
        'from' in arg &&
        'fromRanges' in arg &&
        isModelCallHierarchyItem(arg.from);
}
exports.isModelCallHierarchyIncomingCall = isModelCallHierarchyIncomingCall;
function isModelCallHierarchyOutgoingCall(arg) {
    return (0, common_1.isObject)(arg) &&
        'to' in arg &&
        'fromRanges' in arg &&
        isModelCallHierarchyItem(arg.to);
}
exports.isModelCallHierarchyOutgoingCall = isModelCallHierarchyOutgoingCall;
function toLocation(value) {
    return new types.Location(types_impl_1.URI.revive(value.uri), toRange(value.range));
}
exports.toLocation = toLocation;
function fromHierarchyItem(item) {
    return {
        kind: SymbolKind.fromSymbolKind(item.kind),
        name: item.name,
        detail: item.detail,
        uri: item.uri,
        range: fromRange(item.range),
        selectionRange: fromRange(item.selectionRange),
        tags: item.tags,
        _itemId: item._itemId,
        _sessionId: item._sessionId,
    };
}
exports.fromHierarchyItem = fromHierarchyItem;
function fromCallHierarchyItem(item) {
    return fromHierarchyItem(item);
}
exports.fromCallHierarchyItem = fromCallHierarchyItem;
function toCallHierarchyItem(value) {
    const item = new types.CallHierarchyItem(SymbolKind.toSymbolKind(value.kind), value.name, value.detail ? value.detail : '', types_impl_1.URI.revive(value.uri), toRange(value.range), toRange(value.selectionRange));
    item.tags = value.tags;
    item._itemId = value._itemId;
    item._sessionId = value._sessionId;
    return item;
}
exports.toCallHierarchyItem = toCallHierarchyItem;
function toCallHierarchyIncomingCall(value) {
    return new types.CallHierarchyIncomingCall(toCallHierarchyItem(value.from), value.fromRanges && value.fromRanges.map(toRange));
}
exports.toCallHierarchyIncomingCall = toCallHierarchyIncomingCall;
function toCallHierarchyOutgoingCall(value) {
    return new types.CallHierarchyOutgoingCall(toCallHierarchyItem(value.to), value.fromRanges && value.fromRanges.map(toRange));
}
exports.toCallHierarchyOutgoingCall = toCallHierarchyOutgoingCall;
function isModelTypeHierarchyItem(arg) {
    return (0, common_1.isObject)(arg)
        && isModelRange(arg.range)
        && isModelRange(arg.selectionRange)
        && isUriComponents(arg.uri)
        && !!arg.name;
}
exports.isModelTypeHierarchyItem = isModelTypeHierarchyItem;
function fromTypeHierarchyItem(item) {
    return fromHierarchyItem(item);
}
exports.fromTypeHierarchyItem = fromTypeHierarchyItem;
function toTypeHierarchyItem(value) {
    const item = new types.TypeHierarchyItem(SymbolKind.toSymbolKind(value.kind), value.name, value.detail ? value.detail : '', types_impl_1.URI.revive(value.uri), toRange(value.selectionRange), toRange(value.range));
    item.tags = value.tags;
    item._itemId = value._itemId;
    item._sessionId = value._sessionId;
    return item;
}
exports.toTypeHierarchyItem = toTypeHierarchyItem;
function toWorkspaceFolder(folder) {
    return {
        uri: types_impl_1.URI.revive(folder.uri),
        name: folder.name,
        index: folder.index
    };
}
exports.toWorkspaceFolder = toWorkspaceFolder;
function fromTask(task) {
    if (!task) {
        return undefined;
    }
    const taskDto = {};
    taskDto.label = task.name;
    taskDto.source = task.source;
    taskDto.runOptions = { reevaluateOnRerun: task.runOptions.reevaluateOnRerun };
    if (task.hasProblemMatchers) {
        taskDto.problemMatcher = task.problemMatchers;
    }
    if ('detail' in task) {
        taskDto.detail = task.detail;
    }
    if (typeof task.scope === 'number') {
        taskDto.scope = task.scope;
    }
    else if (task.scope !== undefined) {
        taskDto.scope = task.scope.uri.toString();
    }
    else {
        taskDto.scope = types.TaskScope.Workspace;
    }
    if (task.presentationOptions) {
        taskDto.presentation = task.presentationOptions;
    }
    if (task.group) {
        taskDto.group = {
            kind: task.group.id,
            isDefault: !!task.group.isDefault
        };
    }
    const taskDefinition = task.definition;
    if (!taskDefinition) {
        return taskDto;
    }
    taskDto.type = taskDefinition.type;
    const { type, ...properties } = taskDefinition;
    for (const key in properties) {
        if (properties.hasOwnProperty(key)) {
            taskDto[key] = properties[key];
        }
    }
    const execution = task.execution;
    if (!execution) {
        return taskDto;
    }
    if (types.ShellExecution.is(execution)) {
        return fromShellExecution(execution, taskDto);
    }
    if (types.ProcessExecution.is(execution)) {
        return fromProcessExecution(execution, taskDto);
    }
    if (types.CustomExecution.is(execution)) {
        return fromCustomExecution(execution, taskDto);
    }
    return taskDto;
}
exports.fromTask = fromTask;
function toTask(taskDto) {
    if (!taskDto) {
        throw new Error('Task should be provided for converting');
    }
    const { type, taskType, label, source, scope, problemMatcher, detail, command, args, options, group, presentation, runOptions, ...properties } = taskDto;
    const result = {};
    result.name = label;
    result.source = source;
    result.runOptions = runOptions !== null && runOptions !== void 0 ? runOptions : {};
    if (detail) {
        result.detail = detail;
    }
    if (typeof scope === 'string') {
        const uri = types_impl_1.URI.parse(scope);
        result.scope = {
            uri,
            name: uri.toString(),
            index: 0
        };
    }
    else {
        result.scope = scope;
    }
    const taskDefinition = {
        type: type
    };
    result.definition = taskDefinition;
    if (taskType === 'process') {
        result.execution = getProcessExecution(taskDto);
    }
    const execution = { command, args, options };
    if (taskType === 'shell' || types.ShellExecution.is(execution)) {
        result.execution = getShellExecution(taskDto);
    }
    if (taskType === 'customExecution' || types.CustomExecution.is(execution)) {
        result.execution = getCustomExecution(taskDto);
        // if taskType is customExecution, we need to put all the information into taskDefinition,
        // because some parameters may be in taskDefinition.
        taskDefinition.label = label;
        taskDefinition.command = command;
        taskDefinition.args = args;
        taskDefinition.options = options;
    }
    if (group) {
        result.group = new types.TaskGroup(group.kind, group.kind, group.isDefault);
    }
    if (presentation) {
        result.presentationOptions = presentation;
    }
    if (!properties) {
        return result;
    }
    for (const key in properties) {
        if (properties.hasOwnProperty(key)) {
            taskDefinition[key] = properties[key];
        }
    }
    return result;
}
exports.toTask = toTask;
function fromProcessExecution(execution, taskDto) {
    taskDto.taskType = 'process';
    taskDto.command = execution.process;
    taskDto.args = execution.args;
    const options = execution.options;
    if (options) {
        taskDto.options = options;
    }
    return taskDto;
}
exports.fromProcessExecution = fromProcessExecution;
function fromShellExecution(execution, taskDto) {
    taskDto.taskType = 'shell';
    const options = execution.options;
    if (options) {
        taskDto.options = getShellExecutionOptions(options);
    }
    const commandLine = execution.commandLine;
    if (commandLine) {
        taskDto.command = commandLine;
        return taskDto;
    }
    if (execution.command) {
        taskDto.command = getCommand(execution.command);
        taskDto.args = getShellArgs(execution.args);
        return taskDto;
    }
    else {
        throw new Error('Command is undefined');
    }
}
exports.fromShellExecution = fromShellExecution;
function fromCustomExecution(execution, taskDto) {
    taskDto.taskType = 'customExecution';
    const callback = execution.callback;
    if (callback) {
        taskDto.callback = callback;
        return taskDto;
    }
    else {
        throw new Error('Converting CustomExecution callback is not implemented');
    }
}
exports.fromCustomExecution = fromCustomExecution;
function getProcessExecution(taskDto) {
    return new types.ProcessExecution(taskDto.command, taskDto.args || [], taskDto.options || {});
}
exports.getProcessExecution = getProcessExecution;
function getShellExecution(taskDto) {
    if (taskDto.command && Array.isArray(taskDto.args) && taskDto.args.length !== 0) {
        return new types.ShellExecution(taskDto.command, taskDto.args, taskDto.options || {});
    }
    return new types.ShellExecution(taskDto.command || taskDto.commandLine, taskDto.options || {});
}
exports.getShellExecution = getShellExecution;
function getCustomExecution(taskDto) {
    return new types.CustomExecution(taskDto.callback);
}
exports.getCustomExecution = getCustomExecution;
function getShellArgs(args) {
    if (!args || args.length === 0) {
        return [];
    }
    const element = args[0];
    if (typeof element === 'string') {
        return args;
    }
    const result = [];
    const shellQuotedArgs = args;
    shellQuotedArgs.forEach(arg => {
        result.push(arg.value);
    });
    return result;
}
exports.getShellArgs = getShellArgs;
function getCommand(command) {
    return typeof command === 'string' ? command : command.value;
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function getShellExecutionOptions(options) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const result = {};
    const env = options.env;
    if (env) {
        result['env'] = env;
    }
    const executable = options.executable;
    if (executable) {
        result['executable'] = executable;
    }
    const shellQuoting = options.shellQuoting;
    if (shellQuoting) {
        result['shellQuoting'] = shellQuoting;
    }
    const shellArgs = options.shellArgs;
    if (shellArgs) {
        result['shellArgs'] = shellArgs;
    }
    const cwd = options.cwd;
    if (cwd) {
        Object.assign(result, { cwd });
    }
    return result;
}
exports.getShellExecutionOptions = getShellExecutionOptions;
function fromSymbolInformation(symbolInformation) {
    if (!symbolInformation) {
        return undefined;
    }
    if (symbolInformation.location && symbolInformation.location.range) {
        const p1 = lstypes.Position.create(symbolInformation.location.range.start.line, symbolInformation.location.range.start.character);
        const p2 = lstypes.Position.create(symbolInformation.location.range.end.line, symbolInformation.location.range.end.character);
        return lstypes.SymbolInformation.create(symbolInformation.name, symbolInformation.kind++, lstypes.Range.create(p1, p2), symbolInformation.location.uri.toString(), symbolInformation.containerName);
    }
    return {
        name: symbolInformation.name,
        containerName: symbolInformation.containerName,
        kind: symbolInformation.kind++,
        location: {
            uri: symbolInformation.location.uri.toString(),
            range: symbolInformation.location.range,
        }
    };
}
exports.fromSymbolInformation = fromSymbolInformation;
function toSymbolInformation(symbolInformation) {
    if (!symbolInformation) {
        return undefined;
    }
    return {
        name: symbolInformation.name,
        containerName: symbolInformation.containerName,
        kind: symbolInformation.kind,
        location: {
            uri: types_impl_1.URI.parse(symbolInformation.location.uri),
            range: symbolInformation.location.range
        }
    };
}
exports.toSymbolInformation = toSymbolInformation;
function fromSelectionRange(selectionRange) {
    return { range: fromRange(selectionRange.range) };
}
exports.fromSelectionRange = fromSelectionRange;
function fromFoldingRange(foldingRange) {
    const range = {
        start: foldingRange.start + 1,
        end: foldingRange.end + 1
    };
    if (foldingRange.kind) {
        range.kind = fromFoldingRangeKind(foldingRange.kind);
    }
    return range;
}
exports.fromFoldingRange = fromFoldingRange;
function fromFoldingRangeKind(kind) {
    if (kind) {
        switch (kind) {
            case types.FoldingRangeKind.Comment:
                return model.FoldingRangeKind.Comment;
            case types.FoldingRangeKind.Imports:
                return model.FoldingRangeKind.Imports;
            case types.FoldingRangeKind.Region:
                return model.FoldingRangeKind.Region;
        }
    }
    return undefined;
}
exports.fromFoldingRangeKind = fromFoldingRangeKind;
function fromColor(color) {
    return [color.red, color.green, color.blue, color.alpha];
}
exports.fromColor = fromColor;
function toColor(color) {
    return new types.Color(color[0], color[1], color[2], color[3]);
}
exports.toColor = toColor;
function fromColorPresentation(colorPresentation) {
    return {
        label: colorPresentation.label,
        textEdit: colorPresentation.textEdit ? fromTextEdit(colorPresentation.textEdit) : undefined,
        additionalTextEdits: colorPresentation.additionalTextEdits ? colorPresentation.additionalTextEdits.map(value => fromTextEdit(value)) : undefined
    };
}
exports.fromColorPresentation = fromColorPresentation;
function convertToTransferQuickPickItems(items) {
    return items.map((item, index) => {
        if (typeof item === 'string') {
            return { type: 'item', label: item, handle: index };
        }
        else if (item.kind === types_impl_1.QuickPickItemKind.Separator) {
            return { type: 'separator', label: item.label, handle: index };
        }
        else {
            const { label, description, detail, picked, alwaysShow, buttons } = item;
            return {
                type: 'item',
                label,
                description,
                detail,
                picked,
                alwaysShow,
                buttons,
                handle: index,
            };
        }
    });
}
exports.convertToTransferQuickPickItems = convertToTransferQuickPickItems;
var DecorationRenderOptions;
(function (DecorationRenderOptions) {
    function from(options) {
        return {
            isWholeLine: options.isWholeLine,
            rangeBehavior: options.rangeBehavior ? DecorationRangeBehavior.from(options.rangeBehavior) : undefined,
            overviewRulerLane: options.overviewRulerLane,
            light: options.light ? ThemableDecorationRenderOptions.from(options.light) : undefined,
            dark: options.dark ? ThemableDecorationRenderOptions.from(options.dark) : undefined,
            backgroundColor: options.backgroundColor,
            outline: options.outline,
            outlineColor: options.outlineColor,
            outlineStyle: options.outlineStyle,
            outlineWidth: options.outlineWidth,
            border: options.border,
            borderColor: options.borderColor,
            borderRadius: options.borderRadius,
            borderSpacing: options.borderSpacing,
            borderStyle: options.borderStyle,
            borderWidth: options.borderWidth,
            fontStyle: options.fontStyle,
            fontWeight: options.fontWeight,
            textDecoration: options.textDecoration,
            cursor: options.cursor,
            color: options.color,
            opacity: options.opacity,
            letterSpacing: options.letterSpacing,
            gutterIconPath: options.gutterIconPath ? pathOrURIToURI(options.gutterIconPath) : undefined,
            gutterIconSize: options.gutterIconSize,
            overviewRulerColor: options.overviewRulerColor,
            before: options.before ? ThemableDecorationAttachmentRenderOptions.from(options.before) : undefined,
            after: options.after ? ThemableDecorationAttachmentRenderOptions.from(options.after) : undefined,
        };
    }
    DecorationRenderOptions.from = from;
})(DecorationRenderOptions = exports.DecorationRenderOptions || (exports.DecorationRenderOptions = {}));
var DecorationRangeBehavior;
(function (DecorationRangeBehavior) {
    function from(value) {
        if (typeof value === 'undefined') {
            return value;
        }
        switch (value) {
            case types.DecorationRangeBehavior.OpenOpen:
                return rpc.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges;
            case types.DecorationRangeBehavior.ClosedClosed:
                return rpc.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges;
            case types.DecorationRangeBehavior.OpenClosed:
                return rpc.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore;
            case types.DecorationRangeBehavior.ClosedOpen:
                return rpc.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter;
        }
    }
    DecorationRangeBehavior.from = from;
})(DecorationRangeBehavior = exports.DecorationRangeBehavior || (exports.DecorationRangeBehavior = {}));
var ThemableDecorationRenderOptions;
(function (ThemableDecorationRenderOptions) {
    function from(options) {
        if (typeof options === 'undefined') {
            return options;
        }
        return {
            backgroundColor: options.backgroundColor,
            outline: options.outline,
            outlineColor: options.outlineColor,
            outlineStyle: options.outlineStyle,
            outlineWidth: options.outlineWidth,
            border: options.border,
            borderColor: options.borderColor,
            borderRadius: options.borderRadius,
            borderSpacing: options.borderSpacing,
            borderStyle: options.borderStyle,
            borderWidth: options.borderWidth,
            fontStyle: options.fontStyle,
            fontWeight: options.fontWeight,
            textDecoration: options.textDecoration,
            cursor: options.cursor,
            color: options.color,
            opacity: options.opacity,
            letterSpacing: options.letterSpacing,
            gutterIconPath: options.gutterIconPath ? pathOrURIToURI(options.gutterIconPath) : undefined,
            gutterIconSize: options.gutterIconSize,
            overviewRulerColor: options.overviewRulerColor,
            before: options.before ? ThemableDecorationAttachmentRenderOptions.from(options.before) : undefined,
            after: options.after ? ThemableDecorationAttachmentRenderOptions.from(options.after) : undefined,
        };
    }
    ThemableDecorationRenderOptions.from = from;
})(ThemableDecorationRenderOptions = exports.ThemableDecorationRenderOptions || (exports.ThemableDecorationRenderOptions = {}));
var ThemableDecorationAttachmentRenderOptions;
(function (ThemableDecorationAttachmentRenderOptions) {
    function from(options) {
        if (typeof options === 'undefined') {
            return options;
        }
        return {
            contentText: options.contentText,
            contentIconPath: options.contentIconPath ? pathOrURIToURI(options.contentIconPath) : undefined,
            border: options.border,
            borderColor: options.borderColor,
            fontStyle: options.fontStyle,
            fontWeight: options.fontWeight,
            textDecoration: options.textDecoration,
            color: options.color,
            backgroundColor: options.backgroundColor,
            margin: options.margin,
            width: options.width,
            height: options.height,
        };
    }
    ThemableDecorationAttachmentRenderOptions.from = from;
})(ThemableDecorationAttachmentRenderOptions = exports.ThemableDecorationAttachmentRenderOptions || (exports.ThemableDecorationAttachmentRenderOptions = {}));
var ViewColumn;
(function (ViewColumn) {
    function from(column) {
        if (typeof column === 'number' && column >= types.ViewColumn.One) {
            return column - 1; // adjust zero index (ViewColumn.ONE => 0)
        }
        if (column === types.ViewColumn.Beside) {
            return SIDE_GROUP;
        }
        return ACTIVE_GROUP; // default is always the active group
    }
    ViewColumn.from = from;
    function to(position) {
        if (typeof position === 'number' && position >= 0) {
            return position + 1; // adjust to index (ViewColumn.ONE => 1)
        }
        throw new Error('invalid \'EditorGroupColumn\'');
    }
    ViewColumn.to = to;
})(ViewColumn = exports.ViewColumn || (exports.ViewColumn = {}));
function pathOrURIToURI(value) {
    if (typeof value === 'undefined') {
        return value;
    }
    if (typeof value === 'string') {
        return types_impl_1.URI.file(value);
    }
    else {
        return value;
    }
}
exports.pathOrURIToURI = pathOrURIToURI;
function pluginToPluginInfo(plugin) {
    return {
        id: plugin.model.id,
        name: plugin.model.name,
        displayName: plugin.model.displayName
    };
}
exports.pluginToPluginInfo = pluginToPluginInfo;
var InlayHintKind;
(function (InlayHintKind) {
    function from(kind) {
        return kind;
    }
    InlayHintKind.from = from;
    function to(kind) {
        return kind;
    }
    InlayHintKind.to = to;
})(InlayHintKind = exports.InlayHintKind || (exports.InlayHintKind = {}));
var DataTransferItem;
(function (DataTransferItem) {
    function to(mime, item, resolveFileData) {
        const file = item.fileData;
        if (file) {
            return new class extends types.DataTransferItem {
                asFile() {
                    return {
                        name: file.name,
                        uri: types_impl_1.URI.revive(file.uri),
                        data: () => resolveFileData(item.id),
                    };
                }
            }('');
        }
        if (mime === 'text/uri-list' && item.uriListData) {
            return new types.DataTransferItem(reviveUriList(item.uriListData));
        }
        return new types.DataTransferItem(item.asString);
    }
    DataTransferItem.to = to;
    function reviveUriList(parts) {
        return parts.map(part => typeof part === 'string' ? part : types_impl_1.URI.revive(part).toString()).join('\r\n');
    }
})(DataTransferItem = exports.DataTransferItem || (exports.DataTransferItem = {}));
var DataTransfer;
(function (DataTransfer) {
    function toDataTransfer(value, resolveFileData) {
        const dataTransfer = new types.DataTransfer();
        for (const [mimeType, item] of value.items) {
            dataTransfer.set(mimeType, DataTransferItem.to(mimeType, item, resolveFileData));
        }
        return dataTransfer;
    }
    DataTransfer.toDataTransfer = toDataTransfer;
})(DataTransfer = exports.DataTransfer || (exports.DataTransfer = {}));
var NotebookDocumentContentOptions;
(function (NotebookDocumentContentOptions) {
    function from(options) {
        var _a, _b, _c;
        return {
            transientOutputs: (_a = options === null || options === void 0 ? void 0 : options.transientOutputs) !== null && _a !== void 0 ? _a : false,
            transientCellMetadata: (_b = options === null || options === void 0 ? void 0 : options.transientCellMetadata) !== null && _b !== void 0 ? _b : {},
            transientDocumentMetadata: (_c = options === null || options === void 0 ? void 0 : options.transientDocumentMetadata) !== null && _c !== void 0 ? _c : {},
        };
    }
    NotebookDocumentContentOptions.from = from;
})(NotebookDocumentContentOptions = exports.NotebookDocumentContentOptions || (exports.NotebookDocumentContentOptions = {}));
var NotebookStatusBarItem;
(function (NotebookStatusBarItem) {
    function from(item, commandsConverter, disposables) {
        const command = typeof item.command === 'string' ? { title: '', command: item.command } : item.command;
        return {
            alignment: item.alignment === types.NotebookCellStatusBarAlignment.Left ? 1 /* Left */ : 2 /* Right */,
            command: commandsConverter.toSafeCommand(command, disposables),
            text: item.text,
            tooltip: item.tooltip,
            priority: item.priority
        };
    }
    NotebookStatusBarItem.from = from;
})(NotebookStatusBarItem = exports.NotebookStatusBarItem || (exports.NotebookStatusBarItem = {}));
var NotebookData;
(function (NotebookData) {
    function from(data) {
        var _a;
        const res = {
            metadata: (_a = data.metadata) !== null && _a !== void 0 ? _a : Object.create(null),
            cells: [],
        };
        for (const cell of data.cells) {
            // types.NotebookCellData.validate(cell);
            res.cells.push(NotebookCellData.from(cell));
        }
        return res;
    }
    NotebookData.from = from;
    function to(data) {
        const res = new types.NotebookData(data.cells.map(NotebookCellData.to));
        if (!(0, common_1.isEmptyObject)(data.metadata)) {
            res.metadata = data.metadata;
        }
        return res;
    }
    NotebookData.to = to;
})(NotebookData = exports.NotebookData || (exports.NotebookData = {}));
var NotebookCellData;
(function (NotebookCellData) {
    function from(data) {
        return {
            cellKind: NotebookCellKind.from(data.kind),
            language: data.languageId,
            source: data.value,
            // metadata: data.metadata,
            // internalMetadata: NotebookCellExecutionSummary.from(data.executionSummary ?? {}),
            outputs: data.outputs ? data.outputs.map(NotebookCellOutputConverter.from) : []
        };
    }
    NotebookCellData.from = from;
    function to(data) {
        return new types.NotebookCellData(NotebookCellKind.to(data.cellKind), data.source, data.language, data.outputs ? data.outputs.map(NotebookCellOutput.to) : undefined, data.metadata, data.internalMetadata ? NotebookCellExecutionSummary.to(data.internalMetadata) : undefined);
    }
    NotebookCellData.to = to;
})(NotebookCellData = exports.NotebookCellData || (exports.NotebookCellData = {}));
var NotebookCellKind;
(function (NotebookCellKind) {
    function from(data) {
        switch (data) {
            case types.NotebookCellKind.Markup:
                return notebooks.CellKind.Markup;
            case types.NotebookCellKind.Code:
            default:
                return notebooks.CellKind.Code;
        }
    }
    NotebookCellKind.from = from;
    function to(data) {
        switch (data) {
            case notebooks.CellKind.Markup:
                return types.NotebookCellKind.Markup;
            case notebooks.CellKind.Code:
            default:
                return types.NotebookCellKind.Code;
        }
    }
    NotebookCellKind.to = to;
})(NotebookCellKind = exports.NotebookCellKind || (exports.NotebookCellKind = {}));
var NotebookCellOutput;
(function (NotebookCellOutput) {
    function from(output) {
        return {
            outputId: output.outputId,
            items: output.items.map(NotebookCellOutputItem.from),
            metadata: output.metadata
        };
    }
    NotebookCellOutput.from = from;
    function to(output) {
        const items = output.items.map(NotebookCellOutputItem.to);
        return new types.NotebookCellOutput(items, output.outputId, output.metadata);
    }
    NotebookCellOutput.to = to;
})(NotebookCellOutput = exports.NotebookCellOutput || (exports.NotebookCellOutput = {}));
var NotebookCellOutputItem;
(function (NotebookCellOutputItem) {
    function from(item) {
        return {
            mime: item.mime,
            valueBytes: buffer_1.BinaryBuffer.wrap(item.data),
        };
    }
    NotebookCellOutputItem.from = from;
    function to(item) {
        return new types.NotebookCellOutputItem(item.valueBytes.buffer, item.mime);
    }
    NotebookCellOutputItem.to = to;
})(NotebookCellOutputItem = exports.NotebookCellOutputItem || (exports.NotebookCellOutputItem = {}));
var NotebookCellOutputConverter;
(function (NotebookCellOutputConverter) {
    function from(output) {
        return {
            outputId: output.outputId,
            items: output.items.map(NotebookCellOutputItem.from),
            metadata: output.metadata
        };
    }
    NotebookCellOutputConverter.from = from;
    function to(output) {
        const items = output.items.map(NotebookCellOutputItem.to);
        return new types.NotebookCellOutput(items, output.outputId, output.metadata);
    }
    NotebookCellOutputConverter.to = to;
    function ensureUniqueMimeTypes(items, warn = false) {
        const seen = new Set();
        const removeIdx = new Set();
        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            // We can have multiple text stream mime types in the same output.
            if (!seen.has(item.mime) || (0, common_2.isTextStreamMime)(item.mime)) {
                seen.add(item.mime);
                continue;
            }
            // duplicated mime types... first has won
            removeIdx.add(i);
            if (warn) {
                console.warn(`DUPLICATED mime type '${item.mime}' will be dropped`);
            }
        }
        if (removeIdx.size === 0) {
            return items;
        }
        return items.filter((_, index) => !removeIdx.has(index));
    }
    NotebookCellOutputConverter.ensureUniqueMimeTypes = ensureUniqueMimeTypes;
})(NotebookCellOutputConverter = exports.NotebookCellOutputConverter || (exports.NotebookCellOutputConverter = {}));
var NotebookCellExecutionSummary;
(function (NotebookCellExecutionSummary) {
    function to(data) {
        return {
            timing: typeof data.runStartTime === 'number' && typeof data.runEndTime === 'number' ? { startTime: data.runStartTime, endTime: data.runEndTime } : undefined,
            executionOrder: data.executionOrder,
            success: data.lastRunSuccess
        };
    }
    NotebookCellExecutionSummary.to = to;
    function from(data) {
        var _a, _b;
        return {
            lastRunSuccess: data.success,
            runStartTime: (_a = data.timing) === null || _a === void 0 ? void 0 : _a.startTime,
            runEndTime: (_b = data.timing) === null || _b === void 0 ? void 0 : _b.endTime,
            executionOrder: data.executionOrder
        };
    }
    NotebookCellExecutionSummary.from = from;
})(NotebookCellExecutionSummary = exports.NotebookCellExecutionSummary || (exports.NotebookCellExecutionSummary = {}));
var NotebookRange;
(function (NotebookRange) {
    function from(range) {
        return { start: range.start, end: range.end };
    }
    NotebookRange.from = from;
    function to(range) {
        return new types.NotebookRange(range.start, range.end);
    }
    NotebookRange.to = to;
})(NotebookRange = exports.NotebookRange || (exports.NotebookRange = {}));
var NotebookKernelSourceAction;
(function (NotebookKernelSourceAction) {
    function from(item, commandsConverter, disposables) {
        const command = typeof item.command === 'string' ? { title: '', command: item.command } : item.command;
        return {
            command: commandsConverter.toSafeCommand(command, disposables),
            label: item.label,
            description: item.description,
            detail: item.detail,
            documentation: item.documentation
        };
    }
    NotebookKernelSourceAction.from = from;
})(NotebookKernelSourceAction = exports.NotebookKernelSourceAction || (exports.NotebookKernelSourceAction = {}));
var NotebookDto;
(function (NotebookDto) {
    function toNotebookOutputItemDto(item) {
        return {
            mime: item.mime,
            valueBytes: item.data
        };
    }
    NotebookDto.toNotebookOutputItemDto = toNotebookOutputItemDto;
    function toNotebookOutputDto(output) {
        return {
            outputId: output.outputId,
            metadata: output.metadata,
            items: output.outputs.map(toNotebookOutputItemDto)
        };
    }
    NotebookDto.toNotebookOutputDto = toNotebookOutputDto;
    function toNotebookCellDataDto(cell) {
        return {
            cellKind: cell.cellKind,
            language: cell.language,
            source: cell.source,
            internalMetadata: cell.internalMetadata,
            metadata: cell.metadata,
            outputs: cell.outputs.map(toNotebookOutputDto)
        };
    }
    NotebookDto.toNotebookCellDataDto = toNotebookCellDataDto;
    // export function toNotebookDataDto(data: NotebookData): rpc.NotebookDataDto {
    //     return {
    //         metadata: data.metadata,
    //         cells: data.cells.map(toNotebookCellDataDto)
    //     };
    // }
    function fromNotebookOutputItemDto(item) {
        return {
            mime: item.mime,
            data: item.valueBytes
        };
    }
    NotebookDto.fromNotebookOutputItemDto = fromNotebookOutputItemDto;
    function fromNotebookOutputDto(output) {
        return {
            outputId: output.outputId,
            metadata: output.metadata,
            outputs: output.items.map(fromNotebookOutputItemDto)
        };
    }
    NotebookDto.fromNotebookOutputDto = fromNotebookOutputDto;
    function fromNotebookCellDataDto(cell) {
        return {
            cellKind: cell.cellKind,
            language: cell.language,
            source: cell.source,
            outputs: cell.outputs.map(fromNotebookOutputDto),
            metadata: cell.metadata,
            internalMetadata: cell.internalMetadata
        };
    }
    NotebookDto.fromNotebookCellDataDto = fromNotebookCellDataDto;
    // export function fromNotebookDataDto(data: rpc.NotebookDataDto): NotebookData {
    //     return {
    //         metadata: data.metadata,
    //         cells: data.cells.map(fromNotebookCellDataDto)
    //     };
    // }
    // export function toNotebookCellDto(cell: Cell): rpc.NotebookCellDto {
    //     return {
    //         handle: cell.handle,
    //         uri: cell.uri,
    //         source: cell.textBuffer.getLinesContent(),
    //         eol: cell.textBuffer.getEOL(),
    //         language: cell.language,
    //         cellKind: cell.cellKind,
    //         outputs: cell.outputs.map(toNotebookOutputDto),
    //         metadata: cell.metadata,
    //         internalMetadata: cell.internalMetadata,
    //     };
    // }
    function fromCellExecuteUpdateDto(data) {
        if (data.editType === common_2.CellExecutionUpdateType.Output) {
            return {
                editType: data.editType,
                cellHandle: data.cellHandle,
                append: data.append,
                outputs: data.outputs.map(fromNotebookOutputDto)
            };
        }
        else if (data.editType === common_2.CellExecutionUpdateType.OutputItems) {
            return {
                editType: data.editType,
                append: data.append,
                items: data.items.map(fromNotebookOutputItemDto)
            };
        }
        else {
            return data;
        }
    }
    NotebookDto.fromCellExecuteUpdateDto = fromCellExecuteUpdateDto;
    function fromCellExecuteCompleteDto(data) {
        return data;
    }
    NotebookDto.fromCellExecuteCompleteDto = fromCellExecuteCompleteDto;
    // export function fromCellEditOperationDto(edit: rpc.CellEditOperationDto): CellEditOperation {
    //     if (edit.editType === CellEditType.Replace) {
    //         return {
    //             editType: edit.editType,
    //             index: edit.index,
    //             count: edit.count,
    //             cells: edit.cells.map(fromNotebookCellDataDto)
    //         };
    //     } else {
    //         return edit;
    //     }
    // }
})(NotebookDto = exports.NotebookDto || (exports.NotebookDto = {}));


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/webview-views.js":
/*!*************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/webview-views.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 SAP SE or an SAP affiliate company and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/
// some of the code is copied and modified from https://github.com/microsoft/vscode/blob/e1f0f8f51390dea5df9096718fb6b647ed5a9534/src/vs/workbench/api/common/extHostWebviewView.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebviewViewExtImpl = exports.WebviewViewsExtImpl = void 0;
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../packages/core/lib/common/event.js");
class WebviewViewsExtImpl {
    constructor(rpc, webviewsExt) {
        this.webviewsExt = webviewsExt;
        this.viewProviders = new Map();
        this.webviewViews = new Map();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.WEBVIEW_VIEWS_MAIN);
    }
    registerWebviewViewProvider(viewType, provider, plugin, webviewOptions) {
        if (this.viewProviders.has(viewType)) {
            throw new Error(`View provider for '${viewType}' already registered`);
        }
        this.viewProviders.set(viewType, { provider: provider, plugin: plugin });
        this.proxy.$registerWebviewViewProvider(viewType, {
            retainContextWhenHidden: webviewOptions === null || webviewOptions === void 0 ? void 0 : webviewOptions.retainContextWhenHidden,
            serializeBuffersForPostMessage: false,
        });
        return new types_impl_1.Disposable(() => {
            this.viewProviders.delete(viewType);
            this.proxy.$unregisterWebviewViewProvider(viewType);
        });
    }
    async $resolveWebviewView(handle, viewType, title, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    state, cancellation) {
        const entry = this.viewProviders.get(viewType);
        if (!entry) {
            throw new Error(`No view provider found for '${viewType}'`);
        }
        const { provider, plugin } = entry;
        const webviewNoPanel = this.webviewsExt.createNewWebview({}, plugin, handle);
        const revivedView = new WebviewViewExtImpl(handle, this.proxy, viewType, title, webviewNoPanel, true);
        this.webviewViews.set(handle, revivedView);
        await provider.resolveWebviewView(revivedView, { state }, cancellation);
    }
    async $onDidChangeWebviewViewVisibility(handle, visible) {
        const webviewView = this.getWebviewView(handle);
        webviewView.setVisible(visible);
        webviewView.onDidChangeVisibilityEmitter.fire();
    }
    async $disposeWebviewView(handle) {
        const webviewView = this.getWebviewView(handle);
        this.webviewViews.delete(handle);
        webviewView.dispose();
        this.webviewsExt.deleteWebview(handle);
    }
    getWebviewView(handle) {
        const entry = this.webviewViews.get(handle);
        if (!entry) {
            throw new Error('No webview found');
        }
        return entry;
    }
}
exports.WebviewViewsExtImpl = WebviewViewsExtImpl;
class WebviewViewExtImpl {
    constructor(handle, proxy, viewType, title, webview, isVisible) {
        this.onDidChangeVisibilityEmitter = new event_1.Emitter();
        this.onDidChangeVisibility = this.onDidChangeVisibilityEmitter.event;
        this.onDidDisposeEmitter = new event_1.Emitter();
        this.onDidDispose = this.onDidDisposeEmitter.event;
        this._isDisposed = false;
        this._viewType = viewType;
        this._title = title;
        this.handle = handle;
        this.proxy = proxy;
        this._webview = webview;
        this._isVisible = isVisible;
    }
    dispose() {
        if (this._isDisposed) {
            return;
        }
        this._isDisposed = true;
        this.onDidDisposeEmitter.fire();
    }
    get title() {
        this.assertNotDisposed();
        return this._title;
    }
    set title(value) {
        this.assertNotDisposed();
        if (this._title !== value) {
            this._title = value;
            this.proxy.$setWebviewViewTitle(this.handle, value);
        }
    }
    get description() {
        this.assertNotDisposed();
        return this._description;
    }
    set description(value) {
        this.assertNotDisposed();
        if (this._description !== value) {
            this._description = value;
            this.proxy.$setWebviewViewDescription(this.handle, value);
        }
    }
    get badge() {
        this.assertNotDisposed();
        return this._badge;
    }
    set badge(badge) {
        this.assertNotDisposed();
        if (this._badge !== badge) {
            this._badge = badge;
            this.proxy.$setBadge(this.handle, badge ? { value: badge.value, tooltip: badge.tooltip } : undefined);
        }
    }
    get visible() { return this._isVisible; }
    get webview() { return this._webview; }
    get viewType() { return this._viewType; }
    setVisible(visible) {
        if (visible === this._isVisible || this._isDisposed) {
            return;
        }
        this._isVisible = visible;
        this.onDidChangeVisibilityEmitter.fire();
    }
    show(preserveFocus) {
        this.assertNotDisposed();
        this.proxy.$show(this.handle, !!preserveFocus);
    }
    assertNotDisposed() {
        if (this._isDisposed) {
            throw new Error('Webview is disposed');
        }
    }
}
exports.WebviewViewExtImpl = WebviewViewExtImpl;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/webviews.js":
/*!********************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/webviews.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebviewPanelImpl = exports.WebviewImpl = exports.WebviewsExtImpl = void 0;
const uuid_1 = __webpack_require__(/*! uuid */ "../../node_modules/uuid/dist/esm-node/index.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../packages/core/lib/common/event.js");
const type_converters_1 = __webpack_require__(/*! ./type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const plugin_icon_path_1 = __webpack_require__(/*! ./plugin-icon-path */ "../../packages/plugin-ext/lib/plugin/plugin-icon-path.js");
class WebviewsExtImpl {
    constructor(rpc, workspace) {
        this.workspace = workspace;
        this.webviewPanels = new Map();
        this.webviews = new Map();
        this.serializers = new Map();
        this.onDidDisposeEmitter = new event_1.Emitter();
        this.onDidDispose = this.onDidDisposeEmitter.event;
        this.proxy = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.WEBVIEWS_MAIN);
    }
    init(initData) {
        this.initData = initData;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    $onMessage(handle, message) {
        const panel = this.getWebviewPanel(handle);
        if (panel) {
            panel.webview.onMessageEmitter.fire(message);
        }
        else {
            const webview = this.getWebview(handle);
            if (webview) {
                webview.onMessageEmitter.fire(message);
            }
        }
    }
    $onDidChangeWebviewPanelViewState(handle, newState) {
        const panel = this.getWebviewPanel(handle);
        if (panel) {
            const viewColumn = (0, type_converters_1.toViewColumn)(newState.position);
            if (panel.active !== newState.active || panel.visible !== newState.visible || panel.viewColumn !== viewColumn) {
                panel.setActive(newState.active);
                panel.setVisible(newState.visible);
                panel.setViewColumn(viewColumn);
                panel.onDidChangeViewStateEmitter.fire({ webviewPanel: panel });
            }
        }
    }
    $onDidDisposeWebviewPanel(handle) {
        const panel = this.getWebviewPanel(handle);
        if (panel) {
            panel.dispose();
            this.webviewPanels.delete(handle);
        }
        return Promise.resolve();
    }
    $deserializeWebviewPanel(viewId, viewType, title, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    state, viewState, options) {
        if (!this.initData) {
            return Promise.reject(new Error('Webviews are not initialized'));
        }
        const entry = this.serializers.get(viewType);
        if (!entry) {
            return Promise.reject(new Error(`No serializer found for '${viewType}'`));
        }
        const { serializer, plugin } = entry;
        const webview = new WebviewImpl(viewId, this.proxy, options, this.initData, this.workspace, plugin);
        const revivedPanel = new WebviewPanelImpl(viewId, this.proxy, viewType, title, (0, type_converters_1.toViewColumn)(viewState.position), options, webview);
        revivedPanel.setActive(viewState.active);
        revivedPanel.setVisible(viewState.visible);
        this.webviewPanels.set(viewId, revivedPanel);
        return serializer.deserializeWebviewPanel(revivedPanel, state);
    }
    createWebview(viewType, title, showOptions, options, plugin) {
        const viewId = (0, uuid_1.v4)();
        const webviewShowOptions = (0, type_converters_1.toWebviewPanelShowOptions)(showOptions);
        const webviewOptions = WebviewImpl.toWebviewOptions(options, this.workspace, plugin);
        this.proxy.$createWebviewPanel(viewId, viewType, title, webviewShowOptions, webviewOptions);
        const panel = this.createWebviewPanel(viewType, title, showOptions, options, plugin, viewId);
        return panel;
    }
    createWebviewPanel(viewType, title, showOptions, options, plugin, viewId) {
        if (!this.initData) {
            throw new Error('Webviews are not initialized');
        }
        const webviewShowOptions = (0, type_converters_1.toWebviewPanelShowOptions)(showOptions);
        const webview = new WebviewImpl(viewId, this.proxy, options, this.initData, this.workspace, plugin);
        const panel = new WebviewPanelImpl(viewId, this.proxy, viewType, title, webviewShowOptions, options, webview);
        this.webviewPanels.set(viewId, panel);
        return panel;
    }
    createNewWebview(options, plugin, viewId) {
        if (!this.initData) {
            throw new Error('Webviews are not initialized');
        }
        const webview = new WebviewImpl(viewId, this.proxy, options, this.initData, this.workspace, plugin);
        this.webviews.set(viewId, webview);
        return webview;
    }
    registerWebviewPanelSerializer(viewType, serializer, plugin) {
        if (this.serializers.has(viewType)) {
            throw new Error(`Serializer for '${viewType}' already registered`);
        }
        this.serializers.set(viewType, { serializer, plugin });
        this.proxy.$registerSerializer(viewType);
        return new types_impl_1.Disposable(() => {
            this.serializers.delete(viewType);
            this.proxy.$unregisterSerializer(viewType);
        });
    }
    getWebviewPanel(viewId) {
        if (this.webviewPanels.has(viewId)) {
            return this.webviewPanels.get(viewId);
        }
        return undefined;
    }
    deleteWebview(handle) {
        this.webviews.delete(handle);
    }
    getWebview(handle) {
        return this.webviews.get(handle);
    }
}
exports.WebviewsExtImpl = WebviewsExtImpl;
class WebviewImpl {
    constructor(viewId, proxy, options, initData, workspace, plugin) {
        this.viewId = viewId;
        this.proxy = proxy;
        this.initData = initData;
        this.workspace = workspace;
        this.plugin = plugin;
        this.isDisposed = false;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.onMessageEmitter = new event_1.Emitter();
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.onDidReceiveMessage = this.onMessageEmitter.event;
        this._options = options;
    }
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this.isDisposed = true;
        this.onMessageEmitter.dispose();
    }
    asWebviewUri(resource) {
        const uri = this.initData.webviewResourceRoot
            .replace('{{scheme}}', resource.scheme)
            .replace('{{authority}}', resource.authority)
            .replace('{{path}}', resource.path.replace(/^\//, ''))
            .replace('{{uuid}}', this.viewId);
        return types_impl_1.URI.parse(uri);
    }
    get cspSource() {
        return this.initData.webviewCspSource.replace('{{uuid}}', this.viewId);
    }
    get html() {
        this.checkIsDisposed();
        return this._html;
    }
    set html(value) {
        this.checkIsDisposed();
        if (this._html !== value) {
            this._html = value;
            this.proxy.$setHtml(this.viewId, this._html);
        }
    }
    get options() {
        this.checkIsDisposed();
        return this._options;
    }
    set options(newOptions) {
        this.checkIsDisposed();
        this.proxy.$setOptions(this.viewId, WebviewImpl.toWebviewOptions(newOptions, this.workspace, this.plugin));
        this._options = newOptions;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    postMessage(message) {
        this.checkIsDisposed();
        return this.proxy.$postMessage(this.viewId, message);
    }
    checkIsDisposed() {
        if (this.isDisposed) {
            throw new Error('This Webview is disposed!');
        }
    }
    static toWebviewOptions(options, workspace, plugin) {
        return {
            ...options,
            localResourceRoots: options.localResourceRoots || [
                ...(workspace.workspaceFolders || []).map(x => x.uri),
                types_impl_1.URI.file(plugin.pluginFolder)
            ]
        };
    }
}
exports.WebviewImpl = WebviewImpl;
class WebviewPanelImpl {
    constructor(viewId, proxy, _viewType, _title, showOptions, _options, _webview) {
        this.viewId = viewId;
        this.proxy = proxy;
        this._viewType = _viewType;
        this._title = _title;
        this._options = _options;
        this._webview = _webview;
        this.isDisposed = false;
        this._active = true;
        this._visible = true;
        this.onDisposeEmitter = new event_1.Emitter();
        this.onDidDispose = this.onDisposeEmitter.event;
        this.onDidChangeViewStateEmitter = new event_1.Emitter();
        this.onDidChangeViewState = this.onDidChangeViewStateEmitter.event;
        this._showOptions = typeof showOptions === 'object' ? showOptions : { viewColumn: showOptions };
    }
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this.isDisposed = true;
        this.onDisposeEmitter.fire(undefined);
        this.proxy.$disposeWebview(this.viewId);
        this._webview.dispose();
        this.onDisposeEmitter.dispose();
        this.onDidChangeViewStateEmitter.dispose();
    }
    get viewType() {
        this.checkIsDisposed();
        return this._viewType;
    }
    get title() {
        this.checkIsDisposed();
        return this._title;
    }
    set title(newTitle) {
        this.checkIsDisposed();
        if (this._title !== newTitle) {
            this._title = newTitle;
            this.proxy.$setTitle(this.viewId, newTitle);
        }
    }
    get iconPath() {
        return this._iconPath;
    }
    set iconPath(iconPath) {
        this.checkIsDisposed();
        if (this._iconPath !== iconPath) {
            this._iconPath = iconPath;
            this.proxy.$setIconPath(this.viewId, plugin_icon_path_1.PluginIconPath.toUrl(iconPath, this._webview.plugin));
        }
    }
    get webview() {
        this.checkIsDisposed();
        return this._webview;
    }
    get options() {
        this.checkIsDisposed();
        return this._options;
    }
    get viewColumn() {
        this.checkIsDisposed();
        return this._showOptions.viewColumn;
    }
    setViewColumn(value) {
        this.checkIsDisposed();
        this._showOptions.viewColumn = value;
    }
    get showOptions() {
        this.checkIsDisposed();
        return this._showOptions;
    }
    setShowOptions(value) {
        this.checkIsDisposed();
        this._showOptions = value;
    }
    get active() {
        this.checkIsDisposed();
        return this._active;
    }
    setActive(value) {
        this.checkIsDisposed();
        this._active = value;
    }
    get visible() {
        this.checkIsDisposed();
        return this._visible;
    }
    setVisible(value) {
        this.checkIsDisposed();
        this._visible = value;
    }
    reveal(arg0, arg1, arg2) {
        let area = undefined;
        let viewColumn = undefined;
        let preserveFocus = undefined;
        if (typeof arg0 === 'number') {
            viewColumn = arg0;
        }
        else {
            area = arg0;
        }
        if (typeof arg1 === 'number') {
            viewColumn = arg1;
        }
        else {
            preserveFocus = arg1;
        }
        if (typeof arg2 === 'boolean') {
            preserveFocus = arg2;
        }
        this.checkIsDisposed();
        this.proxy.$reveal(this.viewId, {
            area,
            viewColumn: viewColumn ? (0, type_converters_1.fromViewColumn)(viewColumn) : undefined,
            preserveFocus
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    postMessage(message) {
        this.checkIsDisposed();
        return this.proxy.$postMessage(this.viewId, message);
    }
    checkIsDisposed() {
        if (this.isDisposed) {
            throw new Error('This WebviewPanel is disposed!');
        }
    }
}
exports.WebviewPanelImpl = WebviewPanelImpl;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/window-state.js":
/*!************************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/window-state.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WindowStateExtImpl = void 0;
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../packages/core/lib/common/event.js");
const uri_components_1 = __webpack_require__(/*! ../common/uri-components */ "../../packages/plugin-ext/lib/common/uri-components.js");
class WindowStateExtImpl {
    constructor(rpc) {
        this.windowStateChangedEmitter = new event_1.Emitter();
        this.onDidChangeWindowState = this.windowStateChangedEmitter.event;
        this.proxy = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.WINDOW_MAIN);
        this.windowStateCached = { focused: true }; // supposed tab is active on start
    }
    getWindowState() {
        return this.windowStateCached;
    }
    $onWindowStateChanged(focused) {
        const state = { focused: focused };
        if (state === this.windowStateCached) {
            return;
        }
        this.windowStateCached = state;
        this.windowStateChangedEmitter.fire(state);
    }
    openUri(uri) {
        return this.proxy.$openUri(uri);
    }
    async asExternalUri(target) {
        if (!target.scheme.trim().length) {
            throw new Error('Invalid scheme - cannot be empty');
        }
        if (uri_components_1.Schemes.http !== target.scheme && uri_components_1.Schemes.https !== target.scheme) {
            throw new Error(`Invalid scheme '${target.scheme}'`);
        }
        const uri = await this.proxy.$asExternalUri(target);
        return types_impl_1.URI.revive(uri);
    }
}
exports.WindowStateExtImpl = WindowStateExtImpl;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/word-helper.js":
/*!***********************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/word-helper.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getWordAtText = exports.ensureValidWordDefinition = exports.DEFAULT_WORD_REGEXP = exports.USUAL_WORD_SEPARATORS = void 0;
exports.USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\|;:\'",.<>/?';
/**
 * Create a word definition regular expression based on default word separators.
 * Optionally provide allowed separators that should be included in words.
 *
 * The default would look like this:
 * /(-?\d*\.\d\w*)|([^\`\~\!\@\#\$\%\^\&\*\(\)\-\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\?\s]+)/g
 */
function createWordRegExp(allowInWords = '') {
    let source = '(-?\\d*\\.\\d\\w*)|([^';
    for (let i = 0; i < exports.USUAL_WORD_SEPARATORS.length; i++) {
        if (allowInWords.indexOf(exports.USUAL_WORD_SEPARATORS[i]) >= 0) {
            continue;
        }
        source += '\\' + exports.USUAL_WORD_SEPARATORS[i];
    }
    source += '\\s]+)';
    return new RegExp(source, 'g');
}
// catches numbers (including floating numbers) in the first group, and alphanum in the second
exports.DEFAULT_WORD_REGEXP = createWordRegExp();
function ensureValidWordDefinition(wordDefinition) {
    let result = exports.DEFAULT_WORD_REGEXP;
    if (wordDefinition && (wordDefinition instanceof RegExp)) {
        if (!wordDefinition.global) {
            let flags = 'g';
            if (wordDefinition.ignoreCase) {
                flags += 'i';
            }
            if (wordDefinition.multiline) {
                flags += 'm';
            }
            result = new RegExp(wordDefinition.source, flags);
        }
        else {
            result = wordDefinition;
        }
    }
    result.lastIndex = 0;
    return result;
}
exports.ensureValidWordDefinition = ensureValidWordDefinition;
function getWordAtPosFast(column, wordDefinition, text, textOffset) {
    // find whitespace enclosed text around column and match from there
    const pos = column - 1 - textOffset;
    const start = text.lastIndexOf(' ', pos - 1) + 1;
    let end = text.indexOf(' ', pos);
    if (end === -1) {
        end = text.length;
    }
    wordDefinition.lastIndex = start;
    let match;
    while (match = wordDefinition.exec(text)) {
        if (match.index <= pos && wordDefinition.lastIndex >= pos) {
            return {
                word: match[0],
                startColumn: textOffset + 1 + match.index,
                endColumn: textOffset + 1 + wordDefinition.lastIndex
            };
        }
    }
    return undefined;
}
function getWordAtPosSlow(column, wordDefinition, text, textOffset) {
    // matches all words starting at the beginning
    // of the input until it finds a match that encloses
    // the desired column. slow but correct
    const pos = column - 1 - textOffset;
    wordDefinition.lastIndex = 0;
    let match;
    while (match = wordDefinition.exec(text)) {
        if (match.index > pos) {
            // |nW -> matched only after the pos
            return undefined;
        }
        else if (wordDefinition.lastIndex >= pos) {
            // W|W -> match encloses pos
            return {
                word: match[0],
                startColumn: textOffset + 1 + match.index,
                endColumn: textOffset + 1 + wordDefinition.lastIndex
            };
        }
    }
    return undefined;
}
function getWordAtText(column, wordDefinition, text, textOffset) {
    // if `words` can contain whitespace character we have to use the slow variant
    // otherwise we use the fast variant of finding a word
    wordDefinition.lastIndex = 0;
    const match = wordDefinition.exec(text);
    if (!match) {
        return undefined;
    }
    // todo@joh the `match` could already be the (first) word
    const ret = match[0].indexOf(' ') >= 0
        // did match a word which contains a space character -> use slow word find
        ? getWordAtPosSlow(column, wordDefinition, text, textOffset)
        // sane word definition -> use fast word find
        : getWordAtPosFast(column, wordDefinition, text, textOffset);
    // both (getWordAtPosFast and getWordAtPosSlow) leave the wordDefinition-RegExp
    // in an undefined state and to not confuse other users of the wordDefinition
    // we reset the lastIndex
    wordDefinition.lastIndex = 0;
    return ret;
}
exports.getWordAtText = getWordAtText;


/***/ }),

/***/ "../../packages/plugin-ext/lib/plugin/workspace.js":
/*!*********************************************************!*\
  !*** ../../packages/plugin-ext/lib/plugin/workspace.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// copied and modified from https://github.com/Microsoft/vscode/blob/master/src/vs/workbench/services/workspace/node/workspaceEditingService.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceExtImpl = void 0;
const paths = __webpack_require__(/*! path */ "path");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../packages/core/lib/common/event.js");
const cancellation_1 = __webpack_require__(/*! @theia/core/lib/common/cancellation */ "../../packages/core/lib/common/cancellation.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../../packages/plugin-ext/lib/common/plugin-api-rpc.js");
const path_1 = __webpack_require__(/*! @theia/core/lib/common/path */ "../../packages/core/lib/common/path.js");
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../../packages/plugin-ext/lib/plugin/types-impl.js");
const paths_1 = __webpack_require__(/*! @theia/core/lib/common/paths */ "../../packages/core/lib/common/paths.js");
const paths_util_1 = __webpack_require__(/*! ../common/paths-util */ "../../packages/plugin-ext/lib/common/paths-util.js");
const uri_components_1 = __webpack_require__(/*! ../common/uri-components */ "../../packages/plugin-ext/lib/common/uri-components.js");
const type_converters_1 = __webpack_require__(/*! ./type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const Converter = __webpack_require__(/*! ./type-converters */ "../../packages/plugin-ext/lib/plugin/type-converters.js");
const types_1 = __webpack_require__(/*! ../common/types */ "../../packages/plugin-ext/lib/common/types.js");
class WorkspaceExtImpl {
    constructor(rpc, editorsAndDocuments, messageService) {
        this.editorsAndDocuments = editorsAndDocuments;
        this.messageService = messageService;
        this.workspaceFoldersChangedEmitter = new event_1.Emitter();
        this.onDidChangeWorkspaceFolders = this.workspaceFoldersChangedEmitter.event;
        this.documentContentProviders = new Map();
        this.searchInWorkspaceEmitter = new event_1.Emitter();
        this.workspaceSearchSequence = 0;
        this._trusted = undefined;
        this.didGrantWorkspaceTrustEmitter = new event_1.Emitter();
        this.onDidGrantWorkspaceTrust = this.didGrantWorkspaceTrustEmitter.event;
        this.canonicalUriProviders = new Map();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.WORKSPACE_MAIN);
    }
    get rootPath() {
        const folder = this.folders && this.folders[0];
        return folder && folder.uri.fsPath;
    }
    get workspaceFolders() {
        if (this.folders && this.folders.length === 0) {
            return undefined;
        }
        return this.folders;
    }
    get workspaceFile() {
        return this.workspaceFileUri;
    }
    get name() {
        if (this.workspaceFolders && this.workspaceFolders.length > 0) {
            return new path_1.Path(this.workspaceFolders[0].uri.path).base;
        }
        return undefined;
    }
    resolveProxy(url) {
        return this.proxy.$resolveProxy(url);
    }
    $onWorkspaceFoldersChanged(event) {
        const newRoots = event.roots || [];
        const newFolders = newRoots.map((root, index) => this.toWorkspaceFolder(root, index));
        const delta = this.deltaFolders(this.folders, newFolders);
        this.folders = newFolders;
        this.refreshWorkspaceFile();
        this.workspaceFoldersChangedEmitter.fire(delta);
    }
    $onWorkspaceLocationChanged(stat) {
        this.updateWorkSpace(stat);
    }
    $onTextSearchResult(searchRequestId, done, result) {
        if (result) {
            result.matches.map(next => {
                const range = {
                    endColumn: next.character + next.length,
                    endLineNumber: next.line + 1,
                    startColumn: next.character,
                    startLineNumber: next.line + 1
                };
                const tRange = Converter.toRange(range);
                const searchResult = {
                    uri: types_impl_1.URI.parse(result.fileUri),
                    preview: {
                        text: typeof next.lineText === 'string' ? next.lineText : next.lineText.text,
                        matches: tRange
                    },
                    ranges: tRange
                };
                return searchResult;
            }).forEach(next => this.searchInWorkspaceEmitter.fire({ result: next, searchId: searchRequestId }));
        }
        else if (done) {
            this.searchInWorkspaceEmitter.fire({ searchId: searchRequestId });
        }
    }
    deltaFolders(currentFolders = [], newFolders = []) {
        const added = this.foldersDiff(newFolders, currentFolders);
        const removed = this.foldersDiff(currentFolders, newFolders);
        return { added, removed };
    }
    foldersDiff(folder1 = [], folder2 = []) {
        const map = new Map();
        folder1.forEach(folder => map.set(folder.uri.toString(), folder));
        folder2.forEach(folder => map.delete(folder.uri.toString()));
        return folder1.filter(folder => map.has(folder.uri.toString()));
    }
    toWorkspaceFolder(root, index) {
        const uri = types_impl_1.URI.parse(root);
        const path = new path_1.Path(uri.path);
        return {
            uri: uri,
            name: path.base,
            index: index
        };
    }
    pickWorkspaceFolder(options) {
        return new Promise((resolve, reject) => {
            const optionsMain = {
                placeHolder: options && options.placeHolder ? options.placeHolder : undefined,
                ignoreFocusOut: options && options.ignoreFocusOut
            };
            this.proxy.$pickWorkspaceFolder(optionsMain).then(value => {
                resolve(value);
            });
        });
    }
    findFiles(include, exclude, maxResults, token = cancellation_1.CancellationToken.None) {
        let includePattern;
        let includeFolderUri;
        if (include) {
            if (typeof include === 'string') {
                includePattern = include;
            }
            else {
                includePattern = include.pattern;
                includeFolderUri = include.baseUri.toString();
            }
        }
        else {
            includePattern = '';
        }
        let excludePatternOrDisregardExcludes;
        if (exclude === undefined) {
            excludePatternOrDisregardExcludes = ''; // default excludes
        }
        else if (exclude) {
            if (typeof exclude === 'string') {
                excludePatternOrDisregardExcludes = exclude;
            }
            else {
                excludePatternOrDisregardExcludes = exclude.pattern;
            }
        }
        else {
            excludePatternOrDisregardExcludes = false; // no excludes
        }
        if (token && token.isCancellationRequested) {
            return Promise.resolve([]);
        }
        return this.proxy.$startFileSearch(includePattern, includeFolderUri, excludePatternOrDisregardExcludes, maxResults, token)
            .then(data => Array.isArray(data) ? data.map(uri => types_impl_1.URI.revive(uri)) : []);
    }
    findTextInFiles(query, optionsOrCallback, callbackOrToken, token) {
        let options;
        let callback;
        if (typeof optionsOrCallback === 'object') {
            options = optionsOrCallback;
            callback = callbackOrToken;
        }
        else {
            options = {};
            callback = optionsOrCallback;
            token = callbackOrToken;
        }
        const nextSearchID = this.workspaceSearchSequence + 1;
        this.workspaceSearchSequence = nextSearchID;
        const disposable = this.searchInWorkspaceEmitter.event(searchResult => {
            if (searchResult.searchId === nextSearchID) {
                if (searchResult.result) {
                    callback(searchResult.result);
                }
                else {
                    disposable.dispose();
                }
            }
        });
        if (token) {
            token.onCancellationRequested(() => {
                disposable.dispose();
            });
        }
        return this.proxy.$findTextInFiles(query, options || {}, nextSearchID, token);
    }
    registerTextDocumentContentProvider(scheme, provider) {
        // `file` and `untitled` schemas are reserved by `workspace.openTextDocument` API:
        // `file`-scheme for opening a file
        // `untitled`-scheme for opening a new file that should be saved
        if (scheme === uri_components_1.Schemes.file || scheme === uri_components_1.Schemes.untitled) {
            throw new Error(`Text Content Document Provider for scheme '${scheme}' is already registered`);
        }
        else if (this.documentContentProviders.has(scheme)) {
            // TODO: we should be able to handle multiple registrations, but for now we should ensure that it doesn't crash plugin activation.
            console.warn(`Repeat registration of TextContentDocumentProvider for scheme '${scheme}'. This registration will be ignored.`);
            return { dispose: () => { } };
        }
        this.documentContentProviders.set(scheme, provider);
        this.proxy.$registerTextDocumentContentProvider(scheme);
        let onDidChangeSubscription;
        if (typeof provider.onDidChange === 'function') {
            onDidChangeSubscription = provider.onDidChange(async (uri) => {
                if (uri.scheme === scheme && this.editorsAndDocuments.getDocument(uri.toString())) {
                    const content = await this.$provideTextDocumentContent(uri.toString());
                    if (content) {
                        this.proxy.$onTextDocumentContentChange(uri.toString(), content);
                    }
                }
            });
        }
        const instance = this;
        return {
            dispose() {
                if (instance.documentContentProviders.delete(scheme)) {
                    instance.proxy.$unregisterTextDocumentContentProvider(scheme);
                }
                if (onDidChangeSubscription) {
                    onDidChangeSubscription.dispose();
                }
            }
        };
    }
    async $provideTextDocumentContent(documentURI) {
        const uri = types_impl_1.URI.parse(documentURI);
        const provider = this.documentContentProviders.get(uri.scheme);
        if (provider) {
            return provider.provideTextDocumentContent(uri, cancellation_1.CancellationToken.None);
        }
        return undefined;
    }
    getWorkspaceFolder(uri, resolveParent) {
        if (!this.folders || !this.folders.length) {
            return undefined;
        }
        function dirname(resource) {
            if (resource.scheme === 'file') {
                return types_impl_1.URI.file(paths.dirname(resource.fsPath));
            }
            return resource.with({
                path: paths.dirname(resource.path)
            });
        }
        if (resolveParent && this.hasFolder(uri)) {
            uri = dirname(uri);
        }
        const resourcePath = uri.toString();
        let workspaceFolder;
        for (let i = 0; i < this.folders.length; i++) {
            const folder = this.folders[i];
            const folderPath = folder.uri.toString();
            if (resourcePath === folderPath) {
                return (0, type_converters_1.toWorkspaceFolder)(folder);
            }
            if (resourcePath.startsWith(folderPath)
                && resourcePath[folderPath.length] === '/'
                && (!workspaceFolder || folderPath.length > workspaceFolder.uri.toString().length)) {
                workspaceFolder = folder;
            }
        }
        return workspaceFolder;
    }
    hasFolder(uri) {
        if (!this.folders) {
            return false;
        }
        return this.folders.some(folder => folder.uri.toString() === uri.toString());
    }
    getRelativePath(pathOrUri, includeWorkspace) {
        let path;
        if (typeof pathOrUri === 'string') {
            path = pathOrUri;
        }
        else if (typeof pathOrUri !== 'undefined') {
            path = pathOrUri.fsPath;
        }
        if (!path) {
            return path;
        }
        const folder = this.getWorkspaceFolder(typeof pathOrUri === 'string' ? types_impl_1.URI.file(pathOrUri) : pathOrUri, true);
        if (!folder) {
            return path;
        }
        if (typeof includeWorkspace === 'undefined') {
            includeWorkspace = this.folders.length > 1;
        }
        let result = (0, paths_util_1.relative)(folder.uri.fsPath, path);
        if (includeWorkspace) {
            result = `${folder.name}/${result}`;
        }
        return (0, paths_1.normalize)(result, true);
    }
    updateWorkspaceFolders(start, deleteCount, ...workspaceFoldersToAdd) {
        const rootsToAdd = new Set();
        if (Array.isArray(workspaceFoldersToAdd)) {
            workspaceFoldersToAdd.forEach(folderToAdd => {
                const uri = types_impl_1.URI.isUri(folderToAdd.uri) && folderToAdd.uri.toString();
                if (uri && !rootsToAdd.has(uri)) {
                    rootsToAdd.add(uri);
                }
            });
        }
        if ([start, deleteCount].some(i => typeof i !== 'number' || i < 0)) {
            return false; // validate numbers
        }
        if (deleteCount === 0 && rootsToAdd.size === 0) {
            return false; // nothing to delete or add
        }
        const currentWorkspaceFolders = this.workspaceFolders || [];
        if (start + deleteCount > currentWorkspaceFolders.length) {
            return false; // cannot delete more than we have
        }
        // Simulate the updateWorkspaceFolders method on our data to do more validation
        const newWorkspaceFolders = currentWorkspaceFolders.slice(0);
        newWorkspaceFolders.splice(start, deleteCount, ...[...rootsToAdd].map(uri => ({ uri: types_impl_1.URI.parse(uri), name: undefined, index: undefined })));
        for (let i = 0; i < newWorkspaceFolders.length; i++) {
            const folder = newWorkspaceFolders[i];
            if (newWorkspaceFolders.some((otherFolder, index) => index !== i && folder.uri.toString() === otherFolder.uri.toString())) {
                return false; // cannot add the same folder multiple times
            }
        }
        const { added, removed } = this.deltaFolders(currentWorkspaceFolders, newWorkspaceFolders);
        if (added.length === 0 && removed.length === 0) {
            return false; // nothing actually changed
        }
        // Trigger on main side
        this.proxy.$updateWorkspaceFolders(start, deleteCount, ...rootsToAdd).then(undefined, error => this.messageService.showMessage(plugin_api_rpc_1.MainMessageType.Error, `Failed to update workspace folders: ${error}`));
        return true;
    }
    async refreshWorkspaceFile() {
        const workspace = await this.proxy.$getWorkspace();
        this.updateWorkSpace(workspace);
    }
    updateWorkSpace(workspace) {
        // A workspace directory implies an undefined workspace file
        if (workspace && !workspace.isDirectory) {
            this.workspaceFileUri = types_impl_1.URI.parse(workspace.resource.toString());
        }
    }
    get trusted() {
        if (this._trusted === undefined) {
            this.requestWorkspaceTrust();
        }
        return !!this._trusted;
    }
    requestWorkspaceTrust(options) {
        return this.proxy.$requestWorkspaceTrust(options);
    }
    $onWorkspaceTrustChanged(trust) {
        if (!this._trusted && trust) {
            this._trusted = trust;
            this.didGrantWorkspaceTrustEmitter.fire();
        }
    }
    registerCanonicalUriProvider(scheme, provider) {
        if (this.canonicalUriProviders.has(scheme)) {
            throw new Error(`Canonical URI provider for scheme: '${scheme}' already exists locally`);
        }
        this.canonicalUriProviders.set(scheme, provider);
        this.proxy.$registerCanonicalUriProvider(scheme).catch(e => {
            console.error(`Canonical URI provider for scheme: '${scheme}' already exists globally`);
            this.canonicalUriProviders.delete(scheme);
        });
        const result = types_impl_1.Disposable.create(() => { this.proxy.$unregisterCanonicalUriProvider(scheme); });
        return result;
    }
    $disposeCanonicalUriProvider(scheme) {
        if (!this.canonicalUriProviders.delete(scheme)) {
            console.warn(`No canonical uri provider registered for '${scheme}'`);
        }
    }
    async getCanonicalUri(uri, options, token) {
        const canonicalUri = await this.proxy.$getCanonicalUri(uri.toString(), options.targetScheme, token);
        return (0, types_1.isUndefined)(canonicalUri) ? undefined : types_impl_1.URI.parse(canonicalUri);
    }
    async $provideCanonicalUri(uri, targetScheme, token) {
        const parsed = types_impl_1.URI.parse(uri);
        const provider = this.canonicalUriProviders.get(parsed.scheme);
        if (!provider) {
            console.warn(`No canonical uri provider registered for '${parsed.scheme}'`);
            return undefined;
        }
        const result = await provider.provideCanonicalUri(parsed, { targetScheme: targetScheme }, token);
        return (0, types_1.isUndefinedOrNull)(result) ? undefined : result.toString();
    }
    /** @stubbed */
    $registerEditSessionIdentityProvider(scheme, provider) {
        return types_impl_1.Disposable.NULL;
    }
}
exports.WorkspaceExtImpl = WorkspaceExtImpl;


/***/ }),

/***/ "../../packages/core/lib/node sync recursive":
/*!******************************************!*\
  !*** ../../packages/core/lib/node/ sync ***!
  \******************************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "../../packages/core/lib/node sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ "async_hooks":
/*!******************************!*\
  !*** external "async_hooks" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("async_hooks");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ "constants":
/*!****************************!*\
  !*** external "constants" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("constants");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "dns":
/*!**********************!*\
  !*** external "dns" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("dns");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "module":
/*!*************************!*\
  !*** external "module" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("module");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "pnpapi":
/*!*************************!*\
  !*** external "pnpapi" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("pnpapi");

/***/ }),

/***/ "punycode":
/*!***************************!*\
  !*** external "punycode" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("punycode");

/***/ }),

/***/ "querystring":
/*!******************************!*\
  !*** external "querystring" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("querystring");

/***/ }),

/***/ "readline":
/*!***************************!*\
  !*** external "readline" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("readline");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "string_decoder":
/*!*********************************!*\
  !*** external "string_decoder" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("string_decoder");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ "tty":
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "worker_threads":
/*!*********************************!*\
  !*** external "worker_threads" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("worker_threads");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ "../../packages/plugin-ext/package.json":
/*!**********************************************!*\
  !*** ../../packages/plugin-ext/package.json ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"@theia/plugin-ext","version":"1.41.0","description":"Theia - Plugin Extension","main":"lib/common/index.js","typings":"lib/common/index.d.ts","dependencies":{"@theia/bulk-edit":"1.41.0","@theia/callhierarchy":"1.41.0","@theia/console":"1.41.0","@theia/core":"1.41.0","@theia/debug":"1.41.0","@theia/editor":"1.41.0","@theia/editor-preview":"1.41.0","@theia/file-search":"1.41.0","@theia/filesystem":"1.41.0","@theia/markers":"1.41.0","@theia/messages":"1.41.0","@theia/monaco":"1.41.0","@theia/monaco-editor-core":"1.72.3","@theia/navigator":"1.41.0","@theia/notebook":"1.41.0","@theia/output":"1.41.0","@theia/plugin":"1.41.0","@theia/preferences":"1.41.0","@theia/scm":"1.41.0","@theia/search-in-workspace":"1.41.0","@theia/task":"1.41.0","@theia/terminal":"1.41.0","@theia/timeline":"1.41.0","@theia/typehierarchy":"1.41.0","@theia/variable-resolver":"1.41.0","@theia/workspace":"1.41.0","@types/mime":"^2.0.1","@vscode/debugprotocol":"^1.51.0","@vscode/proxy-agent":"^0.13.2","async-mutex":"^0.4.0","decompress":"^4.2.1","escape-html":"^1.0.3","filenamify":"^4.1.0","is-electron":"^2.2.0","jsonc-parser":"^2.2.0","lodash.clonedeep":"^4.5.0","macaddress":"^0.5.3","mime":"^2.4.4","ps-tree":"^1.2.0","semver":"^7.5.4","uuid":"^8.0.0","vhost":"^3.0.2","vscode-textmate":"^7.0.3"},"publishConfig":{"access":"public"},"theiaExtensions":[{"backend":"lib/plugin-ext-backend-module","backendElectron":"lib/plugin-ext-backend-electron-module","frontend":"lib/plugin-ext-frontend-module"},{"frontendElectron":"lib/plugin-ext-frontend-electron-module"}],"keywords":["theia-extension"],"license":"EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0","repository":{"type":"git","url":"https://github.com/eclipse-theia/theia.git"},"bugs":{"url":"https://github.com/eclipse-theia/theia/issues"},"homepage":"https://github.com/eclipse-theia/theia","files":["lib","src"],"scripts":{"build":"theiaext build","clean":"theiaext clean","compile":"theiaext compile","lint":"theiaext lint","test":"theiaext test","watch":"theiaext watch"},"devDependencies":{"@theia/ext-scripts":"1.41.0","@types/decompress":"^4.2.2","@types/escape-html":"^0.0.20","@types/lodash.clonedeep":"^4.5.3","@types/ps-tree":"^1.1.0"},"nyc":{"extends":"../../configs/nyc.json"}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// the startup function
/******/ 	__webpack_require__.x = () => {
/******/ 		// Load entry module and return exports
/******/ 		var __webpack_exports__ = __webpack_require__.O(undefined, ["vendors-node_modules_fuzzy_lib_fuzzy_js-node_modules_inversify_es_inversify_js-node_modules_i-374ef0","vendors-node_modules_phosphor_coreutils_lib_index_js-packages_core_node_modules_iconv-lite_li-d06203","vendors-node_modules_yargs_index_js","vendors-node_modules_fs-extra_lib_index_js","vendors-node_modules_reflect-metadata_Reflect_js","vendors-node_modules_deepmerge_dist_cjs_js-node_modules_express_index_js-node_modules_http-pr-e1c984","vendors-node_modules_theia_monaco-editor-core_esm_vs_base_common_severity_js-node_modules_the-0d5078","packages_core_lib_common_index_js","packages_plugin-ext_lib_common_plugin-api-rpc_js","packages_core_lib_node_messaging_ipc-channel_js-packages_core_lib_node_messaging_ipc-protocol_js","dev-packages_application-package_lib_api_js-packages_plugin-ext_lib_common_index_js","node_modules_express_lib_sync_recursive-node_modules_require-main-filename_sync_recursive-pac-c83c5f"], () => (__webpack_require__("../../packages/plugin-ext/lib/hosted/node/plugin-host.js")))
/******/ 		__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 		return __webpack_exports__;
/******/ 	};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks and sibling chunks for the entrypoint
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/require chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "loaded", otherwise not loaded yet
/******/ 		var installedChunks = {
/******/ 			"plugin-host": 1
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.O.require = (chunkId) => (installedChunks[chunkId]);
/******/ 		
/******/ 		var installChunk = (chunk) => {
/******/ 			var moreModules = chunk.modules, chunkIds = chunk.ids, runtime = chunk.runtime;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			for(var i = 0; i < chunkIds.length; i++)
/******/ 				installedChunks[chunkIds[i]] = 1;
/******/ 			__webpack_require__.O();
/******/ 		};
/******/ 		
/******/ 		// require() chunk loading for javascript
/******/ 		__webpack_require__.f.require = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					installChunk(require("./" + __webpack_require__.u(chunkId)));
/******/ 				} else installedChunks[chunkId] = 1;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		// no external install chunk
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/startup chunk dependencies */
/******/ 	(() => {
/******/ 		var next = __webpack_require__.x;
/******/ 		__webpack_require__.x = () => {
/******/ 			__webpack_require__.e("vendors-node_modules_fuzzy_lib_fuzzy_js-node_modules_inversify_es_inversify_js-node_modules_i-374ef0");
/******/ 			__webpack_require__.e("vendors-node_modules_phosphor_coreutils_lib_index_js-packages_core_node_modules_iconv-lite_li-d06203");
/******/ 			__webpack_require__.e("vendors-node_modules_yargs_index_js");
/******/ 			__webpack_require__.e("vendors-node_modules_fs-extra_lib_index_js");
/******/ 			__webpack_require__.e("vendors-node_modules_reflect-metadata_Reflect_js");
/******/ 			__webpack_require__.e("vendors-node_modules_deepmerge_dist_cjs_js-node_modules_express_index_js-node_modules_http-pr-e1c984");
/******/ 			__webpack_require__.e("vendors-node_modules_theia_monaco-editor-core_esm_vs_base_common_severity_js-node_modules_the-0d5078");
/******/ 			__webpack_require__.e("packages_core_lib_common_index_js");
/******/ 			__webpack_require__.e("packages_plugin-ext_lib_common_plugin-api-rpc_js");
/******/ 			__webpack_require__.e("packages_core_lib_node_messaging_ipc-channel_js-packages_core_lib_node_messaging_ipc-protocol_js");
/******/ 			__webpack_require__.e("dev-packages_application-package_lib_api_js-packages_plugin-ext_lib_common_index_js");
/******/ 			__webpack_require__.e("node_modules_express_lib_sync_recursive-node_modules_require-main-filename_sync_recursive-pac-c83c5f");
/******/ 			return next();
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// run startup
/******/ 	var __webpack_exports__ = __webpack_require__.x();
/******/ 	
/******/ })()
;
//# sourceMappingURL=plugin-host.js.map